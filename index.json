[{"categories":["spring"],"content":"介绍FactoryBean的使用方法和FactoryBean在Spring中的实现原理，执行流程。 ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:0:0","tags":["spring源码"],"title":"07 复杂对象的构建 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"1 FactoryBean 的作用 Spring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该FactoryBean的getObject方法所返回的对象。创建出来的对象是否属于单例由isSingleton中的返回决定。 一般情况下，Spring通过反射机制利用的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean的形式 以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个\u0026符号来获取。 ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:1:0","tags":["spring源码"],"title":"07 复杂对象的构建 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"2 FactoryBean 接口的定义 以下是 Spring 中 FactoryBean 接口的定义： public interface FactoryBean\u003cT\u003e { T getObject() throws Exception; Class\u003c?\u003e getObjectType(); default boolean isSingleton() { return true; } } ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:2:0","tags":["spring源码"],"title":"07 复杂对象的构建 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"3 应用场景 FactoryBean 通常是用来创建比较复杂的 bean，一般的 bean 直接用 xml 配置即可，但如果一个 bean 的创建过程中涉及到很多其他的 bean 和复杂的逻辑，用 xml 配置比较困难，这时可以考虑用 FactoryBean。 很多开源项目在集成 Spring 时都使用到 FactoryBean，比如 MyBatis3 提供 mybatis-spring 项目中的 org.mybatis.spring.SqlSessionFactoryBean： \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"/\u003e \u003c!-- 自动扫描mapping.xml文件 --\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"\u003e\u003c/property\u003e \u003c/bean\u003e public class SqlSessionFactoryBean implements FactoryBean\u003cSqlSessionFactory\u003e, InitializingBean, ApplicationListener\u003cApplicationEvent\u003e { // ... public SqlSessionFactory getObject() throws Exception { if (this.sqlSessionFactory == null) { this.afterPropertiesSet(); } return this.sqlSessionFactory; } // ... } ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:3:0","tags":["spring源码"],"title":"07 复杂对象的构建 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"4 源码分析 ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:4:0","tags":["spring源码"],"title":"07 复杂对象的构建 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"4.1 初次创建 AbstractBeanFactory 通过 getBean 向 IOC 容器获取被管理的 Bean。 AbstractBeanFactory.getBean() -\u003e doGetBean()。 来到 doGetBean()，看 bean 第一次创建实例后，调用的地方： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -\u003e { try { //创建Bean实例 return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); /* TODO 重要程度 5 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 否则调用FactoryBean的getObject(),且将返回的bean替换为getObject()的返回值。 FactoryBean接口很重要，具体应用场景见FactoryBean接口注释。 */ bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } } 可以看到，在 getSingleton() 之后，又调用了 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd)，给 bean 重新赋值，这里bean的实例就可能被改变了。 如果当前创建的 bean 是 FactoryBean 类型的，调用 getObjectForBeanInstance() 时，最终会返回 FactoryBean.getObject() 返回的对象，也就是最终 getBean() 返回的是这个 getObject() 获取到的实例。 以下是 getObjectForBeanInstance() 的源码： public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) { String currentlyCreatedBean = this.currentlyCreatedBean.get(); if (currentlyCreatedBean != null) { registerDependentBean(beanName, currentlyCreatedBean); } // 从父类方法中获取 return super.getObjectForBeanInstance(beanInstance, name, beanName, mbd); } } 这里调用到了父类的方法，继续看父类的方法： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) { // ... // 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) { return beanInstance; } Object object = null; // 如果BeanDefinition为null，从缓存中获取，doGetBean() 中传入的就是null // createBean后进入这里的话，传入的就不是null if (mbd == null) { object = getCachedObjectForFactoryBean(beanName); } if (object == null) { FactoryBean\u003c?\u003e factory = (FactoryBean\u003c?\u003e) beanInstance; if (mbd == null \u0026\u0026 containsBeanDefinition(beanName)) { mbd = getMergedLocalBeanDefinition(beanName); } boolean synthetic = (mbd != null \u0026\u0026 mbd.isSynthetic()); // 调用FactoryBean的getObject方法 object = getObjectFromFactoryBean(factory, beanName, !synthetic); } return object; } } 上面代码的尾部，调用到了 object = getObjectFromFactoryBean(factory, beanName, !synthetic)，这个方法中调用了 getObject()。 源码如下（关键点 - 注意源码中高亮部分）： public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry { protected Object getObjectFromFactoryBean(FactoryBean\u003c?\u003e factory, String beanName, boolean shouldPostProcess) { if (factory.isSingleton() \u0026\u0026 containsSingleton(beanName)) { synchronized (getSingletonMutex()) { Object object = this.factoryBeanObjectCache.get(beanName); if (object == null) { // 调用 factory.getObject(); object = doGetObjectFromFactoryBean(factory, beanName); Object alreadyThere = this.factoryBeanObjectCache.get(beanName); if (alreadyThere != null) { object = alreadyThere; } else { if (shouldPostProcess) { if (isSingletonCurrentlyInCreation(beanName)) { // Temporarily return non-post-processed object, not storing it yet.. return object; } beforeSingletonCreation(beanName); try { // 这里调用了BeanPostProcessor的后置处理 object = postProcessObjectFromFactoryBean(object, beanName); } catch (Throwable ex) { throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's singleton object failed\", ex); } finally { afterSingletonCreation(beanName); } } // 加入到缓存，缓存位置：BeanFactory的 factoryBeanO","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:4:1","tags":["spring源码"],"title":"07 复杂对象的构建 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"4.2 缓存中获取 从上面的代码分析中已经知道，最终调用了 getObject() 之后，会将这个实例缓存到一个变量中，这个变量是 factoryBeanObjectCache。 回到 doGetBean() 中开始的代码块，先从缓存中获取实例，如果获取到了，同样会调用 getObjectForBeanInstance()，判断实例是否是 FactoryBean 类型。 源码如下： Object sharedInstance = getSingleton(beanName); if (sharedInstance != null \u0026\u0026 args == null) { // ... // 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 // 否则将bean强转为FactoryBean类型，并调用getObject()方法返回。 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } 在 [06 循环依赖的实现原理 - getSingleton()] 中有提到，这里可能返回一个bean实例。实际上在 bean 第一次创建后，后面再获取都是从缓存中拿的。拿到了之后，经过一些处理，就返回。这个处理就是判断 FactoryBean 的处理。 从上面源码中可以看到，如果从缓存中获取到，会调用 getObjectForBeanInstance() 。很明显，在第一次创建 bean 实例时，就调用过这个方法，会把创建的结果缓存到 factoryBeanObjectCache 变量中，这里就直接从 factoryBeanObjectCache 变量中获取的实例。 最终，如果这个 bean 是 FactoryBean 类型，会被替换掉。 ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:4:2","tags":["spring源码"],"title":"07 复杂对象的构建 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"4.3 获取原始bean 关于获取原始bean的方式，在 beanName 前加一个前缀 \u0026，就可以获取到原始 bean 实例。 在 getObjectForBeanInstance() 中有这么一段源码： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) { // 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) { return beanInstance; } } } 看一下 isFactoryDereference() 的源码： public abstract class BeanFactoryUtils { public static boolean isFactoryDereference(@Nullable String name) { return (name != null \u0026\u0026 name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)); } } 可以看到，如果 beanName以 BeanFactory.FACTORY_BEAN_PREFIX 开头，就会返回true。 BeanFactory.FACTORY_BEAN_PREFIX 常量的声明： public interface BeanFactory { String FACTORY_BEAN_PREFIX = \"\u0026\"; } 结合上面的源码，如果 getBean() 时，传入的 beanName 是以 \u0026 开头，走到 getObjectForBeanInstance() 时，就不会执行 FactoryBean 的逻辑，而是直接返回 bean 实例。 ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:4:3","tags":["spring源码"],"title":"07 复杂对象的构建 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"本章着重介绍了spring中在多个bean有相互依赖关系时，是怎么样进行依赖注入的。","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"1 什么是循环依赖 在我们日常开发中，肯定存在这种情况：bean A 某个成员是 bean B，bean B 中某个属性是 bean A。那A类和B类就是相互依赖的关系，也叫循环依赖。 当然，也可以是这种情况 A -\u003e B -\u003e C -\u003e D -\u003e E -\u003e A。这种关系也是循环依赖。 ","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:1:0","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"2 循环依赖在spring中的实现原理 @Service public class CyclicGoodsServiceImpl implements CyclicGoodsService { @Autowired private CyclicOrderService cyclicOrderService; @Override public CyclicOrderService getCyclicOrderService() { return cyclicOrderService; } } ","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:2:0","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"2.1 源码分析 在这之前，先看一个简单的循环依赖代码案例： @Service public class CyclicGoodsServiceImpl implements CyclicGoodsService { @Autowired private CyclicOrderService cyclicOrderService; @Override public CyclicOrderService getCyclicOrderService() { return cyclicOrderService; } } @Service public class CyclicOrderServiceImpl implements CyclicOrderService { @Autowired private CyclicGoodsService cyclicGoodsService; @Override public CyclicGoodsService getCyclicGoodsService() { return cyclicGoodsService; } } @Slf4j public class ApplicationContextTest { @Test public void testCyclicDependence(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(\"top.wlz922.cyclic\"); CyclicGoodsService goodsService = context.getBean(CyclicGoodsService.class); CyclicOrderService orderService = context.getBean(CyclicOrderService.class); log.debug(goodsService.toString()); log.debug(orderService.toString()); } } 只是简单的打印一下两个Service类中属性的值，很明显是注入成功了。 以下是打印的内容： 19:34:42.334 [main] DEBUG top.wlz922.test.context.ApplicationContextTest 36 - top.wlz922.cyclic.CyclicGoodsServiceImpl@7fa98a66 19:34:42.335 [main] DEBUG top.wlz922.test.context.ApplicationContextTest 37 - top.wlz922.cyclic.CyclicOrderServiceImpl@15ff3e9e 前面的文章中已经分析过，spring中获取bean实例的方法是getBean()。在容器启动的时候，会调用这些方法，实例化单例bean实例。 直接来到doGetBean()，看以下代码： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { protected \u003cT\u003e T doGetBean(final String name, @Nullable final Class\u003cT\u003e requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { //转换beanName，这里传入进来的beanName可能是以\u0026开头的，这里会截掉\u0026 final String beanName = transformedBeanName(name); Object bean; /* TODO 这里多级缓存用于解决循环依赖问题。 注：循环依赖只能是属性见的依赖，不能是构造函数中参数的循环依赖。 从缓存（一级二级三级缓存依次获取，获取到就返回）中获取单例实例，如果获取到并且是无参构造函数，则将bean变量的值赋值。 */ // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null \u0026\u0026 args == null) { // 省略无关代码 // 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 // 否则将bean强转为FactoryBean类型，并调用getObject()方法返回。 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } // 省略无关代码... return (T) bean; } } 先跳过无关代码，看关键点。从上面代码中可以看出，在doGetBean()中先调用了getSingleton()，如果这个值不为空就调用getObjectForBeanInstance()，经过一定的处理（先不要关心具体处理了什么），返回这个bean实例。 可以先分析，从接收变量的变量名sharedInstance就可以看出来，这是一个bean实例。关键点就在getSingleton()方法，这里可能会获取到一个bean实例。 下面是 getSingleton() 源码： public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry { /** 一级缓存 里面存储的是bean实例，在bean实例化完成、依赖注入、代理生成等流程全部完成之后，会存储到这个容器中 */ /** Cache of singleton objects: bean name to bean instance. */ private final Map\u003cString, Object\u003e singletonObjects = new ConcurrentHashMap\u003c\u003e(256); /** * 三级缓存，在单例bean刚刚创建完成时，会将其封装成一个ObjectFactory对象，存储到这个容器中。键值是beanName。 * 从源码中可以看到，实际上是提供了一些通过BeanPostProcessor进行的扩展操作。这里不会执行，只是把这个扩展操作流程封装起来。 * 实际上，这里封装的一个函数式接口，在这里可以通过BeanPostProcessor进行一些扩展操作，其节点是bean实例化之后， * 在真正getBean时，会触发调用。 */ /** Cache of singleton factories: bean name to ObjectFactory. */ private final Map\u003cString, ObjectFactory\u003c?\u003e\u003e singletonFactories = new HashMap\u003c\u003e(16); /** * 二级缓存 从三级缓存获取后，会将bean实例存储到二级缓存，并从三级缓存中移除。这里封装了一个函数式接口的匿名实例， * 依赖注入过程中通过getBean方法获取这个实例时，可以对其进行一些指定操作，比如说aop代理对象生成，就可能在这里触发。 */ /** Cache of early singleton objects: bean name to bean instance. */ private final Map\u003cString, Object\u003e earlySingletonObjects = new HashMap\u003c\u003e(16); protected Object getSingleton(String beanName, boolean allowEarlyReference) { /** * 从一级缓存中取，如果有值，则返回。否则依次查找二级、三级缓存，如果最终从三级缓存中拿到值， * 则将bean对象升级到二级缓存，并把原值从三级缓存中移除。 */ Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null \u0026\u0026 isSingletonCurrentlyInCreation(beanName)) { synchronized (this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null \u0026\u0026 allowEarlyReference) { ObjectFactory\u003c?\u003e singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.ge","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:2:1","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"2.2 源码中要注意的细节 注意\r\r构造函数中的依赖注入不可以循环依赖，多例依赖注入也不可以循环依赖。 构造函数不允许循环依赖：很容易明白，如果想要创建一个对象，比如调用它的构造函数，即使反射调用也是如此。如果A构造函数依赖B，B构造函数中依赖A，那么构造函数就无法调用完成，对象也就无从创建。永远也拿不到提前暴露的对象引用。 多例情况：不允许循环依赖，由于是多例，每次getBean都会创建新的实例，假如代码中定义了有循环依赖的属性，如果被允许，就会陷入死循环。 \r\r 多例情况，如果有循环依赖，会抛出异常，源码如下： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { protected \u003cT\u003e T doGetBean(final String name, @Nullable final Class\u003cT\u003e requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { // Fail if we're already creating this bean instance: // We're assumably within a circular reference. // 多例不支持循环引用。多例时，如果返回指定的原型bean是否正在创建中，则抛出异常。 if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } } } 构造函数中如果有循环依赖，源码ConstructorResolver类中有这段代码，抛出异常： try { // 省略无关代码，如果这里有构造函数中的循环依赖，则抛出异常 }catch (BeansException ex) { throw new UnsatisfiedDependencyException( mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex); } ","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:2:2","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"2.3 流程梳理 例如有A、B两个类进行实例化，分别将对方的实例注入到自身成员中，代码如下（前文中类似案例）： @Service public class A { @Autowired private B b; } @Service public class B { @Autowired private A a; } 分析上面代码的执行流程： A 类无参构造函数实例化后， 设置三级缓存。 A 类 populateBean 进行依赖注入， 这里触发了属性 B 的 getBean 操作。 B 类无参构造函数实例化后，设置三级缓存。 B 类 populateBean 进行依赖注入，这里触发了属性 A 的 getBean 操作 A 类之前正在实例化， singletonsCurrentlyInCreation 集合中有已经有这个 A 实例了，三级缓存里面也有了，所以这时候是从三级缓存中拿到的提前暴露的 A 实例，该实例还没有进行属性 B 的依赖注入，属性 B 为空。 B 类拿到了 A 的提前暴露实例注入到属性 A 中了。 B 类实例化已经完成，B 类的实例化是由 A 类实例化中属性 B 的依赖注入触发的 getBean 操作进行的，现在 B 已经实例化，所以 A 类中属性 B 就可以完成依赖注入了，这时候 A 类 B 属性已经有值了。 B 类 A 属性指向的就是 A 类实例堆空间，所以这时候 B 类 A 属性也会有值了。 ","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:2:3","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"详细解读spring中bean的实例化流程，由于篇幅原因，循环依赖、一些流程节点的详细解析在后续文章中讨论。 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:0:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"1 常见的ApplicationContext实现类： spring容器都是从构造一个ApplicationContext对象开始的，以下是spring中常见的ApplicationContext实现。 容器：AbstractApplicationContext 抽象父类，核心(模板)方法 refresh()。 ClassPathXmlApplicationContext - XML方式启动。 AnnotationConfigWebApplicationContext - 注解方式启动，对局部代码进行测试时比较好用。 AnnotationConfigServletWebServerApplicationContext - SpringBoot启动默认使用的上下文类。 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:1:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"2 核心方法refresh() 。 在spring容器启动时，会调用到核心方法refrsh()。这个方法定义了spring容器初始化核心流程。包含创建beanFactory、XML解析、注解支持、后置处理器注册执行、BeanPostProcessor注册、Bean实例化等节点。 以下是spring中refresh()源码： public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext { @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. // 不太重要，预刷新，做一些准备工作。记录了启动时间戳，标记为活动，非关闭状态。 prepareRefresh(); /** * TODO 重点：解析xml配置文件，创建beanFactory，包装BeanDefinition */ // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 注册一些对事件、监听器等的支持 prepareBeanFactory(beanFactory); // 钩子方法，BeanFactory创建后，对BeanFactory的自定义操作。 // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // TODO 重点：这里调用了postProcessBeanDefinitionRegistry(registry);springboot中很多激活自动配置的注解都是通过这里导入的。 // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // TODO 重点：从beanFactory中获取所有的BeanPostProcessor，优先进行getBean操作，实例化 // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // 国际化支持 // Initialize message source for this context. initMessageSource(); // 初始化ApplicationEventMulticaster。 如果上下文中未定义，则使用SimpleApplicationEventMulticaster。 // Initialize event multicaster for this context. initApplicationEventMulticaster(); // 钩子方法，springBoot中的嵌入式tomcat就是通过此方法实现的 // Initialize other special beans in specific context subclasses. onRefresh(); // 监听器注册 // Check for listener beans and register them. registerListeners(); // TODO 重点方法：完成容器中bean的实例化，及代理的生成等操作。 // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // 完成此上下文的刷新，调用LifecycleProcessor的onRefresh（）方法并发布 // Last step: publish corresponding event. finishRefresh(); // ... 省略无关代码 } } } ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:2:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"3 Bean实例化入口，getBean() bean实例化的入口是getBean()。对于单例Bean（实际开发中大多数都是单例），在初始化过程中，是从refresh()中，调用到finishBeanFactoryInitialization()，然后调用到preInstantiateSingletons()。 在preInstantiateSingletons()中（DefaultListableBeanFactory类中），调用到了getBean()，源码如下： public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable { @Override public void preInstantiateSingletons() throws BeansException { // 容器中所有的beanName，循环、实例化 // Iterate over a copy to allow for init methods which in turn register new bean definitions. // While this may not be part of the regular factory bootstrap, it does otherwise work fine. List\u003cString\u003e beanNames = new ArrayList\u003c\u003e(this.beanDefinitionNames); // 循环调用，进行实例化 // Trigger initialization of all non-lazy singleton beans... for (String beanName : beanNames) { RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 非抽象的、单例的、并且非懒加载的，才会在容器启动时就实例化。 if (!bd.isAbstract() \u0026\u0026 bd.isSingleton() \u0026\u0026 !bd.isLazyInit()) { if (isFactoryBean(beanName)) { Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) { final FactoryBean\u003c?\u003e factory = (FactoryBean\u003c?\u003e) bean; boolean isEagerInit; if (System.getSecurityManager() != null \u0026\u0026 factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged((PrivilegedAction\u003cBoolean\u003e) ((SmartFactoryBean\u003c?\u003e) factory)::isEagerInit, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean \u0026\u0026 ((SmartFactoryBean\u003c?\u003e) factory).isEagerInit()); } if (isEagerInit) { getBean(beanName); } } } else { getBean(beanName); } } } } } 注意\r\r从以上源码中可以看到，在已经搜集好的BeanDefinition集合中，只有非抽象的、单例的、并且非懒加载的，才会在容器启动时就实例化。\r\r ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:3:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"4 实例化主流程 暂且忽略无关代码，仅关注单例情况下，spring容器启动过程中bean的实例化。 public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { @SuppressWarnings(\"unchecked\") protected \u003cT\u003e T doGetBean(final String name, @Nullable final Class\u003cT\u003e requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { /* TODO 重要程度 5 单例实例第一次创建bean入口，这里的getSingleton方法中，调用了参数中匿名对象的getObject() 在bean创建完成后，将bean放入到一级缓存，并从二三级缓存中移除:addSingleton(beanName, singletonObject); */ // Create bean instance. if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -\u003e { try { //创建Bean实例 return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); /* TODO 重要程度 5 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 否则调用FactoryBean的getObject(),且将返回的bean替换为getObject()的返回值。 FactoryBean接口很重要，具体应用场景见FactoryBean接口注释。 */ bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } } } 其中有三个关键的方法，分别是getSingleton()、函数接口（ObjectFactory）中的createBean()、以及最后调用的getObjectForBeanInstance()。 getSingleton()中调用到了匿名函数中的getObject()，这个getObject就是外围方法中的lambda表达式中的方法，这里面调用了createBean()。 来到createBean(): public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { @Override protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { // ...省略无关代码 // 这里如果满足条件，会调用 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()和 // BeanPostProcessor.postProcessAfterInitialization()，直接返回。 // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } // ...省略无关代码 //创建Bean实例 Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isTraceEnabled()) { logger.trace(\"Finished creating instance of bean '\" + beanName + \"'\"); } return beanInstance; } } 在createBean中，doCreateBean()是真正创建Bean实例的方法。在此之前，spring预留了一个扩展点，通过实现InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()方法，可以通过BeanPostProcessor返回一个实例，这时候就不会再调用doCreateBean了。 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()的调用逻辑（源码中文注释中，详细描述了它的调用过程）： public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { @Nullable protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) { Object bean = null; // 如果满足条件，会在这里通过InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()进行实例化。 // 如果此方法最终返回的值不为空，则会调用所有BeanPostProcessor的postProcessAfterInitialization()， // 标记是否已经提前实例化了bean，然后返回。 if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) { // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() \u0026\u0026 hasInstantiationAwareBeanPostProcessors()) { Class\u003c?\u003e targetType = determineTargetType(beanName, mbd); if (targetType != null) { bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) { bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); } } } mbd.beforeInstantiationResolved = (bean != null); } return bean; } } 在doCreateBean中，经历了以下调用流程。 createBeanInstance：创建bean实例，这里真正创建了bean的实例。 applyMergedBeanDefinitionPostProcessors：这里是BeanPostProcessor的一个扩展点，添加了PostConstruct、PreDestroy、Autowired、Value、Inject注解的支持。官方注释是：将MergedBeanDefinitionPostProcessors应用于指定的bean定义，调用其{@code postProcessMergedBeanDefinition}方法。 populateBean：完成了依赖注入。其原理是通过调用InstantiationAwareBeanPostProcessor.postProcessProperties()（spring5.1版本开始）、InstantiationAwareBeanPostProcessor.postProcessPropertyValues()（spring5.1版本之前）。也是一个BeanPostProcessor扩展点。 initializeBean：初始化bean。bean的init","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:4:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"5 创建实例，createBeanInstance 在创建bean实例中，主要经历了一下流程： 判断，只有public修饰的类，才可以被创建，否则直接抛出异常。 通过BeanDefinition中的回调，来创建Bean实例。 使用FactoryMethod来创建实例，factory-method标签属性，或者@bean注解。 重新创建相同的Bean。 通过构造函数注入参数。 使用无参构造函数。（这里是重点，大多数情况下，都是使用的无参构造。） 任何一个流程有结果，就会直接创建bean的实例，并返回。 从源码中可以清晰的看出以上结论： public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) { // Make sure bean class is actually resolved at this point. Class\u003c?\u003e beanClass = resolveBeanClass(mbd, beanName); // 只有public修饰的class才可以被创建 if (beanClass != null \u0026\u0026 !Modifier.isPublic(beanClass.getModifiers()) \u0026\u0026 !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); } // 通过BeanDefinition中的回调，来创建bean实例。一般不会走到这个条件里。 Supplier\u003c?\u003e instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) { return obtainFromSupplier(instanceSupplier, beanName); } // 使用FactoryMethod创建bean实例。factory-method标签属性，或者@Bean注解标注的方法，会从这里创建实例。 if (mbd.getFactoryMethodName() != null) { return instantiateUsingFactoryMethod(beanName, mbd, args); } // 重新创建相同bean，会走到这里。 // Shortcut when re-creating the same bean... boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } if (resolved) { if (autowireNecessary) { return autowireConstructor(beanName, mbd, null, null); } else { return instantiateBean(beanName, mbd); } } // 判断是否是通过构造函数注入参数，如果是，则通过@Autowired标注的构造函数实例化。 // Candidate constructors for autowiring? Constructor\u003c?\u003e[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { return autowireConstructor(beanName, mbd, ctors, args); } // 默认构造的首选函数 // Preferred constructors for default construction? ctors = mbd.getPreferredConstructors(); if (ctors != null) { return autowireConstructor(beanName, mbd, ctors, null); } // 使用无参构造实例化bean，实际大多数bean的实例化，都是走的这个方法。 // No special handling: simply use no-arg constructor. return instantiateBean(beanName, mbd); } } 记录一下无参构造函数创建实例的过程： getInstantiationStrategy()：获取bean的实例化策略对象，默认使用的CglibSubclassingInstantiationStrategy。 instantiate(mbd, beanName, parent)：实例化bean。 instantiate -\u003e BeanUtils.instantiateClass() -\u003e ctor.newInstance()。反射调用无参构造函数，创建对象。 源码如下： public class SimpleInstantiationStrategy implements InstantiationStrategy { // 第一步 @Override public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) { // Don't override the class with CGLIB if no overrides. if (!bd.hasMethodOverrides()) { // 省略无关代码... // 获取无参构造函数 constructorToUse = clazz.getDeclaredConstructor(); bd.resolvedConstructorOrFactoryMethod = constructorToUse; // 省略无关代码... // TODO 实例化bean return BeanUtils.instantiateClass(constructorToUse); } else { // Must generate CGLIB subclass. return instantiateWithMethodInjection(bd, beanName, owner); } } } public abstract class BeanUtils { // 第二步 public static \u003cT\u003e T instantiateClass(Constructor\u003cT\u003e ctor, Object... args) throws BeanInstantiationException { Assert.notNull(ctor, \"Constructor must not be null\"); // 设置构造函数setAccessible=true // newInstance:反射调用构造函数，创建bean对象。 ReflectionUtils.makeAccessible(ctor); return (KotlinDetector.isKotlinReflectPresent() \u0026\u0026 KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ? KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args)); // 省略无关代码... } } 源码中最后一行 ctor.newInstance(args) 创建了bean实例。然后逐层向上返回。 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:5:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"6 注解支持，applyMergedBeanDefinitionPostProcessors 这里执行了MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()方法。spring会加载在之前的流程中注册的MergedBeanDefinitionPostProcessor（BeanPostProcessor的子接口），并对其进行调用。比较典型的两个类，完成了@Autowried、@Value、@Injected、@PostConstruct、@PreDestroy等注解的支持 调用入口源码如下： public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class\u003c?\u003e beanType, String beanName) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof MergedBeanDefinitionPostProcessor) { MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp; bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName); } } } } 两个比较典型的实现：AutowiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:6:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"6.1 AutowiredAnnotationBeanPostProcessor AutowiredAnnotationBeanPostProcessor中存储了需要@Autowired注入的一些信息映射。 构造函数中添加了对应注解的支持，postProcessMergedBeanDefinition()中查找带有Autowired注解的成员的属性信息信息，并将搜集结果封装缓存起来。 public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { /** * 在依赖注入之前，调用此方法搜集需要依赖注入的类的信息，并封装成InjectionMetadata对象，缓存到当前BeanPostProcessor实例中。 * * @param beanDefinition the merged bean definition for the bean * @param beanType the actual type of the managed bean instance * @param beanName the name of the bean */ @Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class\u003c?\u003e beanType, String beanName) { // 查找带有Autowired注解的成员的属性信息信息。 InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); } } 此类完成了对@AutoWried、@Value、@Injected注解的支持。 执行buildAutowiringMetadata方法，完成的注解支持，之后会把结果缓存到injectionMetadataCache变量中。 构建元数据的过程： 循环目标Class的所有字段，查找@Autowired注解。如果查找到，将注解属性封装成AutowiredFieldElement，并封装到一个list中。 循环目标Class的所有方法，查找@Autowired注解，如果找到，将注解属性封装成AutowiredMethodElement，并封装到一个list中。 将以上两个步骤得到的结果，封装为InjectionMetadata，返回。即InjectionMetadata中包含了需要@Autowired的字段和方法。 public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { // 无参构造函数中添加了对应注解的支持 public AutowiredAnnotationBeanPostProcessor() { // 初始化autowiredAnnotationTypes，这里添加了Autowired Value Inject注解的支持 this.autowiredAnnotationTypes.add(Autowired.class); this.autowiredAnnotationTypes.add(Value.class); try { this.autowiredAnnotationTypes.add((Class\u003c? extends Annotation\u003e) ClassUtils.forName(\"javax.inject.Inject\", AutowiredAnnotationBeanPostProcessor.class.getClassLoader())); logger.trace(\"JSR-330 'javax.inject.Inject' annotation found and supported for autowiring\"); } catch (ClassNotFoundException ex) { // JSR-330 API not available：simply skip. } } private InjectionMetadata buildAutowiringMetadata(final Class\u003c?\u003e clazz) { List\u003cInjectionMetadata.InjectedElement\u003e elements = new ArrayList\u003c\u003e(); Class\u003c?\u003e targetClass = clazz; do { final List\u003cInjectionMetadata.InjectedElement\u003e currElements = new ArrayList\u003c\u003e(); // 循环所有的字段，并以此字段为参数，执行回调。 ReflectionUtils.doWithLocalFields(targetClass, field -\u003e { // 查找当前带有autowiredAnnotationTypes中支持的注解的字段。 AnnotationAttributes ann = findAutowiredAnnotation(field); if (ann != null) { if (Modifier.isStatic(field.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\"Autowired annotation is not supported on static fields: \" + field); } return; } boolean required = determineRequiredStatus(ann); currElements.add(new AutowiredFieldElement(field, required)); } }); // 循环所有的方法，并以此方法为参数，执行回调。 ReflectionUtils.doWithLocalMethods(targetClass, method -\u003e { Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) { return; } // 查找当前带有autowiredAnnotationTypes中支持的注解的方法。 AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod); if (ann != null \u0026\u0026 method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) { if (Modifier.isStatic(method.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\"Autowired annotation is not supported on static methods: \" + method); } return; } if (method.getParameterCount() == 0) { if (logger.isInfoEnabled()) { logger.info(\"Autowired annotation should only be used on methods with parameters: \" + method); } } boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); currElements.add(new AutowiredMethodElement(method, required, pd)); } }); elements.addAll(0, currElements); targetClass = targetClass.getSuperclass(); } while (targetClass != null \u0026\u0026 targetClass != Object.class); return new InjectionMetadata(clazz, elements); } @Nullable private AnnotationA","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:6:1","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"6.2 CommonAnnotationBeanPostProcessor CommonAnnotationBeanPostProcessor是InitDestroyAnnotationBeanPostProcessor的子类，也是一个BeanPostProcessor。设置了@PostConstruct、@PreDestroy、@Resource注解的支持。 注意\r\r 两个比较重要的成员变量（初始化、销毁方法）是在InitDestroyAnnotationBeanPostProcessor定义的。 @PostConstruct、@PreDestroy注解支持是在CommonAnnotationBeanPostProcessor的无参构造函数中设置的。 \r\r public class InitDestroyAnnotationBeanPostProcessor implements DestructionAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor, PriorityOrdered, Serializable { @Nullable private Class\u003c? extends Annotation\u003e initAnnotationType; @Nullable private Class\u003c? extends Annotation\u003e destroyAnnotationType; } public class CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor implements InstantiationAwareBeanPostProcessor, BeanFactoryAware, Serializable { public CommonAnnotationBeanPostProcessor() { // 这里设置了PostConstruct、PreDestroy注解的支持。 setOrder(Ordered.LOWEST_PRECEDENCE); setInitAnnotationType(PostConstruct.class); setDestroyAnnotationType(PreDestroy.class); ignoreResourceType(\"javax.xml.ws.WebServiceContext\"); } } 搜集支持的元素并封装的流程： 先执行父类的搜集逻辑，这里设置了@PostConstruct、@PreDestroy注解的支持。 执行本类中的搜集逻辑，这里设置了@Resource注解的支持。 public class CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor implements InstantiationAwareBeanPostProcessor, BeanFactoryAware, Serializable { @Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class\u003c?\u003e beanType, String beanName) { // 先调用父类的方法，查找支持的元素，进行封装 super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName); // 在调用本类中的方法，也是查找支持的元素，进行封装 InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); } } 在真正执行搜集注解逻辑之前，有一个锁的使用方式。父类和子类此方法中都有体现。先不加锁获取，如果为空，再加锁，尝试获取，如果加锁下获取还是空，则执行搜集逻辑，搜集完之后会放入缓存。缓存的map是非线程安全的。 如果我们存储一组数据，这组数据只需要存储一次，后面全部都是get操作，那么就可以使用这种非线程安全的集合（非线程安全的集合的get操作性能远高于线程安全集合）。在存储的时候，以先重试，再加锁的方式进行处理。更多关于线程安全的问题，在并发编程的知识模块里记录。 这里列举一个父类中的方法： public class InitDestroyAnnotationBeanPostProcessor implements DestructionAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor, PriorityOrdered, Serializable { private LifecycleMetadata findLifecycleMetadata(Class\u003c?\u003e clazz) { if (this.lifecycleMetadataCache == null) { // Happens after deserialization, during destruction... return buildLifecycleMetadata(clazz); } // Quick check on the concurrent map first, with minimal locking. LifecycleMetadata metadata = this.lifecycleMetadataCache.get(clazz); if (metadata == null) { synchronized (this.lifecycleMetadataCache) { metadata = this.lifecycleMetadataCache.get(clazz); if (metadata == null) { // 上面代码是缓存，这里加锁的技巧，先无锁尝试，尝试失败再加锁。 // 细节：加锁中需要再次尝试获取一次。 metadata = buildLifecycleMetadata(clazz); this.lifecycleMetadataCache.put(clazz, metadata); } return metadata; } } return metadata; } } InitDestroyAnnotationBeanPostProcessor中搜集初始化、销毁方法的逻辑：根据成员变量（赋值的逻辑前文中有）initAnnotationType、destroyAnnotationType的类型，循环判断方法中是否有对应注解，有就缓存到对应集合中。遍历完所有方法之后将最终的结果封装成LifecycleMetadata 代码如下： public class InitDestroyAnnotationBeanPostProcessor implements DestructionAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor, PriorityOrdered, Serializable { private LifecycleMetadata buildLifecycleMetadata(final Class\u003c?\u003e clazz) { List\u003cLifecycleElement\u003e initMethods = new ArrayList\u003c\u003e(); List\u003cLifecycleElement\u003e destroyMethods = new ArrayList\u003c\u003e(); Class\u003c?\u003e targetClass = clazz; do { final List\u003cLifecycleElement\u003e currInitMethods = new ArrayList\u003c\u003e(); final List\u003cLifecycleElement\u003e currDestroyMethods = new ArrayList\u003c\u003e(); // 循环遍历所有的方法，查找初始化、销毁方法，如果查找到，就封装为LifecycleMetadata返回。 ReflectionUtils.doWithLocalMethods(targetClass, method -\u003e { if (this.initAnnotationType != null \u0026\u0026 method.isAnnotationPresent(this.initAnnotationType)) { LifecycleElement element = new LifecycleElement(method); currInitMethods.add(element); if (logger.isTraceEnabled()) { logger.trace(\"Found init method on class [\" + clazz.getName() + \"]: \" + method); } } if (this.destroyAnnotationType != null \u0026\u0026 method.isAnnotationPres","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:6:2","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"7 依赖注入，populateBean populateBean的作用是完成bean属性的依赖注入。 依赖注入之前，如果BeanDefinition是合成的，有InstantiationAwareBeanPostProcessor实例存在于ioc容器，那么将会执行容器中所有InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()，如果有一个方法返回false，则直接中断并返回。依赖注入不再进行。（它的用途暂时未知，如果这里返回false导致了一些问题，那么排查起来也是比较困难的，因为它没有任何提示信息输出） 通过调用InstantiationAwareBeanPostProcessor.postProcessProperties()完成属性的依赖注入（spring5.1之前的版本调用的postProcessPropertyValues()）。 由于是遍历容器中注册的BeanPostProcessor，找出是InstantiationAwareBeanPostProcessor类型的，这里不同的注入方式会有不同的实现类。与前文中说明的搜集依赖注入有关注解的方法是一样的，实现类也是同一个。遍历过程中会一个个的调用。由于这些BeanPostProcessor中在前面流程中已经缓存了需要依赖注入的内容。这里就可以根据缓存的内容进行获取，依次设置值到对应属性中了。 这里列举几个常见的注入流程 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:7:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"7.1 AutowiredFieldElement 它是对@Autowired标注在字段上的注入支持。 在前文中postProcessMergedBeanDefinition流程节点，添加@Autowired注解支持的时候，就把对应数据放入到了缓存中，成员变量injectionMetadataCache就是对应的缓存。 首先会调用findAutowiringMetadata()方法，获取元数据，这里直接从缓存injectionMetadataCache中拿的。 public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { // 这两个成员变量中，在前面执行postProcessMergedBeanDefinition时，已经缓存了需要注入的元数据。 private final Map\u003cString, InjectionMetadata\u003e injectionMetadataCache = new ConcurrentHashMap\u003c\u003e(256); @Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) { // 找到Autowiring注解标注的属性和方法，并封装为InjectionMetadata返回。 InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); // TODO 依赖注入的具体逻辑，重点看 metadata.inject(bean, beanName, pvs); // 省略无关代码... return pvs; } } 来到inject()方法，可以看到，遍历InjectionMetadata中缓存的injectedElements，然后执行每一个InjectedElement的inject()方法，这里就是@Autowired注入的核心逻辑： public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { Collection\u003cInjectedElement\u003e checkedElements = this.checkedElements; Collection\u003cInjectedElement\u003e elementsToIterate = (checkedElements != null ? checkedElements : this.injectedElements); if (!elementsToIterate.isEmpty()) { for (InjectedElement element : elementsToIterate) { // 执行依赖注入 element.inject(target, beanName, pvs); } } } } 从前文中已经知道，@Autowired的注解搜集，把字段和方法分成了两类来进行封装，分别是：AutowiredFieldElement、AutowiredMethodElement。 先来到AutowiredFieldElement的inject()方法： private class AutowiredFieldElement extends InjectionMetadata.InjectedElement { @Override protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { // 字段的自动注入 Field field = (Field) this.member; Object value; if (this.cached) { value = resolvedCachedArgument(beanName, this.cachedFieldValue); } else { DependencyDescriptor desc = new DependencyDescriptor(field, this.required); desc.setContainingClass(bean.getClass()); Set\u003cString\u003e autowiredBeanNames = new LinkedHashSet\u003c\u003e(1); Assert.state(beanFactory != null, \"No BeanFactory available\"); TypeConverter typeConverter = beanFactory.getTypeConverter(); try { // 处理依赖项 value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); } catch (BeansException ex) { throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex); } // 省略无关代码... } // 执行字段赋值逻辑。 if (value != null) { ReflectionUtils.makeAccessible(field); field.set(bean, value); } } } 获取依赖对象的方法调用链： |-\u003e resolveDependency |-|-\u003e doResolveDependency |-|-|-\u003e findAutowireCandidates |-|-|-|-\u003e addCandidateEntry |-|-|-|-|-\u003e descriptor.resolveCandidate |-|-|-|-|-|-\u003e beanFactory.getBean 最终还是调用到了getBean()方法。也就是经过一系列的处理，最终调用getBean()方法，获取到依赖的对象实例，返回，赋值。从上面代码可以看到，最后使用反射field.set()进行字段赋值。 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:7:1","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"7.2 AutowiredMethodElement 它是对@Autowired标注在方法上的注入支持。 通过方法@Autowired注入的流程是：先获取参数列表中依赖的实例对象，最终一定是会调用到getBean()方法。然后通过反射调用对应方法。 来到AutowiredMethodElement.inject()方法 private class AutowiredMethodElement extends InjectionMetadata.InjectedElement { @Override protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { if (checkPropertySkipping(pvs)) { return; } Method method = (Method) this.member; Object[] arguments; if (this.cached) { // Shortcut for avoiding synchronization... arguments = resolveCachedArguments(beanName); } else { Class\u003c?\u003e[] paramTypes = method.getParameterTypes(); arguments = new Object[paramTypes.length]; DependencyDescriptor[] descriptors = new DependencyDescriptor[paramTypes.length]; Set\u003cString\u003e autowiredBeans = new LinkedHashSet\u003c\u003e(paramTypes.length); Assert.state(beanFactory != null, \"No BeanFactory available\"); TypeConverter typeConverter = beanFactory.getTypeConverter(); for (int i = 0; i \u003c arguments.length; i++) { MethodParameter methodParam = new MethodParameter(method, i); DependencyDescriptor currDesc = new DependencyDescriptor(methodParam, this.required); currDesc.setContainingClass(bean.getClass()); descriptors[i] = currDesc; try { // 获取参数中依赖的对象 Object arg = beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter); if (arg == null \u0026\u0026 !this.required) { arguments = null; break; } arguments[i] = arg; } catch (BeansException ex) { throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(methodParam), ex); } } // 省略无关代码... } if (arguments != null) { try { // 反射调用 ReflectionUtils.makeAccessible(method); method.invoke(bean, arguments); } catch (InvocationTargetException ex) { throw ex.getTargetException(); } } } } 获取依赖对象的方法调用链： |-\u003e resolveDependency |-|-\u003e doResolveDependency |-|-|-\u003e findAutowireCandidates |-|-|-|-\u003e addCandidateEntry |-|-|-|-|-\u003e descriptor.resolveCandidate |-|-|-|-|-|-\u003e beanFactory.getBean 仔细看一下，其实获取依赖对象本身，是和使用字段注入的获取方式一样的，调用的方法没有任何变化。不同之处在于外围方法，字段注入时只获取一个实例，方法则可能是多个实例，是一个数组，所以方法获取依赖属性时，以遍历的方式去执行以上流程的。 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:7:2","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"7.3 ResourceElement 它是对@Resource注解标注在字段/方法上的注入支持。 与上面流程一样，来到inject()方法，这里调用到了父类InjectedElement的inject()方法： public abstract static class InjectedElement { protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs) throws Throwable { if (this.isField) { Field field = (Field) this.member; ReflectionUtils.makeAccessible(field); // 字段赋值 关键点看getResourceToInject field.set(target, getResourceToInject(target, requestingBeanName)); } else { if (checkPropertySkipping(pvs)) { return; } try { Method method = (Method) this.member; ReflectionUtils.makeAccessible(method); // 方法赋值 关键点看getResourceToInject method.invoke(target, getResourceToInject(target, requestingBeanName)); } catch (InvocationTargetException ex) { throw ex.getTargetException(); } } } @Override protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) { return (this.lazyLookup ? buildLazyResourceProxy(this, requestingBeanName) : getResource(this, requestingBeanName)); } } 获取依赖对象的方法调用链： |-\u003e getResourceToInject |-|-\u003e getResource |-|-|-\u003e autowireResource |-|-|-|-\u003e factory.getBean ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:7:3","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"8 AOP、事务支持，initializeBean 外围方法节点： postProcessBeforeInitialization() bean实例化之后，初始化方法执行之前调用。 invokeInitMethods() bean的初始化方法，@PostContructor注解的方法、或者配置文件配置的。 postProcessAfterInitialization() bean实例化之后，初始化方法执行之后调用，也是AOP的入口。事务的入口不在这，但跟它有关，事务的Advisor对象是在这里填充到AOP的执行链的。 源码如下： public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // BeanPostProcessor.postProcessBeforeInitialization() // 顾名思义，在bean实例创建完成并依赖注入后，初始化方法执行之前，会执行此方法。 // AOP的BeanPostProcessor也实现了这个方法，只是直接返回了原始对象。真正入口在后置处理。 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { // 执行初始化方法，InitializingBean实例的afterPropertiesSet，或者init-method或者@PostConstructor标注的方法 invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); } if (mbd == null || !mbd.isSynthetic()) { // BeanPostProcessor.postProcessAfterInitialization() // 顾名思义，在bean实例创建完成并依赖注入后，初始化方法执行之后，会执行此方法。 // AOP的入口，通过AspectJAwareAdvisorAutoProxyCreator生成代理对象 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean; } } 注意\r\r由于篇幅原因，这里只做initializeBean()方法的执行流程描述。关于SpringAop执行链的封装和动态代理生成以及执行原理，事务的支持、事务的七种传播属性实现原理及其表现形式。在别的文章中分析。\r\r ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:8:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"9 临终方法注册，registerDisposableBeanIfNecessary beanFactory中有一个成员变量disposableBeans，这是一个map集合，里面就封装了bean销毁前需要调用的对象映射。键时beanName，值是DisposableBeanAdapter DisposableBeanAdapter中封装了destroyMethod以及List，没错，是一个list列表。因为可以设置多个销毁方法，且设置的方式也是有很多种，可以实现DisposableBean，或者注解方式，或者名称为close的无参数公共方法 ban的销毁前调用方法的注册，相对简单，这里贴两段代码： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) { AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null); // BeanDefinition非多例，并且需要销毁。 if (!mbd.isPrototype() \u0026\u0026 requiresDestruction(bean, mbd)) { if (mbd.isSingleton()) { // Register a DisposableBean implementation that performs all destruction // work for the given bean: DestructionAwareBeanPostProcessors, // DisposableBean interface, custom destroy method. // 注册bean的销毁前调用的方法 registerDisposableBean(beanName, new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc)); } else { // A bean with a custom scope... Scope scope = this.scopes.get(mbd.getScope()); if (scope == null) { throw new IllegalStateException(\"No Scope registered for scope name '\" + mbd.getScope() + \"'\"); } scope.registerDestructionCallback(beanName, new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc)); } } } } public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry { public void registerDisposableBean(String beanName, DisposableBean bean) { synchronized (this.disposableBeans) { this.disposableBeans.put(beanName, bean); } } } ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:9:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":null,"content":"留言板，留言给我","date":"2020-11-25","objectID":"/message-board/","tags":null,"title":"留言板","uri":"/message-board/"},{"categories":null,"content":"留言给我↓","date":"2020-11-25","objectID":"/message-board/:0:0","tags":null,"title":"留言板","uri":"/message-board/"},{"categories":["spring"],"content":"spring容器启动过程中，在创建BeanFactory、搜集BeanDefinition、实例化并调用BeanFactoryPostProcessor之后，会对BeanPostProcessor进行注册。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:0:0","tags":["spring源码"],"title":"04 BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"1 BeanPostProcessor的作用 BeanPostProcessor是对SpringIOC容器中bean实例化的一些扩展，在bean实例化的关键节点进行了一些插桩。 真正实例化bean的方法是beanFactory.getBean()方法。而在bean实例化之前、实例化之后、依赖注入、初始化方法执行之前、初始化方法执行之后等节点进行一些钩子回调。BeanPostProcessor的作用就体现于此。 BeanPostProcessor接口只提供初始化方法执行前、后的节点操作。其余操作在它的子接口中定义。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:1:0","tags":["spring源码"],"title":"04 BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"2 BeanPostProcessor的体系结构 BeanPostProcessor及其关键子接口的方法定义-UML图\"\rBeanPostProcessor及其关键子接口的方法定义-UML图\r 上图详细注释了BeanPostProcessor及其子接口每个方法的作用节点，从BeanPostProcessor接口继承体系可以看出，BeanPostProcessor贯穿整个Spring容器中Bean的实例化流程。可以说，在Spring容器中，任何一个Bean的实例化，在其关键节点，都有BeanPostProcessor的存在。甚至可以说它是SpringIOC容器组成部分中最重要的一个类。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:2:0","tags":["spring源码"],"title":"04 BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"3 BeanPostProcessor的注册流程 以下是spring中BeanPostProcessor的源码： final class PostProcessorRegistrationDelegate { public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) { // 从beanDefinitionNames中获取所有BeanPostProcessor类型的beanName。 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); // 这里之所以要+1，因为在这个方法的结尾处，单独注册了一个BeanPostProcessor：ApplicationListenerDetector // Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors. int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount)); // Separate between BeanPostProcessors that implement PriorityOrdered, // Ordered, and the rest. // 实现了PriorityOrdered接口的。 List\u003cBeanPostProcessor\u003e priorityOrderedPostProcessors = new ArrayList\u003c\u003e(); // MergedBeanDefinitionPostProcessor类型的。 List\u003cBeanPostProcessor\u003e internalPostProcessors = new ArrayList\u003c\u003e(); // 实现了Ordered接口的。 List\u003cString\u003e orderedPostProcessorNames = new ArrayList\u003c\u003e(); // 没有实现排序接口的。 List\u003cString\u003e nonOrderedPostProcessorNames = new ArrayList\u003c\u003e(); // 对以上四种情况进行分别处理。 for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { orderedPostProcessorNames.add(ppName); } else { nonOrderedPostProcessorNames.add(ppName); } } // 注册BeanPostProcessors // First, register the BeanPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // 注册实现了Ordered接口的BeanPostProcessor。 // Next, register the BeanPostProcessors that implement Ordered. List\u003cBeanPostProcessor\u003e orderedPostProcessors = new ArrayList\u003c\u003e(); for (String ppName : orderedPostProcessorNames) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors); // 注册没有实现接口的BeanPostProcessor // Now, register all regular BeanPostProcessors. List\u003cBeanPostProcessor\u003e nonOrderedPostProcessors = new ArrayList\u003c\u003e(); for (String ppName : nonOrderedPostProcessorNames) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); // Finally, re-register all internal BeanPostProcessors. sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); } } 从上面代码可以看出，BeanPostProcessor的注册流程和BeanFactoryPostProcessor的注册流程类似。获取到BeanFactory中存储的BeanPostProcessor类型的beanName，然后对实现了不同排序接口的类、及没有实现排序接口的类分别进行getBean()操作、排序和注册。 spring会在不同的流程节点执行BeanPostProcessor及其子接口对应的方法。具体的实现类在后面的spring容器bean的实例化相关文章描述。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:3:0","tags":["spring源码"],"title":"04 BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"spring ioc容器初始化时，首先创建BeanFactory对象，搜集BeanDefinition，在完成之后，会优先先实例化BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor，并调用postProcessBeanDefinitionRegistry()、postProcessBeanFactory()方法 ","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:0:0","tags":["spring源码"],"title":"03 BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"1 BeanFactoryPostProcessor BeanFactoryPostProcessor中只有一个方法postProcessBeanFactory，实现了这个接口的类，会优先于其他常规的类实例化，并调用postProcessBeanFactory方法。 @FunctionalInterface public interface BeanFactoryPostProcessor { void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; } ","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:1:0","tags":["spring源码"],"title":"03 BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"2 BeanDefinitionRegistryPostProcessor BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子接口，同样的，它会优先与其他常规的类，提前实例化、加入到IOC容器，并会调用postProcessBeanDefinitionRegistry()方法，再调用postProcessBeanFactory()方法。 public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor { void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException; } ","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:2:0","tags":["spring源码"],"title":"03 BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"3 调用逻辑 首先搜集从BeanFactory中后去所有BeanDefinitionRegistryPostProcessor类型的beanName。 筛选出实现了PriorityOrdered接口的（筛选过程中会调用getBean()方法），并对其进行排序，然后进行遍历调用postProcessBeanDefinitionRegistry()。 筛选出实现了Ordered接口的，同上，进行getBean()，并排序，然后进行遍历调用postProcessBeanDefinitionRegistry()。 对没有实现PriorityOrdered接口且没有实现Ordered接口的BeanDefinitionRegistryPostProcessor进行排序、调用postProcessBeanDefinitionRegistry()。 上面的每一步调用postProcessBeanDefinitionRegistry()之前，会将其实力缓存到一个名为registryProcessors的List集合中，在以上步骤执行完，会调用BeanDefinitionRegistryPostProcessor.postProcessBeanFactory()方法 对没有实现BeanDefinitionRegistryPostProcessor但实现了BeanFactoryPostProcessor的类进行搜集。 分别筛选出实现了PriorityOrdered接口、Ordered接口、没有实现接口的类，对其进行排序、getBean()操作，调用postProcessBeanFactory()方法。 从源码中，我们可以很清晰的看到执行流程。源码逻辑如下： final class PostProcessorRegistrationDelegate { public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List\u003cBeanFactoryPostProcessor\u003e beanFactoryPostProcessors) { // 这里存储了已经调用过的BeanFactoryPostProcessor。 // BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子接口。 // 先调用BeanDefinitionRegistryPostProcessor的方法，然后是BeanFactoryPostProcessor // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set\u003cString\u003e processedBeans = new HashSet\u003c\u003e(); if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; // 这里面装的是实现了BeanFactoryPostProcessor接口的。 List\u003cBeanFactoryPostProcessor\u003e regularPostProcessors = new ArrayList\u003c\u003e(); // 这里面装的是实现了BeanDefinitionRegistryPostProcessor接口的。 List\u003cBeanDefinitionRegistryPostProcessor\u003e registryProcessors = new ArrayList\u003c\u003e(); // 对参数中传入的beanFactoryPostProcessors优先执行BeanDefinitionRegistryPostProcessor的方法，然后添加到registryProcessors中。 for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) { if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) { BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); } else { regularPostProcessors.add(postProcessor); } } // 记录当前注册的BeanDefinitionRegistryPostProcessor // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. List\u003cBeanDefinitionRegistryPostProcessor\u003e currentRegistryProcessors = new ArrayList\u003c\u003e(); // 从beanFactory中的beanDefinitionNames中获取所有的beanName。将实现了PriorityOrdered接口部分，放到处理过的bean容器中。 // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { // 这里进行了getBean操作。类的实例化就是通过此方法进行。 currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } // 对上面搜集到的BeanDefinitionRegistryPostProcessor进行排序、执行BeanDefinitionRegistryPostProcessor的方法 sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // 搜集实现了Ordered接口的BeanDefinitionRegistryPostProcessor，执行同上的逻辑。 // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName) \u0026\u0026 beanFactory.isTypeMatch(ppName, Ordered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } }// 排序、执行postProcessBeanDefinitionRegistry()方法 sortPostProcessors(current","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:3:0","tags":["spring源码"],"title":"03 BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"记录spring标签解析中，对标签属性解析的几个典型BeanDefinitionParser实现。","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"本篇是对 Spring程序入口和XML解析 的扩展，详细解析其中提到的BeanDefinitionParser的作用，以及一些典型的XML方式解析的实现类。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:0:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"1 BeanDefinitionParser接口的定义 public interface BeanDefinitionParser { @Nullable BeanDefinition parse(Element element, ParserContext parserContext); } 可以看到，BeanDefinitionParser只有一个方法，负责BeanDefinitaion的解析。参数有节点元素、解析上下文对象。 在Spring中有很多内置的BeanDefinitionParser实现类（之所以说内置，因为它也是可以扩展的），包括XML方式解析、注解方式解析等。 注意\r\rParserContext中封装了BeanDefinitionRegistry对象，用于BeanDefinition的注册。\r\r 关于此类的实例从哪里注册、parse方法从哪里调入进来的， Spring程序入口和XML解析 中有结尾处有详细说明。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:1:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2 ComponentScanBeanDefinitionParser实现流程解析 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2.1 ComponentScanBeanDefinitionParser中的属性 ComponentScanBeanDefinitionParser是BeanDefinitionParser的一个实现，用于解析\u003ccontext:component-scan/\u003e标签的属性。 这个类中定义了一些常量，这些常量是\u003ccontext:component-scan/\u003e中所有可能用到的属性。比如最常用到的base-package属性。 前面有提到，parse方法的参数中有Element。在解析Element时，会对Element的多个属性进行识别及处理。这些常量的作用就在于此，用来区分Element的不同属性，并做特定的处理。 以下是ComponentScanBeanDefinitionParser中定义的常量： public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { private static final String BASE_PACKAGE_ATTRIBUTE = \"base-package\"; private static final String RESOURCE_PATTERN_ATTRIBUTE = \"resource-pattern\"; private static final String USE_DEFAULT_FILTERS_ATTRIBUTE = \"use-default-filters\"; private static final String ANNOTATION_CONFIG_ATTRIBUTE = \"annotation-config\"; private static final String NAME_GENERATOR_ATTRIBUTE = \"name-generator\"; private static final String SCOPE_RESOLVER_ATTRIBUTE = \"scope-resolver\"; private static final String SCOPED_PROXY_ATTRIBUTE = \"scoped-proxy\"; private static final String EXCLUDE_FILTER_ELEMENT = \"exclude-filter\"; private static final String INCLUDE_FILTER_ELEMENT = \"include-filter\"; private static final String FILTER_TYPE_ATTRIBUTE = \"type\"; private static final String FILTER_EXPRESSION_ATTRIBUTE = \"expression\"; } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:1","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2.2 主流程方法parse() 步骤： 获取到标签中base-package属性的值，这个值是必须的。（否则会抛出异常，异常信息At least one base package must be specified）。 创建扫描器：ClassPathBeanDefinitionScanner（mybatis中的扫描器就是继承了它） 调用核心方法doScan（这里解析并注册了BeanDefinition） 注册组件registerComponents（ClassPathBeanDefinitionScanner中，最终是一个空方法，可以不看，BeanDefinition的注册在doScan中做了） public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { public BeanDefinition parse(Element element, ParserContext parserContext) { // 获取base-package属性 String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage); String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // Actually scan for bean definitions and register them. ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); // TODO 重点：这里执行了具体的解析逻辑。 Set\u003cBeanDefinitionHolder\u003e beanDefinitions = scanner.doScan(basePackages); registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:2","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2.3 configureScanner() 从以下源码可以看到，首先设置是否使用默认过滤器，然后创建扫描器ComponentScanBeanDefinitionParser，之后对其他属性进行一些设置。（关注源码中关键点就好，不然会越陷越深） public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { // 解析配置的属性，use-default-filters如果未定义，默认为true boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); } // 创建扫描器，其实mybatis中的扫描原理就来自于此，mybatis中的ClassPathMapperScanner继承了ClassPathBeanDefinitionScanner // Delegate bean definition registration to scanner class. ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters); // 下面的代码是对标签中其他属性的一些设置，其实就是把标签及其属性以java类的描述形式体现。 scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) { scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); } try { parseBeanNameGenerator(element, scanner); } catch (Exception ex) { parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause()); } try { parseScope(element, scanner); } catch (Exception ex) { parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause()); } parseTypeFilters(element, scanner, parserContext); return scanner; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:3","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2.4 核心方法doScan() 扫描出所有满足条件的类，并封装成BeanDefinition 循环扫描到的BeanDefinition集合，依次执行操作。 解析@Scope注解 对不同类型的BeanDefinition做不同处理，@Lazy、@DependOn等注解信息封装就是在这里设置的。 校验是否是需要实例化的BeanDefinition，如果为true，则将BeanDefinition包装成BeanDefinitionHolder（这个类里封装了实例名称、别名信息） 源码如下： public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { protected Set\u003cBeanDefinitionHolder\u003e doScan(String... basePackages) { Assert.notEmpty(basePackages, \"At least one base package must be specified\"); // 用来装所有扫描到的类的BeanDefinition对象。 Set\u003cBeanDefinitionHolder\u003e beanDefinitions = new LinkedHashSet\u003c\u003e(); for (String basePackage : basePackages) { // TODO 重点看：查找候选组件，封装成BeanDefinition。 Set\u003cBeanDefinition\u003e candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) { // 获取到ScopeMetadata，如果类中有@Scope注解，则会将值封装到这个实例中。然后设置到BeanDefinition中。 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); // 对不同类型的BeanDefinition做不同的处理。 if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } // 对不同类型的BeanDefinition做不同的处理，@Lazy、@DependOn等注解信息封装就是在这里设置的。 if (candidate instanceof AnnotatedBeanDefinition) { // 一些注解信息的封装 AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } // 校验是否是需要实例化的BeanDefinition，如果为true，则将BeanDefinition包装成BeanDefinitionHolder（这个类里封装了实例名称、别名信息） if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 注册BeanDefinition registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:4","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2.5 findCandidateComponents原理解析 最终会执行到scanCandidateComponents()方法。从下面源码中可以看到，实际上就是根据\u003ccontext:component-scan/\u003e标签配置的base-package来扫描对应路径下的文件输入流，读取类文件信息。进而拿到Class对象，封装成BeanDefinition对象。然后向上返回，直到注册到BeanDefinitionRegistry中。 public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { private Set\u003cBeanDefinition\u003e scanCandidateComponents(String basePackage) { Set\u003cBeanDefinition\u003e candidates = new LinkedHashSet\u003c\u003e(); try { //根据路径扫描 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; // 获取指定包下匹配到的所有的资源对象。里面封装了InputStream，用来读取类文件。 Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(\"Scanning \" + resource); } if (resource.isReadable()) { try { // 封装成ScannedGenericBeanDefinition，这里封装了包下所有的类信息 MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); if (isCandidateComponent(metadataReader)) { // 创建BeanDefinition对象，将 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); // 判断是否是候选组件，如果是，就添加BeanDefinition对象 if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(\"Identified candidate component class: \" + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(\"Ignored because not a concrete top-level class: \" + resource); } } } else { if (traceEnabled) { logger.trace(\"Ignored because not matching any filter: \" + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( \"Failed to read candidate component class: \" + resource, ex); } } else { if (traceEnabled) { logger.trace(\"Ignored because not readable: \" + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); } return candidates; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:5","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"3 AspectJAutoProxyBeanDefinitionParser AspectJAutoProxyBeanDefinitionParser是对aop标签的aop:aspectj-autoproxy/的支持 源码： class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser { @Override @Nullable public BeanDefinition parse(Element element, ParserContext parserContext) { // 对aspectj-autoproxy属性的支持 AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 添加IncludePatterns extendBeanDefinition(element, parserContext); return null; } } 会走到这里： public abstract class AopConfigUtils { @Nullable public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary( BeanDefinitionRegistry registry, @Nullable Object source) { // 注入此类 AnnotationAwareAspectJAutoProxyCreator，本质还是一个BeanPostProcessor, // 实现了BeanPostProcessor的子接口：SmartInstantiationAwareBeanPostProcessor return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source); } } AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法中，注册了AnnotationAwareAspectJAutoProxyCreator的支持，这个类会在AOP知识点中详细阐述。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:3:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"4 总结 spring对XML的解析，就是通过NameSpaceHandler中注册的BeanDefinitionParser进行处理的。通过SPI的方式，很容易对标签解析功能进行扩展。 技巧\r\r其他的解析类，方法都是一样的。 首先根据标签名称找到NamespaceUri，根据SPI加载方式，到对应模块META-INF/spring.handlers文件中查找对应的NamespaceHandler实现类； 然后在实现类中的init方法中，找到标签属性对应的BeanDefinitionParser实现类； 最后，进入实现类的parse方法，读源码即可。结合断点调试，很容易读懂。 \r\r 万事开头难，spring源码也一样。刚开始确实挺难理解的，理清了脉络后，再读起来就相对简单很多。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:4:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"本章记录了Spring源码的程序入口，和XML解析的源码流程。 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:0:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"1 前言 Spring源码Gitee传送门 （本人从 github 中下载，然后以自身理解对核心流程及主要节点做了详细的中文注释。建议下载、结合 Spring 系列文章阅读源码） spring源码系列文章，示例代码的中文注释，均是copy上面链接中的源码。 用 jack大佬 的话来概括，为什么要学习Spring源码？ 提高自己的写代码能力 从全局考虑如何使代码变得灵活可扩展 Spring重新定义了Java Spring源码是有一定难度的 如果想成为真正的高手，Spring源码必须攻克，不是危言耸听的 Spring源码读懂，其他很多基于Spring的框架源码很容易理解。相反，以Spring为基础的框架、组件，不懂Spring压根没法读其源码。 学习源码的方式：主抓脉络，后看细节。（熟练使用的前提下再看源码） 特别感谢：Spring源码中的调用链路、纵深都是比较长的，我个人读了很久。许多源码难点的理解得益于 jack大佬 的讲解，感谢大佬的授业解惑。 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:1:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"2 Spring的历史 2002年10月,Rod Johnson发布《Expert One-on-One J2EE设计和开发》一书 2004年3月，Spring1.0发布 2006年10 月，Spring2.0发布 2009年12月，Spring3.0发布 2013年12月，发布Spring4.0 2017年9月，Spring5.0发布 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:2:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"3 读源码前的准备 JDK1.8版本 spring 5.1.3.RELEASE版本 补一下Lambda表达式的知识 安装配置gradle ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:3:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"4 Spring源码下载 git clone --branch v5.1.3.RELEASE https://gitee.com/wanglizhi00/spring-framework （此链接的Spring源码，核心流程、要注意的点我都做了中文注释，非常详细。如果你的网络足够好，也可以到 github 下载 原版spring源码 ） gradle下载，gradle要JDK8的版本 到下载的spring源码路径执行gradle命令，gradlew :spring-oxm:compileTestJava 用idea打开spring源码工程。（在idea中安装插件kotlin，重启idea，跟IDEA版本有关较新版本不用安装） 把编译好的源码导入到工程中 spring工程如何搭建这里不做介绍，如何将down下来的源码导入到自己的spring工程依赖库， 我的Gitee-Spring源码注释 中有详细的介绍 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:4:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"5 入口方法 容器：AbstractApplicationContext 抽象父类，核心方法 refresh()。 ClassPathXmlApplicationContext XML方式启动。 AnnotationConfigWebApplicationContext 注解方式启动，对局部代码进行测试时比较好用。 AnnotationConfigServletWebServerApplicationContext SpringBoot启动默认使用的上下文类。 我们知道，spring容器的启动是通过构造ApplicationContext的一个实例开始的。以ClassPathXmlApplicationContext为例。 ClassPathXmlApplicationContext UML图ClassPathXmlApplicationContext UML图 \"\rClassPathXmlApplicationContext UML图\r ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:5:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"6 Xml解析流程概览 首先进入spring容器启动的核心方法：refresh() ，创建BeanFactory对象 obtainFreshBeanFactory() 创建XmlBeanDefinitionReader对象 通过Reader对象加载配置文件 根据加载的配置文件把配置文件封装成document对象 创建BeanDefinitionDocumentReader对象，DocumentReader负责对document对象解析 parseDefaultElement(ele, delegate);负责常规标签解析 delegate.parseCustomElement(ele);负责自定义标签解析 最终解析的标签封装成BeanDefinition并缓存到容器中 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:6:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"7 创建XmlBeanDefinitionReader对象 public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext { @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // Create a new XmlBeanDefinitionReader for the given BeanFactory. // 创建BeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); // TODO 关键点：加载BeanDefinition loadBeanDefinitions(beanDefinitionReader); } } 在loadBeanDefinitions方法的第一行，创建了XmlBeanDefinitionReader对象。这个类的主要作用是读取BeanDefinition，并将XML文档的读取委托给BeanDefinitionDocumentReader。 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:7:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"8 创建BeanDefinitionDocumentReader对象 来到loadBeanDefinitions(beanDefinitionReader);这里将要读取的xml路径传递进来，循环xml路径，依次进行解析。 注：看注释中的关键点 public abstract class AbstractBeanDefinitionReader implements BeanDefinitionReader, EnvironmentCapable { // 首先进入这个方法 @Override public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException { Assert.notNull(locations, \"Location array must not be null\"); int count = 0; // 一次解析配置文件，加载配置文件中定义的Bean。 for (String location : locations) { count += loadBeanDefinitions(location); } return count; } } 路径最终会被封装为IinputSource对象，使用委托模式，交给BeanDefinitionDocumentReader处理 public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader { // 第一步：入口 protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 解析xml配置文件，获取到Document对象 Document doc = doLoadDocument(inputSource, resource); // 解析、注册BeanDefinition int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) { logger.debug(\"Loaded \" + count + \" bean definitions from \" + resource); } return count; //此处分别捕获了很多种异常，省略了。 } catch (Exception ex) { throw ex; } } // 第二步 创建BeanDefinitionDocumentReader，委托给BeanDefinitionDocumentReader进行解析工作。 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // 委托模式，将Document的解析及BeanDefinition的注册交给BeanDefinitionDocumentReader // 这里使用的DefaultBeanDefinitionDocumentReader进行解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // TODO 关键点：解析xml、注册BeanDefinition documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore; } } ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:8:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"9 标签解析入口 在解析标签之前、和之后，分别有一个钩子方法。这两个钩子方法分别是 解析xml并注册BeanDefinition 之前和之后的扩展方法，ClassPathXmlApplicationContext中，这两个方法体都是空的。 public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader { // 第一步 protected void doRegisterBeanDefinitions(Element root) { // Any nested \u003cbeans\u003e elements will cause recursion in this method. In // order to propagate and preserve \u003cbeans\u003e default-* attributes correctly, // keep track of the current (parent) delegate, which may be null. Create // the new (child) delegate with a reference to the parent for fallback purposes, // then ultimately reset this.delegate back to its original (parent) reference. // this behavior emulates a stack of delegates without actually necessitating one. BeanDefinitionParserDelegate parent = this.delegate; // BeanDefinitionParserDelegate中封装了预定义的很多标签属性 this.delegate = createDelegate(getReaderContext(), root, parent); // 根标签解析 NameSpace：http://www.springframework.org/schema/beans if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); // We cannot use Profiles.of(...) since profile expressions are not supported // in XML config. See SPR-12458 for details. if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isDebugEnabled()) { logger.debug(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); } return; } } } // 钩子方法，解析xml注册BeanDefinition之前调用，可以不看 preProcessXml(root); // TODO 解析xml，注册BeanDefinition parseBeanDefinitions(root, this.delegate); // 钩子方法，解析xml注册BeanDefinition之后调用，可以不看 postProcessXml(root); this.delegate = parent; } // 第二步 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { // Spring根标签，NameSpace：http://www.springframework.org/schema/beans // 这里循环document中的元素，进行解析默认标签及自定义标签 String tagName = root.getTagName(); if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i \u003c nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { logger.debug(\"delegate.isDefaultNamespace(root):true,解析默认标签 \" + tagName); // TODO 关键点：解析默认标签 parseDefaultElement(ele, delegate); } else { logger.debug(\"delegate.isDefaultNamespace(root):true,解析自定义标签 \" + tagName); // TODO 关键点：解析自定义标签 delegate.parseCustomElement(ele); } } } } else { logger.debug(\"delegate.isDefaultNamespace(root):false,解析自定义标签 \" + tagName); // TODO 关键点：解析自定义标签 delegate.parseCustomElement(root); } } } ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:9:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"10 解析默认标签 根据xml节点的名称，对比代码中定义的标签名称。跳转到对应的解析方法 以bean标签为例，最终走到BeanDefinitionParserDelegate.parseBeanDefinitionElement()方法 public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader { // 第一步 进入标签解析方法 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { // import标签解析 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } // alias标签解析 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } // TODO 重点看：bean标签解析 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); } // beans标签解析 else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // recurse doRegisterBeanDefinitions(ele); } } // 第二步 进入bean标签解析方法 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // TODO 重点：获取到BeanDefinitionHolder，内部封装了BeanDefinition BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // 如果必要，装饰BeanDefinition，这里用到了装饰模式 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } } 解析和封装BeanDefinition，这里解析了bean标签中的所有属性，将这些属性值封装成BeanDefinition对象。最终会被注册到BeanDefinitionRegistry中。 BeanDefinitionRegistry作为spring容器中BeanFactory的全局成员变量。也就是说，最终得到的BeanDefinition贯穿整个spring容器的生命周期，它是对spring容器中所有将要实例化的bean信息的描述。 public class BeanDefinitionParserDelegate { @Nullable public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); // bean标签中的class属性 String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } // bean标签中的parent属性 String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { // TODO 重点：创建BeanDefinition，设置parent、beanClass、beanClassName属性。 // bean标签的bean均定义为：GenericBeanDefinition AbstractBeanDefinition bd = createBeanDefinition(className, parent); // TODO 重点：解析element并设置BeanDefinition中的属性值 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 解析meta标签、lookupOverride子标签、replaceMethod子标签 parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析构造函数参数、property参数、qualifier参数 parseConstructorArgElements(ele, bd); parsePropertyElements(ele, bd); parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(\"Bean class [\" + className + \"] not found\", ele, ex); } catch (NoClassDefFoundError err) { error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err); } catch (Throwable ex) { error(\"Unexpected failure during bean definition parsing\", ele, ex); } finally { this.parseState.pop(); } return null; } } ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:10:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"11 解析自定义标签 SPI方式获取加载所有的namespaceUri（SPI这里不进行讨论），通过当前标签定义的namespaceUri，获取到初始化后（init()）的处理类。然后调用处理类的parse方法，在此方法中，完成了标签属性的解析和BeanDefinition注册 在resolve方法中，调用了NamespaceHandler的init方法，init方法中注册了标签属性的处理类。 这些处理类都是BeanDefinitionParser的实现，在BeanDefinitionParser中，仅有一个parse方法，用来解析特定的标签属性。 public class BeanDefinitionParserDelegate { @Nullable public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) { // SPI方式获取namespaceUri String namespaceUri = getNamespaceURI(ele); if (namespaceUri == null) { return null; } // 获取NamespaceHandler，这里面调用了NamespaceHandler的init方法 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) { error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele); return null; } return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); } } NamespaceHandler，是根据对应模块中的META-INF/spring.handlers中定义的映射关系进行获取的（SPI方式获取）。映射关系NamespaceUri=NamespaceHandler 以下是spring-context中定义的处理映射（spring-context/META-INF/spring.handlers） http\\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler http\\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler http\\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler http\\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler http\\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler resolve方法获取了处理类对象，每个处理类实例化之后都会放入缓存handlerMappings，下次获取直接从缓存中获取。handlerMappings的键时NamespaceUri，值初始是对应处理类的ClassName，实例化之后会替换为该类的实例对象。 public class DefaultNamespaceHandlerResolver implements NamespaceHandlerResolver { @Override @Nullable public NamespaceHandler resolve(String namespaceUri) { // 从缓存中获取，如果存在，直接返回，如果不存在则创建 Map\u003cString, Object\u003e handlerMappings = getHandlerMappings(); Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) { return null; } else if (handlerOrClassName instanceof NamespaceHandler) { return (NamespaceHandler) handlerOrClassName; } else { String className = (String) handlerOrClassName; try { // 加载Class Class\u003c?\u003e handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException(\"Class [\" + className + \"] for namespace [\" + namespaceUri + \"] does not implement the [\" + NamespaceHandler.class.getName() + \"] interface\"); } // TODO 重点：实例化NamespaceHandler，调用init方法，放入缓存。这里是一个扩展点，所有的自定义标签都要提供对应的NamespaceHandler // spring.handler文件中定义了很多内置的NamespaceHandler，通过SPI的方式加载、实例化 NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); namespaceHandler.init(); handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; } catch (ClassNotFoundException ex) { throw new FatalBeanException(\"Could not find NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"]\", ex); } catch (LinkageError err) { throw new FatalBeanException(\"Unresolvable class definition for NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"]\", err); } } } } 每个自定义标签都有自己的NamespaceHandler实现。 NamespaceHandler实现类\"\rNamespaceHandler实现类\r 以context标签为例，注册不同标签属性对应的处理类。 public class ContextNamespaceHandler extends NamespaceHandlerSupport { @Override public void init() { // 注册各种标签属性的解析类 registerBeanDefinitionParser(\"property-placeholder\", new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(\"property-override\", new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(\"annotation-config\", new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(\"load-time-weaver\", new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionPa","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:11:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"12 总结 Spring解析XML，绕了这么大一圈。其目的就是把XML中配置的各种标签按照标签本身定义的解析方式进行处理，将处理的结果封装成BeanDefinition对象，并注入到BeanFactory的成员变量BeanDefinitionRegistry中。 这是Spring容器以XML方式初始化的第一步。其实无论是XML解析方式，还是注解方式，基本思想都是一样的。Spring容器在创建任何实例前，都会先搜集这个将要创建实例的一些必要信息，然后对这些信息根据一些扩展接口中提供的方法（模板设计模式），进行处理。 这些处理有一些是Spring内置的，可能也有使用者自定义的。具体的处理方式，在后面的章节体现。 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:12:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["文档"],"content":"本章记录一些博客的链接，经常百度的一些内容，以链接的方式记录在这里，使用站内搜索引擎方便查找。 ","date":"2020-11-21","objectID":"/posts/docs/other-blog-link/:0:0","tags":["链接"],"title":"其他 - 转载","uri":"/posts/docs/other-blog-link/"},{"categories":["文档"],"content":"linux相关 shell脚本基础：Runoob.com linux常用命令大全 linux 查看日志的几种基本操作 Centos7：ssh免密登录设置 Centos7 minimal安装后的一些配置(解决ifconfig、vim等not found问题) 深入理解VMware虚拟机网络通信原理 ","date":"2020-11-21","objectID":"/posts/docs/other-blog-link/:0:1","tags":["链接"],"title":"其他 - 转载","uri":"/posts/docs/other-blog-link/"},{"categories":["文档"],"content":"框架 Spring事务传播行为详解 Springboot 单元测试详解 ","date":"2020-11-21","objectID":"/posts/docs/other-blog-link/:0:2","tags":["链接"],"title":"其他 - 转载","uri":"/posts/docs/other-blog-link/"},{"categories":["文档"],"content":"工具 Git命令大全 解决GitHub每次push时都提示输入用户名和密码的问题 VMWare使用文档 VMware安装Centos7超详细过程（图文） vi/vim 命令使用详解 ","date":"2020-11-21","objectID":"/posts/docs/other-blog-link/:0:3","tags":["链接"],"title":"其他 - 转载","uri":"/posts/docs/other-blog-link/"},{"categories":["生活"],"content":"回忆 六年前的一个LOL视频，当初也是实锤的电竞粉额。2015年夏天也是拿这个英雄打了一个月排位，网一区一路从白银打到钻二，排行榜3000多名（据说这区当时活跃用户大概50万），之后便不怎么玩儿了。 \r","date":"2020-11-21","objectID":"/posts/life/memory-lol/:0:1","tags":["LOL"],"title":"Memory LOL","uri":"/posts/life/memory-lol/"},{"categories":["生活"],"content":"emm…那年夏天 ","date":"2020-11-21","objectID":"/posts/life/memory-lol/:0:2","tags":["LOL"],"title":"Memory LOL","uri":"/posts/life/memory-lol/"},{"categories":["折腾"],"content":"关于站内搜索，试用两天lunr后，还是决定换成algolia，algolia本身性能更高、也更加节省流量。","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"原由 博客搭建好之后，还算满意。试用过程中，偶然发现页面跳转时每次都会请求几个lunr相关支持的js文件，搜索时，又会下载index.js文件。 对lunr支持的文件，还是比较大的；index.js就是文档索引内容了，这个文件和网站内容数量成正比。目前文章只有十多篇，index.js文件就有70kb。 随着文章的发布，index.js会不断增大，且每次点击搜索框进行搜索，都会下载此文件。内容不多的情况下，速度相较于algolia更快。（网络原因，即使选择官方最近的数据中心，还是略卡） 一番思索后，决定将lunr换成algolia（虽然因网络原因，目前lunr更快），原因：并非每次加载页面都需要搜索支持，而使用lunr总是会下载搜索相关支持文件，algolia就没有这个问题。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:1","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"lunr和algolia的区别 lunr每次搜索前、都会请求对lunr支持的js文件、及将要分析的索引文档（index.json）。也就是说，搜索功能本身及将要搜索的全部网站数据索引，都是一次性发送到客户端，在客户端浏览器上运行的。这种方式太过简单粗暴。 algolia则是将索引分析任务交给第三方服务器（algolia官方的），需要分析的索引文档，提前上传到algolia服务器，搜索时，客户端仅发送搜索的关键字、身份校验的一些信息。algolia分析本地索引文件，处理完成后将结果返回给客户端。 相对lunr，algolia少了向客户端发送搜索引擎功能文件（因为搜索在服务器做了，搜索功能本身可以做的更强大）、及索引文件。仅仅是搜索关键字、和处理结果的传输，就省了很大一笔网络开销，这也是它的高效之处。 algolia比lunr多了一次网络请求。一般公司里项目做搜索，搜索引擎服务器和业务服务器是通过内网链接，网络延迟很低很低。使用algolia的唯一痛点就在这了，即使选择algolia在国内的数据中心（香港），也还是有点延迟的。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:2","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"使用algolia algolia使用还是很简单的，Algolia官网 注册账号 -\u003e 创建应用 -\u003e 创建indices -\u003e 上传索引文件。 hugo项目中，配置一些必要信息（前提主题支持algolia搜索）。分别是Algolia中创建的index名称、appId、searchKey。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:3","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"自动更新index 每次发布新内容，如果手动上传索引文件到algolia，是相当麻烦的。 Algolia Atomic 是一个不错的选择。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:4","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"前言 搭建过程有些波折，好在总算完成了。目前博客采用hugo的主题。不得不说，hugo使用起来相较于jekyll简单了许多，除了主题生态没有jekyll的丰富，别的没毛病。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:1","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"起因 上周听Jack大佬的课，翻了某位同学博客 （叶良辰学习笔记），陡然眼前一亮，原来笔记还可以这么玩儿。 其实几年前我就有意搭建个人博客，一直没落实的原因：确实有些忙，偶尔闲下来时又去学习新的知识，自己写博客系统的话，太耗时间、精力（作为一个java程序员，前端能力有限，你懂得。），会的一堆后端技术，这里毫无用武之地。时至今日这个计划已经迟滞了三年多。 很多云笔记也有分享功能，甚至一键发布博客功能。比如有道云笔记、印象笔记、蚂蚁笔记等，都有用过。看了这位同学的笔记（博客）后，回想自己用云笔记的方式，决定还是研究一下博客系统。一个存储私密文档，一个发布公开文档。 Jack大佬博客传送门 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:2","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"百度 - 货比三家 直接写静态页面得不偿失。页面+后端方式实现博客、管理等功能，太重，且前端能力有限。无论如何，最终内容还是要静态页面，除非你不想被搜索引擎扒到。 首先百度搜索静态页面生成器，很多流行的，不晓得先入手研究哪个，对比了许多帖子，决定先看看jekyll。然后在 jekyll主题网站 选择了几个主题。 一般主题网站中的主题都有demo，先看demo效果。 到github仓库，fork到自己的仓库。 根据README.md文档的介绍，将代码拉取到本地，用IDE打开。（我使用的IDEA，毕竟做后端的…） 根据使用文档（很多主题其实只有一个文件介绍，不是特别详细，需要自己摸索）修改配置。 尝试了几个主题后，大多功能都正常，个别地方有问题，本地很难调试。（依赖ruby、nodejs等环境，作为java程序员，对这玩意儿认知低的可怜） 尝试了几个主题后，感觉还凑合，将修改好的主题推送到github后，通过gitPages托管。能访问，龟速。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:3","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"选择 - Hugo 之后翻看网上的博客时，看到有人说使用的hugo，于是点进去搜了一通。选择了几个主题，挨个试。这里说下我使用的感受： jekyll优点：主题更丰富，选择性更多。 jekyll缺点：使用实在太复杂，构建速度着实慢了些。 hugo优点：使用真的简单，比jekyll简单太多了。构建速度真的快，比jekyll快很多很多倍。（目前没太多内容，构建后大概100多个静态 文件，构建需要500ms左右） hugo缺点：主题没jekyll选择性那么多，也还可以。官网上有些主题相对简陋。（注：不是简约，是简陋） 使用jekyll时，看到一个比较喜欢的主题ThemePersephone，只是搞了半天，gitpages托管的代码是可以访问了，本地环境却始终弄不好（ruby的问题，下载了最新版本不行。准备换个版本的安装包，死活下载不了，官网被墙的厉害），只好放弃。之后在HugoThemes下载主题，试用。只需要下载一个二进制文件，不需要其他任何依赖。没有对比就没有伤害，最终选择Hugo ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:4","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"搭建 两款主题 hugo-theme-hello-friend-ng 和 loveit ，最终选择loveit这款主题，原因是，文档超级详细，功能足够丰富。支持搜索引擎（两款）、评论系统、shortcode、emoji等。该有的功能基本都支持，唯一不满的是md text块的背景色、字体颜色有点丑。有空再研究给换个色。 搜索引擎支持两种： lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 暂时选择lunr，原因简单，现在的访问量来看，缺点可以忽略（好吧…两天后-决定将搜索更换为Alogial）。 评论系统略有点麻烦，支持6种评论系统（disqus、gitalk、valine、facebook、telegram comments、commento、utterances），挨个打开，打开valine官网速度较快，最终选择这个，不为别的，官网打开速度的印象分。 评论本身配置相对简单，根据提示来就行。邮件提醒功能略麻烦点，valine从v1.4.0版本后，不再支持邮件提醒功能。只能使用的第三方邮件提醒。关于这个，github上很多开源项目。我选择的 Valine-Admin ，部署到LeanCloud创建的应用中。部署后需要配置一些环境变量，主要是邮件发送的服务器、账号、授权码、自己网站url等。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:5","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"迁移 - 阿里云 图片资源使用阿里云对象存储OSS，静态页面迁移到阿里云服务器。 GitPages托管方式，访问速度有点慢，还算能接受吧。服务器有、域名有（旧的域名不太喜欢，新域名备案完成还得几天），最终决定迁移到阿里云。部署：服务器安装docker -\u003e docker安装nginx -\u003e 安装git -\u003e 将hugo生成的html文件拉取到nginx路由的目录下，部署完成。 迁移到阿里云后的感受：不卡了，emm…丝滑。嗯，也收费了。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:6","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"自动部署 使用Github的WebHooks，服务器写一个脚本即可。 流程大概是这个样子：当push代码到github时，触发回调接口。在服务器上部署一个web项目（我使用的springboot），暴露一个接口供webhooks调用。接口内容是异步方式（一个单线程的线程池）执行shell脚本，完成自动部署。 更轻量的方式，手写代码，使用socket接收请求，执行脚本更加高效。http接口方式写起来比较快，十多分钟完事。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:7","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"域名备案 wlz922.top是我一直使用的域名，域名备案相对麻烦，思虑再三还是决定再注册一个。 新域名wlizhi.cc审核估计还得几天。 备案流程有点麻烦，周期是比较长的（到域名服务商注册 -\u003e 阿里云初审 -\u003e 通管局审核）。 首先注册域名，注册后是不能直接备案的，要等1-3天。然后申请备案，填一些必须的资料。阿里云关于备案相关资料太多，没看，直接按照流程提示填写资料。之后初审驳回一次（验证资料不规范），按要求重新上传资料，初审通过，等待管局审核。 有一点需要说明，域名备案时，解析的网站首页必须和资料填写的内容一致，页脚必须有备案号链接到 工信部域名备案管理 网站（我上个域名备案时让填的不是这个网址，搞不懂）。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:8","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"最后 看jekyll、hugo文档、选主题、读主题及主题支持各种插件文档、迁移至阿里云。历时四天，博客主题基本选定（主题选了两天多，换了五六个。强迫症，总想找个更好的）、搭建完成。没事还是要研究一下hugo，折腾已成本能。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:9","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["系统"],"content":"linux 基础概念、文件系统组成、常用命令、应用安装 - 卸载","date":"2020-11-18","objectID":"/posts/linux/linux-basics/","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"1. 基础介绍 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:1:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"发行的linux版本 Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS linux各个版本\"\rlinux各个版本\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:1:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"系统目录结构 linux目录结构\"\rlinux目录结构\r 系统启动必须： 信息\r\r /boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。 /etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。 /lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中 \r\r 指令集合： 信息\r\r /bin：存放着最常用的程序和指令 /sbin：只有系统管理员能使用的程序和指令。 \r\r 外部文件管理： 信息\r\r /dev ：Device(设备)的缩写, 存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。 /media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。 /mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 \r\r 临时文件 信息\r\r /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。 /tmp：这个目录是用来存放一些临时文件的。 \r\r 账户： 信息\r\r /root：系统管理员的用户主目录。 /home：用户的主目录，以用户的账号命名的。 /usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序与指令。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 \r\r 运行过程中要用： 信息\r\r /var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。 /proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。 \r\r 扩展用的： 信息\r\r /opt：默认是空的，我们安装额外软件可以放在这个里面。 /srv：存放服务启动后需要提取的数据（不用服务器就是空） \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:1:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"linux基础命令 shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。 信息\r\r# shutdown -P now ### 关闭机器 # shutdown -H now ### 停止机器 # shutdown -r 09:35 ### 在 09:35am 重启机器\r\r 要取消即将进行的关机，只要输入命令： # shutdown -c halt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。 信息\r\r# halt ### 停止机器 # halt -p ### 关闭机器 # halt –reboot ### 重启机器\r\r poweroff 会发送一个 ACPI 信号来通知系统关机。 信息\r\r# poweroff ### 关闭机器 # poweroff –halt ### 停止机器 # poweroff –reboot ### 重启机器\r\r reboot 命令 reboot 通知系统重启。 信息\r\r# reboot ### 重启机器 # reboot –halt ### 停止机器 # reboot -p ### 关闭机器\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:1:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"2. linux用户/用户组 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"增加一个用户组 信息\r\rgroupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 例1： # groupadd group1 ##此命令向系统中增加了一个新组group1 例2： # groupadd -g 1003 group2 ##此命令向系统中增加了一个新组group2，同时指定新组的组标识号是1003 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"删除一个用户组 信息\r\rgroupdel 用户组 例：# groupdel group1 ##此命令从系统中删除组group1。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"修改用户组的属性 信息\r\rgroupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n 新用户组 将用户组的名字改为新名字 例1： # groupmod –g 10000 -n group3 group2 ##此命令将组group2的标识号改为10000，组名修改为group3。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"添加用户账号 信息\r\r参数说明： 选项: -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名: 指定新账号的登录名。 useradd 选项 用户名 例1： # useradd –d /usr/peter -m peter ##创建用户peter，其中-d和-m选项用来为登录名peter产生一个主目录/usr/peter。 例2： # useradd -s /bin/sh -g group1 –G group2,root peter2 ##新建用户peter2，登录Shell是 /bin/sh，属于group1，又属于group2和root。 这里可能新建组：#groupadd group1及groupadd group2 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:4","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"删除账号 信息\r\r userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 例如： # userdel -r peter2 ##删除用户peter2（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:5","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"修改账号 信息\r\rusermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： # usermod -s /bin/sh -d /home/p –g group2 peter ##将用户peter的登录Shell修改为sh，主目录改为/home/p，用户组改为group2。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:6","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"用户口令的管理 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 信息\r\rpasswd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。\r\r 如果默认用户名，则修改当前用户的口令。例如，假设当前用户是peter，则下面的命令修改该用户自己的口令： 信息\r\r$ passwd Old password:****** New password:******* Re-enter new password:*******\r\r 如果是超级用户，可以用下列形式指定任何用户的口令： 信息\r\r# passwd peter New password:******* Re-enter new password:*******\r\r 为用户指定空口令时，执行下列形式的命令：# passwd -d peter passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：# passwd -l peter ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:7","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"切换用户组 信息\r\r$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:8","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"与用户账号有关的系统文件 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等 /etc/passwd文件 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 信息\r\r例子： ＃ cat /etc/passwd root:x:0:0:Superuser:/: daemon:x:1:1:System daemons:/etc: bin:x:2:2:Owner of system commands:/bin: sys:x:3:3:Owner of system files:/usr/sys: adm:x:4:4:System accounting:/usr/adm: uucp:x:5:5:UUCP administrator:/usr/lib/uucp: auth:x:7:21:Authentication administrator:/tcb/files/auth: cron:x:9:16:Cron daemon:/usr/spool/cron: listen:x:37:4:Network daemon:/usr/net/nls: lp:x:71:18:Printer administrator:/usr/spool/lp: \r\r 每一行记录对应着一个用户（其中bin/sys/adm/uucp/lp/nobody是伪用户），每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell /etc/group文件 用户组的所有信息都存放在/etc/group文件中。 信息\r\rroot::0:root bin::2:root,bin sys::3:root,uucp adm::4:root,adm daemon::5:root,daemon lp::7:root,lp users::20:root,sam\r\r 此文件的格式类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:9","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"3. 文件与目录 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"文件基本属性 1. 文件的属性概貌 Lighthouse (image)\"\rLighthouse (image)\r 信息\r\r第一个字符：代表这个文件的类型，是目录、文件，还是一个链接等等 [ d ] 目录 [ - ] 文件 [ l ] 链接文档(link file) [ b ] 可供储存的接口设备(可随机存取装置) [ c ] 串行端口设备，例如键盘、鼠标(一次性读取装置) 接下来的字符：以三个一组分成三组，用 r、w、x 三个参数的组合表示，位置不会改变 [ r ] 代表可读(read) [ w ] 代表可写(write) [ x ] 代表可执行(execute) [ - ] 没有权限\r\r 2. 文件的属主与属组 每一个文件，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 chgrp：更改文件属组 信息\r\rchgrp [-R] 属组名 文件名 参数选项 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。\r\r chown：更改文件属主，也可以同时更改文件属组 语法： chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 进入 /root 目录（~）将install.log的拥有者改为bin这个账号： 例： chown root:root aa ##更改aa的属主与属组 chmod：更改文件9个属性 文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！ 变更权限的指令chmod的语法是这样的： 信息\r\r chmod [-R] xyz 文件或目录 选项与参数： xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下： chmod +x aa ##更改aa的属性,加x权限 chmod 777 aa ##更改aa的属性，三组权限都设置成7 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"文件与目录管理命令 使用 man [命令] 来查看各个命令的使用文档，如 ：man cp 信息\r\rls: 列出目录 —ll cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 —–scp网络复制 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"硬链接与软链接 硬连接 信息\r\r硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\r\r 软连接 信息\r\r另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 例： $touch a #创建一个测试文件a $ ln a b #创建a的一个硬连接文件b –echo 123 \u003e a ##a,b的内容同时变为123 $ ln -s a c #创建a的一个符号连接文件c $ ls -li # -i参数显示文件的inode节点信息 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"4. 安装程序rpm/yum ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"1. rpm方式 需要去下载相应的rpm格式的安装包xxxx.rpm 信息\r\rrpm [参数] rpm包 -i 安装 -U 更新（很少用） -e 卸载 -v 显示安装信息 -h 显示安装进度 例： rpm -ivh jdk-8u172-linux-x64.rpm 安装jdk8并显示安装进度和安装信息 rpm -qa|grep jdk查看jdk的安装包 rpm -e jdk1.8-1.8.0_221-fcs.x86_64 卸载jdk8 ，只适用于rpm包安装的软件\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"2. yum方式 yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。 基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 2.1 yum语法 信息\r\ryum [options] [command] [package …] options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为\"yes\"），-q（不显示安装的过程）等等。 command：要进行的操作。 package操作的对象。 例： yum search jdk 搜索jdk安装包 yum install -y java-1.8.0-openjdk.x86_64 安装openjdk，-y表示安装过程中的询问自动选y yum list installed ｜grep jdk 列出安装的jdk软件包 yum remove java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-headless.x86_64 卸载jdk\r\r 2.2 yum常用命令 示例\r\r1.列出所有可更新的软件清单命令：yum check-update 2.更新所有软件命令：yum update 3.仅安装指定的软件命令：yum install \u003cpackage_name\u003e 4.仅更新指定的软件命令：yum update \u003cpackage_name\u003e 5.列出所有可安裝的软件清单命令：yum list 6.删除软件包命令：yum remove \u003cpackage_name\u003e 7.查找软件包 命令：yum search 8.清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers\r\r 2.3 yum源 官方的yum源在国内访问效果不佳。需要改为国内比较好的阿里云或者网易的yum源 在/etc/yum..repos.d/下进行如下操作(请做好相应备份)： 示例\r\rwget http://mirrors.163.com/.help/CentOS7-Base-163.repo mv CentOS7-Base-163.repo CentOS-Base.repo 重建缓存： yum clean all yum makecache\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"3. 配置环境变量 在Linux系统下，安装应用程序后，在安装目录之外，可能仍然会出现 “command not found ”。 要解决所有地方都能使用应用程序，就涉及到环境变量path的设置问题 3.1 配置环境变量 系统环境变量文件在/etc下的profile文件，我们可以用vi profile命令来编辑该文件，将变量添加进去 一般需要将安装文件的bin目录加入path中，可在profile中加入下面一行代码，如： 示例\r\rvim /etc/profile # 末尾追加以下内容 export JAVA_HOME=/usr/java/default export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\r\r 3.2 环境变量生效 source /etc/profile ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"5. shell脚本 shell语言是一门linux系统下的工具语言，主要用于写一些linux系统下的操作命令，实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。或者直接理解为shell命令是可以执行多个linux命令的脚本。Shell 种类众多，有以下种类（一般使用的 Bash，就是 Bourne Again Shell，它是大多数Linux 系统默认的 Shell）： 示例\r\rBourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh）\r\r shell并不复杂，有编程基础的话，简单入门两三个小时就可以入门，主要是把一些重复操作的linux命令写成shell脚本来执行一下。以下列出shell常规的一些要素： ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:5:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"1. 解释器与执行shell 示例\r\r解释器 #!/bin/sh Bourne shell版本 #!/bin/bash Bourne Again Shell 版本 执行shell chomd +x ./test.sh #使脚本具有执行权限 ./test.sh #执行脚本 “./”表示当前目录下\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:5:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"2. 演示 #!/bin/bash ##声明bash脚本 ##demo ##注释 echo $PATH ##打印PATH环境变量 name=\"Peter\" ##定义变量name echo $name ##打印name值 echo \"I am ${name}'s friend\" ##字符串拼接 echo \"\" name2=\"I am ${name}'s good friend\" ##字符串拼接 echo $name2 echo \"\" names=(\"Peter\" \"james\" \"deer\") ##定义数组 echo ${names[@]} ##遍历数组 echo \"I am ${names[1]}'s friend\" ##第二个元素 echo \"I have ${#names[@]}friends\" ##数组长度 echo \"\" for var in ${names[@]}; ##循环数组 do if test $var = 'Peter' ##字符串相等 then echo \"I am Peter\" else echo \"I am ${var}'s friend\" fi done echo \"\" if [ $(ps -ef | grep -c \"ssh\") -gt 1 ]; ##查找是否有ssh服务 then echo \"ssh service open\"; fi echo \"\" echo \"sh arg: $0$1\" ##sh的传参 重定向： 1、test ‘aa’ -eq “bb” \u003e out ##命令输出到 out文件，报错信息并不会进入out 2、test ‘aa’ -eq “bb” \u003e out 2\u003e\u00261 ##将stderr合并到stdout，则报错信息进入了out ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:5:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6. 常用命令 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.1 最常用的是cd 命令 示例\r\rcd 进入用户主目录； cd ~ 进入用户主目录； cd - 返回进入此目录之前所在的目录； cd .. 返回上级目录（若当前目录为“/“，则执行完后还在“/\"；\"..“为上级目录的意思）； cd ../.. 返回上两级目录；\r\r ls，ll， wget， curl， history ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.2 新建文件夹和文件：mkdir touch 示例\r\rmkdir 创建文件夹 mkdir dirname 直接跟文件夹名，可在当前目录下创建文件夹 mkdir /opt/lamp/dirname 可跟路径 mkdir -p /opt/lam/dirname 假如lam不存在，需要用-p才可以创建该文件夹 touch 新建文件 touch dilename 可直接跟文件名在当前目录下创建新的文件 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.3 cat/less/more/tail等文件查看命令 详细\r\r-n或-number：有1开始对所有输出的行数编号； -b或–number-nonblank：和-n相似，只不过对于空白行不编号； -s或–squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行； -A：显示不可打印字符，行尾显示“$”； -e：等价于\"-vE\"选项； -t：等价于\"-vT\"选项； -e：文件内容显示完毕后，自动退出； -f：强制显示文件； -g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度； -l：搜索时忽略大小写的差异； -N：每一行行首显示行号； -s：将连续多个空行压缩成一行显示； -S：在单行显示较长的内容，而不换行显示； -x\u003c数字\u003e：将TAB字符显示为指定个数的空格字符。 -\u003c数字\u003e：指定每屏显示的行数； -d：显示“[press space to continue,‘q’ to quit.]”和“[Press ‘h’ for instructions]”； -c：不进行滚屏操作。每次刷新这个屏幕； -s：将多个空行压缩成一行显示； -u：禁止下划线； +\u003c数字\u003e：从指定数字的行开始显示。 按Space键：显示文本的下一屏内容。 按Enier键：只显示文本的下一行内容。 按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。 按H键：显示帮助屏，该屏上有相关的帮助信息。 按B键：显示上一屏内容。 按Q键：退出rnore命令。 –retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用； -c或——bytes=：输出文件尾部的N（N为整数）个字节内容； -f或；–follow：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效； -F：与选项“-follow=name”和“–retry\"连用时功能相同； -n或——line=：输出文件的尾部N（N位数字）行内容。 –pid=\u003c进程号\u003e：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令； -q或——quiet或——silent：当有多个文件参数时，不输出各个文件名； -s\u003c秒数\u003e或——sleep-interal=\u003c秒数\u003e：与“-f”选项连用，指定监视文件变化时间隔的秒数； -v或——verbose：当有多个文件参数时，总是输出各个文件名； 一般tail命令最常用的-n和-f，例： tail filename 读取filename最后10行内容 tail -f filename 实时动态读取filename最后10行内容 tail -20f filename 实时动态读取filename最后20行内容 \r\r cat和less及more指令相似，cat是一次性读取所有内容，文件内容较多时速度较慢。less与more的区别在于：less可以前后翻页查看，more只能向前翻页查看。 tail则用于实时获取log信息，从后向前读取内容 上述四种命令均可跟grep搭配使用cat/less/tail |grep mysql ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.4 查看文件大小的命令 du/df 详细\r\rdu -sh * 显示当前目录下所有文件的大小 du -sh filename 显示该文件大小 du -sh 显示当前目录所占空间大小 -s或 仅显示总计，只列出最后加总的值。 -h或 以K，M，G为单位，提高信息的可读性。 df 显示磁盘占用信息 直接df默认一k为单位 df -lh 显示本地系统的占用信息，以K，M，G为单位\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:4","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.5 大重点–文本编辑器 vi 详细\r\rvi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。 Linux中的vi编辑器叫vim，它是vi的增强版（vi Improved），与vi编辑器完全兼容，而且实现了很多增强功能。 vi编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用vi编辑器就必须熟练掌握着两种模式的切换。 默认情况下，打开vi编辑器后自动进入命令模式。从编辑模式切换到命令模式使用“esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。 vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下： Ctrl+u：向文件首翻半屏； 2 Ctrl+d：向文件尾翻半屏； 3 Ctrl+f：向文件尾翻一屏； 4 Ctrl+b：向文件首翻一屏； 5 Esc：从编辑模式切换到命令模式； 6 ZZ：命令模式下保存当前文件所做的修改后退出vi； 7 :行号：光标跳转到指定行的行首； 8 :$：光标跳转到最后一行的行首； 9 x或X：删除一个字符，x删除光标后的，而X删除光标前的； 10 D：删除从当前光标到光标所在行尾的全部字符； 11 dd：删除光标行正行内容； 12 ndd：删除当前行及其后n-1行； 13 nyy：将当前行及其下n行的内容保存到寄存器?中，其中？为一个字母，n为一个数字； 14 p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方； 15 P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方； 16 /字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示； 17 ？name：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示； 18 a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作； 19 a：在当前字符后添加文本； 20 A：在行末添加文本； 21 i：在当前字符前插入文本； 22 I：在行首插入文本； 23 o：在当前行后面插入一空行； 24 O：在当前行前面插入一空行； 25 :wq：在命令模式下，执行存盘退出操作； 26 :w：在命令模式下，执行存盘操作； 27 :w！：在命令模式下，执行强制存盘操作； 28 :q：在命令模式下，执行退出vi操作； 29 :q！：在命令模式下，执行强制退出vi操作； 30 :e文件名：在命令模式下，打开并编辑指定名称的文件； 31 :n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件； 32 :f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例； 33 :set nu：在命令模式下，用于在最左端显示行号； 34 :set nonu：在命令模式下，用于在最左端不显示行号； 35 :1,3y 复制第一行到第三行 36 :1,3d 删除第一行到第三行 37 :1,3s/str/str_new/g 替换第一行到第三行中的字符串 38 :1,3s/str/str_new 替换第一行到第三行中的字符串第一个字符 39 :1,3 g/str /d 删除第一行到第三行中含有这个字符串的行\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:5","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.6 重定向 \u003e 输出重定向 who \u003e bbb.txt 将aaa的内容写入bbb中，覆盖写入 cat bbb.txt » ccc.txt 讲aaa的内容追加写入bbb中，不覆盖原来内容 \u003e bbb.txt 将bbb清空 输入重定向 grep 05:37:43.730 \u003c web.2019-07-22.0.log 大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。 一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。 同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 重定向深入理解 详细\r\r一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：  标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。  标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。  标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command \u003e file 将 stdout 重定向到 file，command \u003c file 将stdin 重定向到 file。\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:6","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.7 查看服务 详细\r\rnetstat -nlpt|grep 80 查看该端口号是否被占用 free -m //查看LINUX内存剩余容量 ps可以查看具体的进程信息，一般与管道符连接其他命令使用，如：grep ps常用参数-ef/-aux，一般最常用还是-ef，例：ps -ef|grep mysql 查询mysql进程 top也可查看进程信息，而且是动态显示 whoami 查看当前登陆用户 who 查看多少用户在使用系统 date查看系统时间，可跟时间格式使用 cal查看日历，可跟年份，查看指定的年份 chkconfig –list #查看系统服务启动 chkconfig iptables on #开机启动该服务 chkconfig iptables off #开机不启动该服务 service iptables start #启动该服务 service iptables restart #重启启该服务 ps -ef|grep mysql|grep -v grep|awk ‘{print $2}‘ps -ef|grep mysql 是查询mysql服务的进程 |后的grep -v grep 是匹配不包含grep的行 awk是取查询结果的第几列，awk ‘{print $2}‘则是取第二列的值 grep 无参数则显示匹配的行 -c 显示匹配的行数 -v 显示不匹配的行\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:7","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.8 杀掉进程 kill命令 详细\r\rkill最常用的参数是-9，用法：kill -9 进程号 即可强制杀掉该进程 统计命令 wc 常用的参数是 -l 用法：wc -l ，例： ps -ef|grep mysql|wc -l 统计查询出的mysql进程的行数 查找命令 find/locate/whereis/which find -name 后跟文件名，可查看文件所在目录，可跟user，查看属于user的文件 find -name filename 查找filename所在目录 find -name name* 查找开头为name的文件所在目录 find -name *name 查找结尾为name的文件所在目录 find -name *name* 查找包含name字符串的文件所在目录 find -user faith 查看用户faith的文件 locate用法与find基本相似，只是locate搜索速度较快些，locate一般系统不会自带，需要安装，可用yum安装 whereis只能搜索程序名 which则是只查询path中的环境变量\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:8","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.9 压缩和解压命令 gzip/guzip zip/unzip tar 详细\r\rgzip和gunzip一般可用参数是-r，例: gzip test.txt　压缩文件 gzip -r test 压缩所有test下的子文件 gunzip test.gz 解压文件 zip和unzip可用参数较多，例： zip test 不跟参数直接使用 zip -r test 递归压缩test下所有文件 unzip test 不跟参数直接使用 unzip -n 解压时不覆盖已存在的文件 unzip -o 解压时覆盖已存在的文件 unzip -d 将文件解压到目录中去 tar使用的较为多些，用法也多，最常用的是zxcvf几个参数，例： -c 创建新文档，就是代表压缩的意思 -x 解压文档 -f 使用归档文件 -z 使用gzip解压 -v 详细输出模式 最为常用的使用方法： tar -zcvf test.tar test 将test压缩为test.tar并输出详细信息 tar -zxvf test.tar 将test.tar解压缩，并输出详细信息\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:9","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.10 定时任务 crontab 详细\r\rcrontab [-u user] 文件 crontab [-u user] {-r -e -l} 不加-u的话默认当前用户 －e：执行文字编辑器来设定时程表，内定的文字编辑器是vi。 －r：删除目前的时程表。 －l：列出目前的时程表。 crontab -e 就可以打开一个文件进行编辑 crontab文件的格式为“M H D m d cmd”，M为分钟1-59，H为小时1-24，D为天1-31，m为月1-12，d为周0-6（0为周日）。cmd代表要执行的程序，*代表每分钟都执行 * * * * * sh /opt/lampp/test.sh 表示每分钟执行一次test.sh这个脚本 */5 * * * * sh /opt/lampp/test.sh 表示每5分钟执行一次test.sh这个脚本 30 21 * * * /usr/local/apache/bin/apachectl restart 表示每晚的21:30重启apache\r\r","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:10","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["文档"],"content":"比较使用的工具软件/插件。例：密码管理器、谷歌浏览器常用插件等。","date":"2020-11-18","objectID":"/posts/docs/software-tools/","tags":["工具"],"title":"工具软件","uri":"/posts/docs/software-tools/"},{"categories":["文档"],"content":"常用的 ","date":"2020-11-18","objectID":"/posts/docs/software-tools/:1:0","tags":["工具"],"title":"工具软件","uri":"/posts/docs/software-tools/"},{"categories":["文档"],"content":"密码管理器 keepass 1 Password ","date":"2020-11-18","objectID":"/posts/docs/software-tools/:1:1","tags":["工具"],"title":"工具软件","uri":"/posts/docs/software-tools/"},{"categories":["文档"],"content":"谷歌浏览器插件 Video DownloadHelper 一款视频下载插件，网页上能看的视频几乎都可以捕捉下载 GitHub加速 国内Github下载很慢，这个插件可以提升下载速度 谷歌访问助手 见名知意、有了它，谷歌可以访问了，虽然依旧龟速 沙拉查词-聚合词典划词翻译 多语言混合网页阅读利器 ","date":"2020-11-18","objectID":"/posts/docs/software-tools/:1:2","tags":["工具"],"title":"工具软件","uri":"/posts/docs/software-tools/"},{"categories":["文档"],"content":"Redis客户端工具 Another Redis Desktop Manager 开源软件，用着还可以 Redis Desktop Manager 官方工具，新版部分功能收费 ","date":"2020-11-18","objectID":"/posts/docs/software-tools/:1:3","tags":["工具"],"title":"工具软件","uri":"/posts/docs/software-tools/"},{"categories":["文档"],"content":"与开发有关的常用在线工具。如：json解析、程序员在线工具箱等","date":"2020-11-18","objectID":"/posts/docs/online-tools/","tags":["工具"],"title":"在线工具","uri":"/posts/docs/online-tools/"},{"categories":["文档"],"content":"Markdown在线编辑器 JSON解析 程序员在线工具箱 程序员在线工具箱2 ","date":"2020-11-18","objectID":"/posts/docs/online-tools/:0:0","tags":["工具"],"title":"在线工具","uri":"/posts/docs/online-tools/"},{"categories":["文档"],"content":"常见官方网址导航","date":"2020-11-18","objectID":"/posts/docs/official-website-about-technology/","tags":["网站"],"title":"常见官网","uri":"/posts/docs/official-website-about-technology/"},{"categories":["文档"],"content":"36 ","date":"2020-11-18","objectID":"/posts/docs/official-website-about-technology/:0:0","tags":["网站"],"title":"常见官网","uri":"/posts/docs/official-website-about-technology/"},{"categories":["文档"],"content":"技术相关 Markdown中文网 清华大学开源软件镜像站 w3cschool github HBuilder Data Structure Visualizations visualgo OSCHINA-中国开源技术交流社区 阿里云云效Maven Maven中央仓库 SpringBoot官方文档 Nacos官网 菜鸟教程 jekyll主题 jekyll中文文档 jekyll英文文档 Hugo官网 Hugo英文文档 Hugo中文文档 图标网 阿里巴巴矢量图标库 Markdown 中文网 LeanCloud valine文档 一套绝佳的图标字体库和CSS框架 数安时代-免费SSL证书 Gravatar - 全球公认的头像 ","date":"2020-11-18","objectID":"/posts/docs/official-website-about-technology/:1:0","tags":["网站"],"title":"常见官网","uri":"/posts/docs/official-website-about-technology/"},{"categories":["文档"],"content":"其他 keepass ","date":"2020-11-18","objectID":"/posts/docs/official-website-about-technology/:2:0","tags":["网站"],"title":"常见官网","uri":"/posts/docs/official-website-about-technology/"},{"categories":["日志"],"content":"logback常见配置","date":"2020-11-16","objectID":"/posts/technology-other/logback-configurature/","tags":["logback"],"title":"logback配置","uri":"/posts/technology-other/logback-configurature/"},{"categories":["日志"],"content":"logback配置 此配置将不同级别的日志归置到不同的文件中。 项目中使用，将对应的property属性值更改即可。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- 日志级别从低到高分为TRACE \u003c DEBUG \u003c INFO \u003c WARN \u003c ERROR \u003c FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\u003e \u003c!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --\u003e \u003c!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\u003e \u003c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\u003e \u003cconfiguration scan=\"true\" scanPeriod=\"10 seconds\"\u003e \u003ccontextName\u003elogback\u003c/contextName\u003e \u003c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --\u003e \u003cproperty name=\"log.path\" value=\"logs\"/\u003e \u003cproperty name=\"project.name\" value=\"project-name\"/\u003e \u003c!--0. 日志格式和颜色渲染 --\u003e \u003c!-- 彩色日志依赖的渲染类 --\u003e \u003cconversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\"/\u003e \u003cconversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\"/\u003e \u003cconversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\"/\u003e \u003c!-- 彩色日志格式 --\u003e \u003cproperty name=\"CONSOLE_LOG_PATTERN\" value=\"${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(%L:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\"/\u003e \u003c!--1. 输出到控制台--\u003e \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003c/filter\u003e \u003cencoder\u003e \u003cPattern\u003e${CONSOLE_LOG_PATTERN}\u003c/Pattern\u003e \u003c!-- 设置字符集 --\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!--2. 输出到文档--\u003e \u003c!-- 2.1 level为 DEBUG 日志，时间滚动输出 --\u003e \u003cappender name=\"DEBUG_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-debug.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c!-- 设置字符集 --\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 日志归档 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-debug-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录debug级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.2 level为 INFO 日志，时间滚动输出 --\u003e \u003cappender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-info.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 每天日志归档路径以及格式 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录info级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003einfo\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.3 level为 WARN 日志，时间滚动输出 --\u003e \u003cappender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-warn.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%","date":"2020-11-16","objectID":"/posts/technology-other/logback-configurature/:0:0","tags":["logback"],"title":"logback配置","uri":"/posts/technology-other/logback-configurature/"},{"categories":null,"content":"关于我 程序员。 极简主义。 曾喜欢玩游戏 （🎮 LOL S5 网一钻二、16年开始基本不玩了、没时间）。 热爱技术，喜欢瞎倒腾。生命不息、折腾不止（例如这个博客）😄。 现居于上海。 怕什么真理无穷，进一寸有一寸的欢喜。 ","date":"2020-11-16","objectID":"/about/:0:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"技术栈 数据库：mysql、redis、mongoDB、zookeeper等。 框架：spring、mybatis、springboot、springcloud系列（eureka、hystrix、ribbon、feign、zuul、actuator）、dubbo等。 java：并发编程、JVM调优、netty。 其他：tomcat、nginx、openresty、rabbitmq、docker、docker-compose等。 ","date":"2020-11-16","objectID":"/about/:0:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"博客 始建于2020年11月14日，尝试过jekyll。 目前使用 hugo ，部署于 阿里云ECS ，对象存储 阿里云OSS 。 自动发布使用 Gitee-WebHooks （最初在github，网络原因，最终迁移到gitee） + 自写脚本 。 ","date":"2020-11-16","objectID":"/about/:0:3","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"网址 https://wlizhi.cc ：注册于2020年11月16日 https://wlz922.top ：注册于2017年11月20日 https://wlizhi.github.io https://wlizhi.gitee.io （个人版，无自动发布，很少更新） ","date":"2020-11-16","objectID":"/about/:0:4","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"友情链接 Jack大佬 | 叶良辰 ","date":"2020-11-16","objectID":"/about/:0:5","tags":null,"title":"关于","uri":"/about/"}]