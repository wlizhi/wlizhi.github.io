[{"categories":["折腾"],"content":"前言 搭建过程有些波折，好在总算完善了。目前博客采用hugo的主题。 不得不说，hugo使用起来相较于jekyll简单了许多，除了主题生态没有jekyll的丰富，别的没毛病。 ","date":"2020-11-19","objectID":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/:0:1","tags":["折腾","经历"],"title":"我的博客搭建历程","uri":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"},{"categories":["折腾"],"content":"起因 有一次听jack老师的课，翻了某位同学博客 （叶良辰学习笔记），陡然眼前一亮，原来笔记还可以这么搞。 其实几年前我就有意搭建个人博客，一直没落实的原因：确实有些忙，偶尔闲下来时又去学习新的知识，自己写博客系统的话， 太耗时间、精力（作为一个java程序员，前端能力有限，你懂得。），会的一堆后端技术，这里毫无用武之地。时至今日这个计划已经迟滞了三年多。 很多云笔记也有分享功能，甚至一键发布博客功能。比如有道云笔记、印象笔记、蚂蚁笔记等，都有用过。看了这位同学的笔记（博客）后， 回想自己用云笔记的方式，决定还是研究一下博客系统。一个是私密文档，一个是公开文档。 ","date":"2020-11-19","objectID":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/:0:2","tags":["折腾","经历"],"title":"我的博客搭建历程","uri":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"},{"categories":["折腾"],"content":"百度 - 货比三家 直接写静态页面得不偿失。页面+后端方式实现博客、管理等功能，有点重了，没必要。无论如何，最终内容还是要静态页面，除非你不想被搜索引擎扒到。 首先百度搜索静态页面生成器，很多流行的，不晓得先入手研究哪个，对比了许多帖子，决定先看看jekyll。 然后在jekyll主题网站选择了两三个主题。 一般主题网站中的主题都有demo，先看demo效果。 到github仓库，fork到自己的github。 根据README.md文档的介绍，将代码拉取到本地，用IDE打开。（我使用的IDEA，毕竟做后端的…） 根据使用文档（很多主题其实只有一个文件介绍，不是特别详细，需要自己摸索）修改配置。 尝试了几个主题后，大多功能都正常，个别小功能有问题，本地很难调试。（依赖ruby、nodejs等环境，作为java程序员，对这玩意儿认知完全等于0， 当然，如果只是需求、分类标签等几个模块能用就成，还是可以的） 尝试了几个主题后，感觉还凑合，将修改好的主题推送到github后，通过gitPages托管。能访问，龟速。 ","date":"2020-11-19","objectID":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/:0:3","tags":["折腾","经历"],"title":"我的博客搭建历程","uri":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"},{"categories":["折腾"],"content":"选择 - Hugo 之后翻看网上的博客时，看到有人说使用的hugo，于是点进去搜了一通。选择了几个主题，挨个试。这里说下我使用的感受： jekyll优点：主题更丰富，选择性更多。 jekyll缺点：使用实在太复杂，构建速度着实慢了些。 hugo缺点：主题没jekyll选择性那么多，也还可以。官网上有些主题相对简陋。（注：不是简约，是简陋） hugo优点：使用真的简单，比jekyll简单太多了。构建速度真的快，比jekyll快很多很多倍。（目前没太多内容，构建后大概100多个静态文件，构建需要500ms左右） 使用jekyll时，看到一个比较喜欢的主题ThemePersephone，只是搞了半天，gitpages托管 的代码是可以访问了，本地环境始终弄不好（ruby的问题，下载了最新版本不行。准备换个版本的安装包，死活下载不了，官网被墙的厉害），只好放弃。 之后在HugoThemes下载主题，试用。只需要下载一个二进制文件，不需要其他任何依赖。 没有对比就没有伤害，最终选择Hugo ","date":"2020-11-19","objectID":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/:0:4","tags":["折腾","经历"],"title":"我的博客搭建历程","uri":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"},{"categories":["折腾"],"content":"搭建 两款主题hugo-theme-hello-friend-ng和loveit, 最终选择loveit这款主题，原因是，文档超级详细，功能足够丰富。支持搜索引擎（两款）、评论系统、shortcode、emoji等。 该有的功能基本都支持。唯一不满的是md text块的背景色、字体颜色有点丑。有空在研究给换个色。 搜索引擎支持两种： lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 选择lunr，原因简单，现在的访问量来看，缺点可以忽略。 评论系统略有点麻烦，支持6种评论系统（disqus、gitalk、valine、facebook、telegram comments、commento、utterances） ，挨个打开，打开valine官网速度较快，最终选择这个，不为别的，官网打开速度的印象分。 评论本身配置相对简单，根据提示来就行。麻烦在邮件提醒功能，valine从v1.4.0版本后，不再支持邮件提醒功能。 只能使用的第三方邮件提醒。自己写太费时间，我选择的Valine-Admin, 部署到LeanCloud创建的应用中。部署后需要配置一些环境变量，主要是邮件发送的服务器、账号、授权码、自己网站url等。 ","date":"2020-11-19","objectID":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/:0:5","tags":["折腾","经历"],"title":"我的博客搭建历程","uri":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"},{"categories":["折腾"],"content":"迁移 - 阿里云 图片资源使用阿里云对象存储OSS，静态页面迁移到阿里云服务器。 GitPages托管方式，访问速度有点慢，还算能接受吧。服务器有、域名有（旧的域名不太喜欢，新域名备案完成还得几天），最终决定前移到阿里云。 部署:服务器安装docker，docker安装nginx，安装git，将hugo生成的html文件拉取到nginx路由的目录下，部署完成。 自动部署，使用Github的WebHooks，服务器写一个脚本即可。 流程大概是这个样子：当push代码到github时，触发回调接口。在服务器上部署一个web项目（我使用的springboot），暴露一个接口供webhooks调用。 接口内容是异步方式（一个单线程的线程池）执行shell脚本，完成自动部署。 更轻量的方式，手写代码，使用socket接收请求，执行脚本更加高效。接口方式写起来比较快，十多分钟完事。 ","date":"2020-11-19","objectID":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/:0:6","tags":["折腾","经历"],"title":"我的博客搭建历程","uri":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"},{"categories":["折腾"],"content":"域名备案 wlz922.top是我一直使用的域名，域名备案相对麻烦，思虑再三还是决定再注册一个。 新域名wlizhi.cc审核估计还得几天。 备案流程有点麻烦，周期是比较长的（到域名服务商注册 -\u003e 阿里云初审 -\u003e 通管局审核）。首先注册域名，注册后是不能直接备案的，要等1-3天。 然后申请备案，填一些必须的资料。阿里云上关于备案相关资料太多，没看，直接按照流程提示填写资料。之后初审驳回一次（验证资料不规范）， 按要求重新上传资料，初审通过，等待管局审核。有一点需要说明，域名备案时，解析的网站首页必须和资料填写的内容一致，页脚必须有备案号链接到 工信部域名备案管理网站（我上个域名备案时让填的不是这个网址，搞不懂）。 ","date":"2020-11-19","objectID":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/:0:7","tags":["折腾","经历"],"title":"我的博客搭建历程","uri":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"},{"categories":["折腾"],"content":"最后 看jekyll、hugo文档、选主题、读主题及主题支持各种插件文档、迁移阿里云。历时四天，博客主题基本选定（主题选了两天多，换了五六个， 没办法，强迫症）、搭建完成。没事还是要研究一下hugo，毕竟折腾已成本能。 ","date":"2020-11-19","objectID":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/:0:8","tags":["折腾","经历"],"title":"我的博客搭建历程","uri":"/posts/experience/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"},{"categories":["linux"],"content":"linux 基础概念、文件系统组成、常用命令、应用安装 - 卸载","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"1. 基础介绍 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:1:0","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"发行的linux版本 Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS linux各个版本\"\rlinux各个版本\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:1:1","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"系统目录结构 linux目录结构\"\rlinux目录结构\r 系统启动必须： 信息\r\r /boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。 /etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。 /lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中 \r\r 指令集合： 信息\r\r /bin：存放着最常用的程序和指令 /sbin：只有系统管理员能使用的程序和指令。 \r\r 外部文件管理： 信息\r\r /dev ：Device(设备)的缩写, 存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。 /media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。 /mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 \r\r 临时文件 信息\r\r /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。 /tmp：这个目录是用来存放一些临时文件的。 \r\r 账户： 信息\r\r /root：系统管理员的用户主目录。 /home：用户的主目录，以用户的账号命名的。 /usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序与指令。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 \r\r 运行过程中要用： 信息\r\r /var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。 /proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。 \r\r 扩展用的： 信息\r\r /opt：默认是空的，我们安装额外软件可以放在这个里面。 /srv：存放服务启动后需要提取的数据（不用服务器就是空） \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:1:2","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"linux基础命令 shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。 信息\r\r# shutdown -P now ### 关闭机器 # shutdown -H now ### 停止机器 # shutdown -r 09:35 ### 在 09:35am 重启机器\r\r 要取消即将进行的关机，只要输入命令： # shutdown -c halt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。 信息\r\r# halt ### 停止机器 # halt -p ### 关闭机器 # halt –reboot ### 重启机器\r\r poweroff 会发送一个 ACPI 信号来通知系统关机。 信息\r\r# poweroff ### 关闭机器 # poweroff –halt ### 停止机器 # poweroff –reboot ### 重启机器\r\r reboot 命令 reboot 通知系统重启。 信息\r\r# reboot ### 重启机器 # reboot –halt ### 停止机器 # reboot -p ### 关闭机器\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:1:3","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"2. linux用户/用户组 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:2:0","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"增加一个用户组 信息\r\rgroupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 例1： # groupadd group1 ##此命令向系统中增加了一个新组group1 例2： # groupadd -g 1003 group2 ##此命令向系统中增加了一个新组group2，同时指定新组的组标识号是1003 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:2:1","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"删除一个用户组 信息\r\rgroupdel 用户组 例：# groupdel group1 ##此命令从系统中删除组group1。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:2:2","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"修改用户组的属性 信息\r\rgroupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n 新用户组 将用户组的名字改为新名字 例1： # groupmod –g 10000 -n group3 group2 ##此命令将组group2的标识号改为10000，组名修改为group3。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:2:3","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"添加用户账号 信息\r\r参数说明： 选项: -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名: 指定新账号的登录名。 useradd 选项 用户名 例1： # useradd –d /usr/peter -m peter ##创建用户peter，其中-d和-m选项用来为登录名peter产生一个主目录/usr/peter。 例2： # useradd -s /bin/sh -g group1 –G group2,root peter2 ##新建用户peter2，登录Shell是 /bin/sh，属于group1，又属于group2和root。 这里可能新建组：#groupadd group1及groupadd group2 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:2:4","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"删除账号 信息\r\r userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 例如： # userdel -r peter2 ##删除用户peter2（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:2:5","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"修改账号 信息\r\rusermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： # usermod -s /bin/sh -d /home/p –g group2 peter ##将用户peter的登录Shell修改为sh，主目录改为/home/p，用户组改为group2。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:2:6","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"用户口令的管理 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 信息\r\rpasswd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。\r\r 如果默认用户名，则修改当前用户的口令。例如，假设当前用户是peter，则下面的命令修改该用户自己的口令： 信息\r\r$ passwd Old password:****** New password:******* Re-enter new password:*******\r\r 如果是超级用户，可以用下列形式指定任何用户的口令： 信息\r\r# passwd peter New password:******* Re-enter new password:*******\r\r 为用户指定空口令时，执行下列形式的命令：# passwd -d peter passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：# passwd -l peter ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:2:7","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"切换用户组 信息\r\r$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:2:8","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"与用户账号有关的系统文件 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等 /etc/passwd文件 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 信息\r\r例子： ＃ cat /etc/passwd root:x:0:0:Superuser:/: daemon:x:1:1:System daemons:/etc: bin:x:2:2:Owner of system commands:/bin: sys:x:3:3:Owner of system files:/usr/sys: adm:x:4:4:System accounting:/usr/adm: uucp:x:5:5:UUCP administrator:/usr/lib/uucp: auth:x:7:21:Authentication administrator:/tcb/files/auth: cron:x:9:16:Cron daemon:/usr/spool/cron: listen:x:37:4:Network daemon:/usr/net/nls: lp:x:71:18:Printer administrator:/usr/spool/lp: \r\r 每一行记录对应着一个用户（其中bin/sys/adm/uucp/lp/nobody是伪用户），每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell /etc/group文件 用户组的所有信息都存放在/etc/group文件中。 信息\r\rroot::0:root bin::2:root,bin sys::3:root,uucp adm::4:root,adm daemon::5:root,daemon lp::7:root,lp users::20:root,sam\r\r 此文件的格式类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:2:9","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"3. 文件与目录 ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:3:0","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"文件基本属性 1. 文件的属性概貌 Lighthouse (image)\"\rLighthouse (image)\r 信息\r\r第一个字符：代表这个文件的类型，是目录、文件，还是一个链接等等 [ d ] 目录 [ - ] 文件 [ l ] 链接文档(link file) [ b ] 可供储存的接口设备(可随机存取装置) [ c ] 串行端口设备，例如键盘、鼠标(一次性读取装置) 接下来的字符：以三个一组分成三组，用 r、w、x 三个参数的组合表示，位置不会改变 [ r ] 代表可读(read) [ w ] 代表可写(write) [ x ] 代表可执行(execute) [ - ] 没有权限\r\r 2. 文件的属主与属组 每一个文件，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 chgrp：更改文件属组 信息\r\rchgrp [-R] 属组名 文件名 参数选项 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。\r\r chown：更改文件属主，也可以同时更改文件属组 语法： chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 进入 /root 目录（~）将install.log的拥有者改为bin这个账号： 例： chown root:root aa ##更改aa的属主与属组 chmod：更改文件9个属性 文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！ 变更权限的指令chmod的语法是这样的： 信息\r\r chmod [-R] xyz 文件或目录 选项与参数： xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下： chmod +x aa ##更改aa的属性,加x权限 chmod 777 aa ##更改aa的属性，三组权限都设置成7 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:3:1","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"文件与目录管理命令 使用 man [命令] 来查看各个命令的使用文档，如 ：man cp 信息\r\rls: 列出目录 —ll cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 —–scp网络复制 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:3:2","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"硬链接与软链接 硬连接 信息\r\r硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\r\r 软连接 信息\r\r另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 例： $touch a #创建一个测试文件a $ ln a b #创建a的一个硬连接文件b –echo 123 \u003e a ##a,b的内容同时变为123 $ ln -s a c #创建a的一个符号连接文件c $ ls -li # -i参数显示文件的inode节点信息 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:3:3","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"4. 安装程序rpm/yum ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:4:0","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"1. rpm方式 需要去下载相应的rpm格式的安装包xxxx.rpm 信息\r\rrpm [参数] rpm包 -i 安装 -U 更新（很少用） -e 卸载 -v 显示安装信息 -h 显示安装进度 例： rpm -ivh jdk-8u172-linux-x64.rpm 安装jdk8并显示安装进度和安装信息 rpm -qa|grep jdk查看jdk的安装包 rpm -e jdk1.8-1.8.0_221-fcs.x86_64 卸载jdk8 ，只适用于rpm包安装的软件\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:4:1","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"2. yum方式 yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。 基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 2.1 yum语法 信息\r\ryum [options] [command] [package …] options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为\"yes\"），-q（不显示安装的过程）等等。 command：要进行的操作。 package操作的对象。 例： yum search jdk 搜索jdk安装包 yum install -y java-1.8.0-openjdk.x86_64 安装openjdk，-y表示安装过程中的询问自动选y yum list installed ｜grep jdk 列出安装的jdk软件包 yum remove java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-headless.x86_64 卸载jdk\r\r 2.2 yum常用命令 示例\r\r1.列出所有可更新的软件清单命令：yum check-update 2.更新所有软件命令：yum update 3.仅安装指定的软件命令：yum install \u003cpackage_name\u003e 4.仅更新指定的软件命令：yum update \u003cpackage_name\u003e 5.列出所有可安裝的软件清单命令：yum list 6.删除软件包命令：yum remove \u003cpackage_name\u003e 7.查找软件包 命令：yum search 8.清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers\r\r 2.3 yum源 官方的yum源在国内访问效果不佳。需要改为国内比较好的阿里云或者网易的yum源 在/etc/yum..repos.d/下进行如下操作(请做好相应备份)： 示例\r\rwget http://mirrors.163.com/.help/CentOS7-Base-163.repo mv CentOS7-Base-163.repo CentOS-Base.repo 重建缓存： yum clean all yum makecache\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:4:2","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"3. 配置环境变量 在Linux系统下，安装应用程序后，在安装目录之外，可能仍然会出现 “command not found ”。 要解决所有地方都能使用应用程序，就涉及到环境变量path的设置问题 3.1 配置环境变量 系统环境变量文件在/etc下的profile文件，我们可以用vi profile命令来编辑该文件，将变量添加进去 一般需要将安装文件的bin目录加入path中，可在profile中加入下面一行代码，如： 示例\r\rvim /etc/profile # 末尾追加以下内容 export JAVA_HOME=/usr/java/default export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\r\r 3.2 环境变量生效 source /etc/profile ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:4:3","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"5. shell脚本 shell语言是一门linux系统下的工具语言，主要用于写一些linux系统下的操作命令，实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。或者直接理解为shell命令是可以执行多个linux命令的脚本。Shell 种类众多，有以下种类（一般使用的 Bash，就是 Bourne Again Shell，它是大多数Linux 系统默认的 Shell）： 示例\r\rBourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh）\r\r shell并不复杂，有编程基础的话，简单入门两三个小时就可以入门，主要是把一些重复操作的linux命令写成shell脚本来执行一下。以下列出shell常规的一些要素： ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:5:0","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"1. 解释器与执行shell 示例\r\r解释器 #!/bin/sh Bourne shell版本 #!/bin/bash Bourne Again Shell 版本 执行shell chomd +x ./test.sh #使脚本具有执行权限 ./test.sh #执行脚本 “./”表示当前目录下\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:5:1","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"2. 演示 #!/bin/bash ##声明bash脚本 ##demo ##注释 echo $PATH ##打印PATH环境变量 name=\"Peter\" ##定义变量name echo $name ##打印name值 echo \"I am ${name}'s friend\" ##字符串拼接 echo \"\" name2=\"I am ${name}'s good friend\" ##字符串拼接 echo $name2 echo \"\" names=(\"Peter\" \"james\" \"deer\") ##定义数组 echo ${names[@]} ##遍历数组 echo \"I am ${names[1]}'s friend\" ##第二个元素 echo \"I have ${#names[@]}friends\" ##数组长度 echo \"\" for var in ${names[@]}; ##循环数组 do if test $var = 'Peter' ##字符串相等 then echo \"I am Peter\" else echo \"I am ${var}'s friend\" fi done echo \"\" if [ $(ps -ef | grep -c \"ssh\") -gt 1 ]; ##查找是否有ssh服务 then echo \"ssh service open\"; fi echo \"\" echo \"sh arg: $0$1\" ##sh的传参 重定向： 1、test ‘aa’ -eq “bb” \u003e out ##命令输出到 out文件，报错信息并不会进入out 2、test ‘aa’ -eq “bb” \u003e out 2\u003e\u00261 ##将stderr合并到stdout，则报错信息进入了out ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:5:2","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6. 常用命令 ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:0","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6.1 最常用的是cd 命令 示例\r\rcd 进入用户主目录； cd ~ 进入用户主目录； cd - 返回进入此目录之前所在的目录； cd .. 返回上级目录（若当前目录为“/“，则执行完后还在“/\"；\"..“为上级目录的意思）； cd ../.. 返回上两级目录；\r\r ls，ll， wget， curl， history ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:1","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6.2 新建文件夹和文件：mkdir touch 示例\r\rmkdir 创建文件夹 mkdir dirname 直接跟文件夹名，可在当前目录下创建文件夹 mkdir /opt/lamp/dirname 可跟路径 mkdir -p /opt/lam/dirname 假如lam不存在，需要用-p才可以创建该文件夹 touch 新建文件 touch dilename 可直接跟文件名在当前目录下创建新的文件 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:2","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6.3 cat/less/more/tail等文件查看命令 详细\r\r-n或-number：有1开始对所有输出的行数编号； -b或–number-nonblank：和-n相似，只不过对于空白行不编号； -s或–squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行； -A：显示不可打印字符，行尾显示“$”； -e：等价于\"-vE\"选项； -t：等价于\"-vT\"选项； -e：文件内容显示完毕后，自动退出； -f：强制显示文件； -g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度； -l：搜索时忽略大小写的差异； -N：每一行行首显示行号； -s：将连续多个空行压缩成一行显示； -S：在单行显示较长的内容，而不换行显示； -x\u003c数字\u003e：将TAB字符显示为指定个数的空格字符。 -\u003c数字\u003e：指定每屏显示的行数； -d：显示“[press space to continue,‘q’ to quit.]”和“[Press ‘h’ for instructions]”； -c：不进行滚屏操作。每次刷新这个屏幕； -s：将多个空行压缩成一行显示； -u：禁止下划线； +\u003c数字\u003e：从指定数字的行开始显示。 按Space键：显示文本的下一屏内容。 按Enier键：只显示文本的下一行内容。 按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。 按H键：显示帮助屏，该屏上有相关的帮助信息。 按B键：显示上一屏内容。 按Q键：退出rnore命令。 –retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用； -c或——bytes=：输出文件尾部的N（N为整数）个字节内容； -f或；–follow：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效； -F：与选项“-follow=name”和“–retry\"连用时功能相同； -n或——line=：输出文件的尾部N（N位数字）行内容。 –pid=\u003c进程号\u003e：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令； -q或——quiet或——silent：当有多个文件参数时，不输出各个文件名； -s\u003c秒数\u003e或——sleep-interal=\u003c秒数\u003e：与“-f”选项连用，指定监视文件变化时间隔的秒数； -v或——verbose：当有多个文件参数时，总是输出各个文件名； 一般tail命令最常用的-n和-f，例： tail filename 读取filename最后10行内容 tail -f filename 实时动态读取filename最后10行内容 tail -20f filename 实时动态读取filename最后20行内容 \r\r cat和less及more指令相似，cat是一次性读取所有内容，文件内容较多时速度较慢。less与more的区别在于：less可以前后翻页查看，more只能向前翻页查看。 tail则用于实时获取log信息，从后向前读取内容 上述四种命令均可跟grep搭配使用cat/less/tail |grep mysql ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:3","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6.4 查看文件大小的命令 du/df 详细\r\rdu -sh * 显示当前目录下所有文件的大小 du -sh filename 显示该文件大小 du -sh 显示当前目录所占空间大小 -s或 仅显示总计，只列出最后加总的值。 -h或 以K，M，G为单位，提高信息的可读性。 df 显示磁盘占用信息 直接df默认一k为单位 df -lh 显示本地系统的占用信息，以K，M，G为单位\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:4","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6.5 大重点–文本编辑器 vi 详细\r\rvi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。 Linux中的vi编辑器叫vim，它是vi的增强版（vi Improved），与vi编辑器完全兼容，而且实现了很多增强功能。 vi编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用vi编辑器就必须熟练掌握着两种模式的切换。 默认情况下，打开vi编辑器后自动进入命令模式。从编辑模式切换到命令模式使用“esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。 vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下： Ctrl+u：向文件首翻半屏； 2 Ctrl+d：向文件尾翻半屏； 3 Ctrl+f：向文件尾翻一屏； 4 Ctrl+b：向文件首翻一屏； 5 Esc：从编辑模式切换到命令模式； 6 ZZ：命令模式下保存当前文件所做的修改后退出vi； 7 :行号：光标跳转到指定行的行首； 8 :$：光标跳转到最后一行的行首； 9 x或X：删除一个字符，x删除光标后的，而X删除光标前的； 10 D：删除从当前光标到光标所在行尾的全部字符； 11 dd：删除光标行正行内容； 12 ndd：删除当前行及其后n-1行； 13 nyy：将当前行及其下n行的内容保存到寄存器?中，其中？为一个字母，n为一个数字； 14 p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方； 15 P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方； 16 /字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示； 17 ？name：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示； 18 a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作； 19 a：在当前字符后添加文本； 20 A：在行末添加文本； 21 i：在当前字符前插入文本； 22 I：在行首插入文本； 23 o：在当前行后面插入一空行； 24 O：在当前行前面插入一空行； 25 :wq：在命令模式下，执行存盘退出操作； 26 :w：在命令模式下，执行存盘操作； 27 :w！：在命令模式下，执行强制存盘操作； 28 :q：在命令模式下，执行退出vi操作； 29 :q！：在命令模式下，执行强制退出vi操作； 30 :e文件名：在命令模式下，打开并编辑指定名称的文件； 31 :n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件； 32 :f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例； 33 :set nu：在命令模式下，用于在最左端显示行号； 34 :set nonu：在命令模式下，用于在最左端不显示行号； 35 :1,3y 复制第一行到第三行 36 :1,3d 删除第一行到第三行 37 :1,3s/str/str_new/g 替换第一行到第三行中的字符串 38 :1,3s/str/str_new 替换第一行到第三行中的字符串第一个字符 39 :1,3 g/str /d 删除第一行到第三行中含有这个字符串的行\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:5","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6.6 重定向 \u003e 输出重定向 who \u003e bbb.txt 将aaa的内容写入bbb中，覆盖写入 cat bbb.txt » ccc.txt 讲aaa的内容追加写入bbb中，不覆盖原来内容 \u003e bbb.txt 将bbb清空 输入重定向 grep 05:37:43.730 \u003c web.2019-07-22.0.log 大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。 一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。 同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 重定向深入理解 详细\r\r一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：  标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。  标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。  标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command \u003e file 将 stdout 重定向到 file，command \u003c file 将stdin 重定向到 file。\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:6","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6.7 查看服务 详细\r\rnetstat -nlpt|grep 80 查看该端口号是否被占用 free -m //查看LINUX内存剩余容量 ps可以查看具体的进程信息，一般与管道符连接其他命令使用，如：grep ps常用参数-ef/-aux，一般最常用还是-ef，例：ps -ef|grep mysql 查询mysql进程 top也可查看进程信息，而且是动态显示 whoami 查看当前登陆用户 who 查看多少用户在使用系统 date查看系统时间，可跟时间格式使用 cal查看日历，可跟年份，查看指定的年份 chkconfig –list #查看系统服务启动 chkconfig iptables on #开机启动该服务 chkconfig iptables off #开机不启动该服务 service iptables start #启动该服务 service iptables restart #重启启该服务 ps -ef|grep mysql|grep -v grep|awk ‘{print $2}‘ps -ef|grep mysql 是查询mysql服务的进程 |后的grep -v grep 是匹配不包含grep的行 awk是取查询结果的第几列，awk ‘{print $2}‘则是取第二列的值 grep 无参数则显示匹配的行 -c 显示匹配的行数 -v 显示不匹配的行\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:7","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6.8 杀掉进程 kill命令 详细\r\rkill最常用的参数是-9，用法：kill -9 进程号 即可强制杀掉该进程 统计命令 wc 常用的参数是 -l 用法：wc -l ，例： ps -ef|grep mysql|wc -l 统计查询出的mysql进程的行数 查找命令 find/locate/whereis/which find -name 后跟文件名，可查看文件所在目录，可跟user，查看属于user的文件 find -name filename 查找filename所在目录 find -name name* 查找开头为name的文件所在目录 find -name *name 查找结尾为name的文件所在目录 find -name *name* 查找包含name字符串的文件所在目录 find -user faith 查看用户faith的文件 locate用法与find基本相似，只是locate搜索速度较快些，locate一般系统不会自带，需要安装，可用yum安装 whereis只能搜索程序名 which则是只查询path中的环境变量\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:8","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6.9 压缩和解压命令 gzip/guzip zip/unzip tar 详细\r\rgzip和gunzip一般可用参数是-r，例: gzip test.txt　压缩文件 gzip -r test 压缩所有test下的子文件 gunzip test.gz 解压文件 zip和unzip可用参数较多，例： zip test 不跟参数直接使用 zip -r test 递归压缩test下所有文件 unzip test 不跟参数直接使用 unzip -n 解压时不覆盖已存在的文件 unzip -o 解压时覆盖已存在的文件 unzip -d 将文件解压到目录中去 tar使用的较为多些，用法也多，最常用的是zxcvf几个参数，例： -c 创建新文档，就是代表压缩的意思 -x 解压文档 -f 使用归档文件 -z 使用gzip解压 -v 详细输出模式 最为常用的使用方法： tar -zcvf test.tar test 将test压缩为test.tar并输出详细信息 tar -zxvf test.tar 将test.tar解压缩，并输出详细信息\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:9","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["linux"],"content":"6.10 定时任务 crontab 详细\r\rcrontab [-u user] 文件 crontab [-u user] {-r -e -l} 不加-u的话默认当前用户 －e：执行文字编辑器来设定时程表，内定的文字编辑器是vi。 －r：删除目前的时程表。 －l：列出目前的时程表。 crontab -e 就可以打开一个文件进行编辑 crontab文件的格式为“M H D m d cmd”，M为分钟1-59，H为小时1-24，D为天1-31，m为月1-12，d为周0-6（0为周日）。cmd代表要执行的程序，*代表每分钟都执行 * * * * * sh /opt/lampp/test.sh 表示每分钟执行一次test.sh这个脚本 */5 * * * * sh /opt/lampp/test.sh 表示每5分钟执行一次test.sh这个脚本 30 21 * * * /usr/local/apache/bin/apachectl restart 表示每晚的21:30重启apache\r\r","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E7%A1%80/:6:10","tags":["linux","操作系统"],"title":"Linux基础","uri":"/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"categories":["文档"],"content":"比较使用的工具软件/插件。例：密码管理器、谷歌浏览器常用插件等。","date":"2020-11-18","objectID":"/posts/docs/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/","tags":["工具"],"title":"实用工具","uri":"/posts/docs/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"categories":["文档"],"content":"常用的 ","date":"2020-11-18","objectID":"/posts/docs/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/:1:0","tags":["工具"],"title":"实用工具","uri":"/posts/docs/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"categories":["文档"],"content":"密码管理器 keepass 1 Password Unikey / 密码保 —\u003e 没用过 LastPass —\u003e 没用过 ","date":"2020-11-18","objectID":"/posts/docs/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/:1:1","tags":["工具"],"title":"实用工具","uri":"/posts/docs/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"categories":["文档"],"content":"谷歌浏览器插件 Video DownloadHelper 一款视频下载插件，网页上能看的视频几乎都可以捕捉下载 GitHub加速 国内Github下载很慢，用上了这个插件后，下载速度嗖嗖嗖的 谷歌访问助手 见名知意、有了它，谷歌可以访问了，虽然依旧龟速 沙拉查词-聚合词典划词翻译 多语言混合网页阅读利器 ","date":"2020-11-18","objectID":"/posts/docs/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/:1:2","tags":["工具"],"title":"实用工具","uri":"/posts/docs/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"categories":["文档"],"content":"Redis客户端工具 Another Redis Desktop Manager 开源软件，用着还可以 Redis Desktop Manager 官方工具，新版部分功能收费 未完待续… ","date":"2020-11-18","objectID":"/posts/docs/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/:1:3","tags":["工具"],"title":"实用工具","uri":"/posts/docs/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"},{"categories":["文档"],"content":"与开发有关的常用在线工具。如：json解析、程序员在线工具箱等","date":"2020-11-18","objectID":"/posts/docs/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/","tags":["工具"],"title":"在线工具","uri":"/posts/docs/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["文档"],"content":"Markdown在线编辑器 JSON解析 程序员在线工具箱 程序员在线工具箱2 未完待续… ","date":"2020-11-18","objectID":"/posts/docs/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:0:0","tags":["工具"],"title":"在线工具","uri":"/posts/docs/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["文档"],"content":"常见官方网址导航","date":"2020-11-18","objectID":"/posts/docs/%E5%B8%B8%E8%A7%81%E5%AE%98%E7%BD%91/","tags":["官网"],"title":"常见官网","uri":"/posts/docs/%E5%B8%B8%E8%A7%81%E5%AE%98%E7%BD%91/"},{"categories":["文档"],"content":"技术相关 Markdown中文网 清华大学开源软件镜像站 w3cschool github HBuilder Data Structure Visualizations visualgo OSCHINA-中国开源技术交流社区 阿里云云效Maven Maven中央仓库 SpringBoot官方文档 Nacos官网 菜鸟教程 jekyll主题 jekyll中文文档 jekyll英文文档 Hugo官网 Hugo英文文档 Hugo中文文档 图标网 阿里巴巴矢量图标库 Markdown 中文网 LeanCloud valine文档 ","date":"2020-11-18","objectID":"/posts/docs/%E5%B8%B8%E8%A7%81%E5%AE%98%E7%BD%91/:1:0","tags":["官网"],"title":"常见官网","uri":"/posts/docs/%E5%B8%B8%E8%A7%81%E5%AE%98%E7%BD%91/"},{"categories":["文档"],"content":"其他 keepass ","date":"2020-11-18","objectID":"/posts/docs/%E5%B8%B8%E8%A7%81%E5%AE%98%E7%BD%91/:2:0","tags":["官网"],"title":"常见官网","uri":"/posts/docs/%E5%B8%B8%E8%A7%81%E5%AE%98%E7%BD%91/"},{"categories":null,"content":"关于我 一个平凡的编码者。 极简主义。 喜欢玩游戏 （曾经 🎮 LOL S5 网一钻二、16年后基本不玩了）。 热爱技术，喜欢瞎倒腾。生命不息、折腾不止😄 （例如这个博客）。 现居于上海。 ","date":"2020-11-16","objectID":"/about/:0:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于博客 始建于2020年11月14日，尝试过jekyll。 目前使用hugo 、 阿里云OSS 、 阿里云ECS 自动部署使用GitHub-WebHooks + 自写脚本 ","date":"2020-11-16","objectID":"/about/:0:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"我的域名 wlz922.top : 注册于2017年11月20日 wlizhi.cc : 注册于2020年11月16日 ","date":"2020-11-16","objectID":"/about/:0:3","tags":null,"title":"关于","uri":"/about/"},{"categories":["日志"],"content":"logback常见配置","date":"2019-11-16","objectID":"/posts/technology-other/logback%E9%85%8D%E7%BD%AE/","tags":["日志配置","logback"],"title":"logback配置","uri":"/posts/technology-other/logback%E9%85%8D%E7%BD%AE/"},{"categories":["日志"],"content":"logback配置 此配置将不同几倍的日志归置到不同的文件中。 项目中使用，将对应的property属性值更改即可。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- 日志级别从低到高分为TRACE \u003c DEBUG \u003c INFO \u003c WARN \u003c ERROR \u003c FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\u003e \u003c!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --\u003e \u003c!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\u003e \u003c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\u003e \u003cconfiguration scan=\"true\" scanPeriod=\"10 seconds\"\u003e \u003ccontextName\u003elogback\u003c/contextName\u003e \u003c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --\u003e \u003cproperty name=\"log.path\" value=\"logs\"/\u003e \u003cproperty name=\"project.name\" value=\"project-name\"/\u003e \u003c!--0. 日志格式和颜色渲染 --\u003e \u003c!-- 彩色日志依赖的渲染类 --\u003e \u003cconversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\"/\u003e \u003cconversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\"/\u003e \u003cconversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\"/\u003e \u003c!-- 彩色日志格式 --\u003e \u003cproperty name=\"CONSOLE_LOG_PATTERN\" value=\"${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(%L:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\"/\u003e \u003c!--1. 输出到控制台--\u003e \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003c/filter\u003e \u003cencoder\u003e \u003cPattern\u003e${CONSOLE_LOG_PATTERN}\u003c/Pattern\u003e \u003c!-- 设置字符集 --\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!--2. 输出到文档--\u003e \u003c!-- 2.1 level为 DEBUG 日志，时间滚动输出 --\u003e \u003cappender name=\"DEBUG_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-debug.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c!-- 设置字符集 --\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 日志归档 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-debug-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录debug级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.2 level为 INFO 日志，时间滚动输出 --\u003e \u003cappender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-info.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 每天日志归档路径以及格式 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录info级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003einfo\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.3 level为 WARN 日志，时间滚动输出 --\u003e \u003cappender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-warn.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%","date":"2019-11-16","objectID":"/posts/technology-other/logback%E9%85%8D%E7%BD%AE/:0:0","tags":["日志配置","logback"],"title":"logback配置","uri":"/posts/technology-other/logback%E9%85%8D%E7%BD%AE/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring-aop%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:0:0","tags":["源码","spring源码"],"title":"Spring AOP实现原理","uri":"/posts/spring/spring-aop%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["spring"],"content":"spring容器启动时初始化流程剖析","date":"2019-11-16","objectID":"/posts/spring/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/","tags":["源码","spring源码"],"title":"Spring IOC容器初始化流程","uri":"/posts/spring/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["spring"],"content":"1.常见的ApplicationContext实现类： 容器：AbstractApplicationContext 抽象父类，核心(模板)方法 refresh()。 ClassPathXmlApplicationContext XML方式启动。 AnnotationConfigWebApplicationContext 注解方式启动，对局部代码进行测试时比较好用。 AnnotationConfigServletWebServerApplicationContext SpringBoot启动默认使用的上下文类。 ","date":"2019-11-16","objectID":"/posts/spring/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:1:0","tags":["源码","spring源码"],"title":"Spring IOC容器初始化流程","uri":"/posts/spring/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["spring"],"content":"2. 核心方法refresh() 。 public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext { @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. // 不太重要，预刷新，做一些准备工作。记录了启动时间戳，标记为活动，非关闭状态。 prepareRefresh(); /** * TODO 重点：解析xml配置文件，创建beanFactory，包装BeanDefinition */ // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 注册一些对事件、监听器等的支持 prepareBeanFactory(beanFactory); try { // 钩子方法，BeanFactory创建后，对BeanFactory的自定义操作。 // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // TODO 重点：这里调用了postProcessBeanDefinitionRegistry(registry);springboot中很多激活自动配置的注解都是通过这里导入的。 // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // TODO 重点：从beanFactory中获取所有的BeanPostProcessor，优先进行getBean操作，实例化 // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // 国际化支持 // Initialize message source for this context. initMessageSource(); // 初始化ApplicationEventMulticaster。 如果上下文中未定义，则使用SimpleApplicationEventMulticaster。 // Initialize event multicaster for this context. initApplicationEventMulticaster(); // 钩子方法，springBoot中的嵌入式tomcat就是通过此方法实现的 // Initialize other special beans in specific context subclasses. onRefresh(); // 监听器注册 // Check for listener beans and register them. registerListeners(); // TODO 重点方法：完成容器中bean的实例化，及代理的生成等操作。 // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // 完成此上下文的刷新，调用LifecycleProcessor的onRefresh（）方法并发布 // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } } ","date":"2019-11-16","objectID":"/posts/spring/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:2:0","tags":["源码","spring源码"],"title":"Spring IOC容器初始化流程","uri":"/posts/spring/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring-xml%E8%A7%A3%E6%9E%90%E5%8F%8Abeandefinition%E5%B0%81%E8%A3%85/:0:0","tags":["源码","spring源码"],"title":"Spring XML解析及Beandefinition封装","uri":"/posts/spring/spring-xml%E8%A7%A3%E6%9E%90%E5%8F%8Abeandefinition%E5%B0%81%E8%A3%85/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/springioc-getbean%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/:0:0","tags":["源码","spring源码"],"title":"SpringIOC-getBean核心流程","uri":"/posts/spring/springioc-getbean%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/springmvc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:0:0","tags":["源码","spring源码"],"title":"SpringMVC实现原理","uri":"/posts/spring/springmvc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:0","tags":["源码","spring源码"],"title":"Spring事务实现原理\u0026事务执行流程","uri":"/posts/spring/spring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-applicationlistener/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-ApplicationListener","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-applicationlistener/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-beandefinitionregistrypostprocessor/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-BeanDefinitionRegistryPostProcessor","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-beandefinitionregistrypostprocessor/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-beanpostprocessor/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-BeanPostProcessor","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-beanpostprocessor/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-factorybean/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-FactoryBean","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-factorybean/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-scope/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-Scope","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-scope/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-%E5%85%B6%E4%BB%96%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-其他钩子方法、策略接口","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-%E5%85%B6%E4%BB%96%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:0:0","tags":["源码","spring源码"],"title":"Spring注解实现原理","uri":"/posts/spring/spring%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"}]