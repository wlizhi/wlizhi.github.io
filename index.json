[{"categories":["spring"],"content":"注解@EnableWebMvc的实现原理，这个注解中主流程源码分析。","date":"2020-12-15","objectID":"/posts/spring/23-enable-web-mvc-principle/","tags":["spring源码"],"title":"23 @EnableWebMvc 的作用及源码分析","uri":"/posts/spring/23-enable-web-mvc-principle/"},{"categories":["spring"],"content":"@EnableWebMvc的声明 @EnableWebMvc 的声明源码如下： @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented // 这里支持了激活mvc各种组件功能，其中父类中有很多@Bean注解的方法，创建了许多可能需要的组件， // 比如RequestMappingHandlerMapping就是在这时候生成的URL-对象方法的映射， // RequestMappingHandlerMapping实现了InitializingBean，afterPropertiesSet方法中初始化了映射关系 @Import(DelegatingWebMvcConfiguration.class) public @interface EnableWebMvc { } 在 @EnableWebMvc 声明处，使用 @Import 注解导入了一个类，这个类是 DelegatingWebMvcConfiguration，这是一个配置类，使用了注解 @Configuration 标注。 ","date":"2020-12-15","objectID":"/posts/spring/23-enable-web-mvc-principle/:1:0","tags":["spring源码"],"title":"23 @EnableWebMvc 的作用及源码分析","uri":"/posts/spring/23-enable-web-mvc-principle/"},{"categories":["spring"],"content":"DelegatingWebMvcConfiguration 中的配置聚合 在 DelegatingWebMvcConfiguration 中，聚合了项目中所有的 WebMvcConfigurer 实现类实例。在这个类中，有很多 @Bean 注解标注的方法，来完成一些 mvc 组件的注册。 而对这些组件的注册的一些配置，会通过调用 DelegatingWebMvcConfiguration 的一些回调方法来完成，这些回调方法中，遍历了搜集到的 WebMvcConfigurer，将对应的方法进行依次调用。 在 DelegatingWebMvcConfiguration 中，聚合 WebMvcConfigurer 实例的源码如下。 @Configuration public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { // 这个类合成了容器中所有实例化的 WebMvcConfigurer private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); /** 将容器中所有实例化的 WebMvcConfigurer 根据类型注入到方法参数，将其封装起来，之后所有的配置方法中， * 会遍历这里搜集到的所有的实例，依次进行配置。 */ @Autowired(required = false) public void setConfigurers(List\u003cWebMvcConfigurer\u003e configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } } } 在 DelegatingWebMvcConfiguration 中，声明了一个成员变量 configurers，这个类是 WebMvcConfigurerComposite，同时它也是一个 WebMvcConfigurer 的实现。 在 setConfigurers() 中，注入了子容器中所有的 WebMvcConfigurer 实例，并将其封装到 configurers 中。 class WebMvcConfigurerComposite implements WebMvcConfigurer { private final List\u003cWebMvcConfigurer\u003e delegates = new ArrayList\u003c\u003e(); public void addWebMvcConfigurers(List\u003cWebMvcConfigurer\u003e configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.delegates.addAll(configurers); } } @Override public void configureViewResolvers(ViewResolverRegistry registry) { for (WebMvcConfigurer delegate : this.delegates) { delegate.configureViewResolvers(registry); } } // 省略一系列方法实现... } 通过 addWebMvcConfigurers() 方法，将所有的实现类，封装到成员 delegates 中。 WebMvcConfigurerComposite 本身并不提供任何组件的配置，而是通过搜集容器中注入的 WebMvcConfigurer 实例，调用各个配置方法时，通过遍历这些实例，依次调用其同名方法来进行配置。 比如 configureViewResolvers()，它会遍历所有封装的实例，依次调用这些实例的 configureViewResolvers()，来进行组件的配置。 ","date":"2020-12-15","objectID":"/posts/spring/23-enable-web-mvc-principle/:2:0","tags":["spring源码"],"title":"23 @EnableWebMvc 的作用及源码分析","uri":"/posts/spring/23-enable-web-mvc-principle/"},{"categories":["spring"],"content":"DelegatingWebMvcConfiguration 中的组件注册 在 DelegatingWebMvcConfiguration 继承了 WebMvcConfigurationSupport，在这个类中，通过 @Bean的方式，完成了很多 mvc 相关组件的注册。 ","date":"2020-12-15","objectID":"/posts/spring/23-enable-web-mvc-principle/:3:0","tags":["spring源码"],"title":"23 @EnableWebMvc 的作用及源码分析","uri":"/posts/spring/23-enable-web-mvc-principle/"},{"categories":["spring"],"content":"主要成员 DelegatingWebMvcConfiguration 的主要成员变量如下： public class WebMvcConfigurationSupport implements ApplicationContextAware, ServletContextAware { /** spring容器的上下文对象 */ @Nullable private ApplicationContext applicationContext; /** servlet 上下文对象 */ @Nullable private ServletContext servletContext; /** springmvc 拦截器封装 */ @Nullable private List\u003cObject\u003e interceptors; /** 帮助配置HandlerMappings路径匹配类的封装 */ @Nullable private PathMatchConfigurer pathMatchConfigurer; /** 内容协商机制 */ @Nullable private ContentNegotiationManager contentNegotiationManager; /** 方法的参数处理 */ @Nullable private List\u003cHandlerMethodArgumentResolver\u003e argumentResolvers; /** 方法的返回值处理 */ @Nullable private List\u003cHandlerMethodReturnValueHandler\u003e returnValueHandlers; /** 消息转换器 */ @Nullable private List\u003cHttpMessageConverter\u003c?\u003e\u003e messageConverters; /** cors 跨域相关 */ @Nullable private Map\u003cString, CorsConfiguration\u003e corsConfigurations; } 这里面封装了上下文对象、拦截器、方法参数处理、返回值处理、消息转换器等实例。 ","date":"2020-12-15","objectID":"/posts/spring/23-enable-web-mvc-principle/:3:1","tags":["spring源码"],"title":"23 @EnableWebMvc 的作用及源码分析","uri":"/posts/spring/23-enable-web-mvc-principle/"},{"categories":["spring"],"content":"注册 RequestMappingHandlerMapping 通过 @Bean，注册了 RequestMappingHandlerMapping ： public class WebMvcConfigurationSupport implements ApplicationContextAware, ServletContextAware { @Bean public RequestMappingHandlerMapping requestMappingHandlerMapping() { // RequestMappingHandlerMapping 实现了 InitializingBean，所以它在实例化后，会调用 afterPropertiesSet() 进行初始化。 // 创建 RequestMappingHandlerMapping。 RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping(); mapping.setOrder(0); // getInterceptors()中调用了钩子方法，可通过 WebMvcConfigurer进行扩展 mapping.setInterceptors(getInterceptors()); mapping.setContentNegotiationManager(mvcContentNegotiationManager()); // getCorsConfigurations() 调用了钩子犯法 mapping.setCorsConfigurations(getCorsConfigurations()); PathMatchConfigurer configurer = getPathMatchConfigurer(); Boolean useSuffixPatternMatch = configurer.isUseSuffixPatternMatch(); if (useSuffixPatternMatch != null) { mapping.setUseSuffixPatternMatch(useSuffixPatternMatch); } Boolean useRegisteredSuffixPatternMatch = configurer.isUseRegisteredSuffixPatternMatch(); if (useRegisteredSuffixPatternMatch != null) { mapping.setUseRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch); } Boolean useTrailingSlashMatch = configurer.isUseTrailingSlashMatch(); if (useTrailingSlashMatch != null) { mapping.setUseTrailingSlashMatch(useTrailingSlashMatch); } UrlPathHelper pathHelper = configurer.getUrlPathHelper(); if (pathHelper != null) { mapping.setUrlPathHelper(pathHelper); } PathMatcher pathMatcher = configurer.getPathMatcher(); if (pathMatcher != null) { mapping.setPathMatcher(pathMatcher); } Map\u003cString, Predicate\u003cClass\u003c?\u003e\u003e\u003e pathPrefixes = configurer.getPathPrefixes(); if (pathPrefixes != null) { mapping.setPathPrefixes(pathPrefixes); } return mapping; } } 在创建 RequestMappingHandlerMapping 的过程中，调用了 getInterceptors()、getCorsConfigurations() 等的回调方法。 getInterceptors() 源码： public class WebMvcConfigurationSupport implements ApplicationContextAware, ServletContextAware { protected final Object[] getInterceptors() { if (this.interceptors == null) { InterceptorRegistry registry = new InterceptorRegistry(); // 钩子方法，如果我们定义了一个WebMvcConfigurer，它就会回调到对应实现的方法中。 // 遍历所有注册到容器中的WebMvcConfigurer，依次进行添加操作 addInterceptors(registry); registry.addInterceptor(new ConversionServiceExposingInterceptor(mvcConversionService())); registry.addInterceptor(new ResourceUrlProviderExposingInterceptor(mvcResourceUrlProvider())); this.interceptors = registry.getInterceptors(); } return this.interceptors.toArray(); } } 这里调用了 addInterceptors(): public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { // 这个类合成了容器中所有实例化的 WebMvcConfigurer private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); @Override protected void addInterceptors(InterceptorRegistry registry) { // 遍历，依次进行添加操作。 this.configurers.addInterceptors(registry); } } 可以看到，在 addInterceptors() 中，就遍历了 DelegatingWebMvcConfiguration 中封装的所有的 WebMvcConfigurer 实例的 addInterceptors()。依次调用对 RequestMappingHandlerMapping 实例进行相关配置。 getCorsConfigurations() 源码： public class WebMvcConfigurationSupport implements ApplicationContextAware, ServletContextAware { protected final Map\u003cString, CorsConfiguration\u003e getCorsConfigurations() { if (this.corsConfigurations == null) { CorsRegistry registry = new CorsRegistry(); addCorsMappings(registry);// 这里遍历了DelegatingWebMvcConfiguration中封装的 WebMvcConfigurer，依次将对应方法调用 this.corsConfigurations = registry.getCorsConfigurations(); } return this.corsConfigurations; } } 同样的，这里调用了 addCorsMappings()，进入源码： public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { // 这个类合成了容器中所有实例化的 WebMvcConfigurer private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); @Override protected void addCorsMappings(CorsRegistry registry) { this.configurers.addCorsMappings(registry); } } 同样遍历了 WebMvcConfigurer 实例，依次调用同名的配置方法。 ","date":"2020-12-15","objectID":"/posts/spring/23-enable-web-mvc-principle/:3:2","tags":["spring源码"],"title":"23 @EnableWebMvc 的作用及源码分析","uri":"/posts/spring/23-enable-web-mvc-principle/"},{"categories":["spring"],"content":"注册 RequestMappingHandlerAdapter 源码如下： public class WebMvcConfigurationSupport implements ApplicationContextAware, ServletContextAware { @Bean public RequestMappingHandlerAdapter requestMappingHandlerAdapter() { // 创建 RequestMappingHandlerAdapter RequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter(); // 这里设置的每一个参数，都触发了相应的回调，如果实现了对应方法，就会将配置注册到这个组件中，否则就注册默认的配置。 adapter.setContentNegotiationManager(mvcContentNegotiationManager()); adapter.setMessageConverters(getMessageConverters()); adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer()); adapter.setCustomArgumentResolvers(getArgumentResolvers()); adapter.setCustomReturnValueHandlers(getReturnValueHandlers()); if (jackson2Present) { adapter.setRequestBodyAdvice(Collections.singletonList(new JsonViewRequestBodyAdvice())); adapter.setResponseBodyAdvice(Collections.singletonList(new JsonViewResponseBodyAdvice())); } AsyncSupportConfigurer configurer = new AsyncSupportConfigurer(); configureAsyncSupport(configurer); if (configurer.getTaskExecutor() != null) { adapter.setTaskExecutor(configurer.getTaskExecutor()); } if (configurer.getTimeout() != null) { adapter.setAsyncRequestTimeout(configurer.getTimeout()); } // 触发了对应的回调 adapter.setCallableInterceptors(configurer.getCallableInterceptors()); adapter.setDeferredResultInterceptors(configurer.getDeferredResultInterceptors()); return adapter; } } 创建 RequestMappingHandlerAdapter，并对其进行一些设置，这些设置大多都是通过遍历并依次回调前面封装的 WebMvcConfigurer 对应方法进行的。 RequestMappingHandlerMapping 和 RequestMappingHandlerAdapter 都实现了接口 InitializingBean，那么在他们通过 @Bean 将自身实例注入到容器中时，也会调用 afterPropertiesSet() 做一些事情，具体做了什么，在后面文章中列举。 ","date":"2020-12-15","objectID":"/posts/spring/23-enable-web-mvc-principle/:3:3","tags":["spring源码"],"title":"23 @EnableWebMvc 的作用及源码分析","uri":"/posts/spring/23-enable-web-mvc-principle/"},{"categories":["spring"],"content":"异常处理器 HandlerExceptionResolver 源码如下： public class WebMvcConfigurationSupport implements ApplicationContextAware, ServletContextAware { @Bean public HandlerExceptionResolver handlerExceptionResolver() { // 全局异常处理器的创建注册 List\u003cHandlerExceptionResolver\u003e exceptionResolvers = new ArrayList\u003c\u003e(); // 钩子方法，遍历依次回调封装的 WebMvcConfigurer configureHandlerExceptionResolvers(exceptionResolvers); if (exceptionResolvers.isEmpty()) { // 如果没有定义，则添加默认的异常处理器 addDefaultHandlerExceptionResolvers(exceptionResolvers); } extendHandlerExceptionResolvers(exceptionResolvers); HandlerExceptionResolverComposite composite = new HandlerExceptionResolverComposite(); composite.setOrder(0); composite.setExceptionResolvers(exceptionResolvers); return composite; } } 这里通过 @Bean 向容器中注入了异常处理器 HandlerExceptionResolver，如果在 WebMvcConfigurer 实现类中，配置了异常处理类，就会加载。否则就会使用默认的异常处理类 ExceptionHandlerExceptionResolver。 在 ExceptionHandlerExceptionResolver 中定义了@ControllerAdvice的支持，在 getExceptionHandlerMethod() 中，通过创建 ExceptionHandlerMethodResolver 对 @HandlerException 进行了支持。 ","date":"2020-12-15","objectID":"/posts/spring/23-enable-web-mvc-principle/:3:4","tags":["spring源码"],"title":"23 @EnableWebMvc 的作用及源码分析","uri":"/posts/spring/23-enable-web-mvc-principle/"},{"categories":["spring"],"content":"其他 在 WebMvcConfigurationSupport 中，还有很多其他的组件注册。不再列举。 ","date":"2020-12-15","objectID":"/posts/spring/23-enable-web-mvc-principle/:3:5","tags":["spring源码"],"title":"23 @EnableWebMvc 的作用及源码分析","uri":"/posts/spring/23-enable-web-mvc-principle/"},{"categories":["spring"],"content":"MVC的支持、执行入口及嵌入式 Tomcat 的使用案例。","date":"2020-12-15","objectID":"/posts/spring/22-enable-web-mvc-main-embedded-tomcat/","tags":["spring源码"],"title":"22 MVC的支持入口及嵌入式Tomcat的使用","uri":"/posts/spring/22-enable-web-mvc-main-embedded-tomcat/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-12-15","objectID":"/posts/spring/22-enable-web-mvc-main-embedded-tomcat/:0:0","tags":["spring源码"],"title":"22 MVC的支持入口及嵌入式Tomcat的使用","uri":"/posts/spring/22-enable-web-mvc-main-embedded-tomcat/"},{"categories":["spring"],"content":"1 入口 根据文章 web容器启动时ServletContainerInitializer的加载 中所述，创建一个 WebApplicationInitializer 的实现类，如下： public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { /** 根容器 父容器 */ @Override protected Class\u003c?\u003e[] getRootConfigClasses() { logger.info(\"===========spring根容器加载成功============\"); return new Class[]{RootConfig.class}; } /** web容器 子容器 */ @Override protected Class\u003c?\u003e[] getServletConfigClasses() { logger.info(\"===========springweb子容器加载成功============\"); return new Class[]{WebConfig.class}; } /** 获取前端控制器映射信息 dispatcherServlet */ @Override protected String[] getServletMappings() { return new String[]{\"/\"}; } } 上面代码中，共重写了三个方法，分别是spring父容器的配置类、mvc子容器的配置类、DispatcherServlet 的拦截路径的设置。 在 mvc 子容器中，使用注解 @EnableWebMvc 来激活mvc功能。 mvc 子容器配置类代码如下： @EnableWebMvc @ComponentScan(value = {\"top.wlz922.controller\", \"top.wlz922.interceptor\", \"top.wlz922.resolver\"} // , includeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})} // , useDefaultFilters = true ) @EnableAspectJAutoProxy public class WebConfig implements WebMvcConfigurer { private static final Logger logger = LoggerFactory.getLogger(WebConfig.class); @Autowired(required = false) private List\u003cHandlerInterceptor\u003e interceptors; /** * 配置springmvc视图 */ @Override public void configureViewResolvers(ViewResolverRegistry registry) { logger.info(\"============jsp解析器开始加载===============\"); // registry.jsp(); registry.jsp(\"/WEB-INF/views/\", \".jsp\"); logger.info(\"============jsp解析器开始成功，开始渲染把===============\"); } @Override public void configureMessageConverters(List\u003cHttpMessageConverter\u003c?\u003e\u003e converters) { ArrayList\u003cMediaType\u003e list = new ArrayList\u003c\u003e(); list.add(MediaType.APPLICATION_JSON); list.add(MediaType.TEXT_PLAIN); FastJsonHttpMessageConverter c = new FastJsonHttpMessageConverter(); c.setSupportedMediaTypes(list); converters.add(c); } @Override public void addInterceptors(InterceptorRegistry registry) { if (interceptors != null) { for (HandlerInterceptor interceptor : interceptors) { InterceptorRegistration registration = registry.addInterceptor(interceptor); if (interceptor instanceof HaldlerInterceptorPathPattern) { String[] pathPatterns = ((HaldlerInterceptorPathPattern) interceptor).getPathPatterns(); registration.addPathPatterns(pathPatterns); } } } } } 根据 Servlet3.0 规范，tomcat 容器在启动时，会根据 SPI 机制加载配置的 ServletContainerInitializer 实现类。springmvc中使用的 SpringServletContainerInitializer，在这个类声明中，引入了 WebApplicationInitializer。 在 WebApplicationInitializer 的 onStartup() 中，会在创建 DispatcherServlet 时，创建一个 WebApplicationContext，将其设置到 DispatcherServlet 的成员变量中。 而在创建这个 WebApplicationContext 时，会调用 WebApplicationInitializer 实现类的回调方法 getServletConfigClasses()，获取到 mvc 子容器的配置类。 接着，在 mvc 子容器核心方法 refresh() 调用的时候，就会扫描加载这个配置类中的信息。 大致流程是： SPI机制加载 ServletContainerInitializer 实现类。 执行 HandlerTypes 中声明的 WebApplicationInitializer 实现类。 调用 WebApplicationInitializer.onStartup()。 创建父容器 ApplicationContext，调用钩子方法 getRootConfigClasses()，将其设置为父容器 refresh() 的配置类，并将父容器缓存到 ServletContext 中。 创建 DispatcherServlet，并创建 WebApplicationContext 子容器，在创建时，调用钩子方法 getServletConfigClasses() 作为子容器 refresh() 的配置类，将子容器设置到 DispatcherServlet 成员变量中。 在父容器、子容器 refresh() 执行的时候，就会加载扫描各自配置类中的注解。 @EnableWebMvc 注解是对 mvc功能的支持，内部通过 @Bean 向 ioc 容器中注入了许多功能支持的类实例。这里是 mvc 功能支持的入口。 ","date":"2020-12-15","objectID":"/posts/spring/22-enable-web-mvc-main-embedded-tomcat/:1:0","tags":["spring源码"],"title":"22 MVC的支持入口及嵌入式Tomcat的使用","uri":"/posts/spring/22-enable-web-mvc-main-embedded-tomcat/"},{"categories":["spring"],"content":"2 嵌入式 Tomcat 首先，引入依赖包： \u003c!-- 嵌入式tomcat依赖 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.tomcat.embed\u003c/groupId\u003e \u003cartifactId\u003etomcat-embed-core\u003c/artifactId\u003e \u003cversion\u003e${tomcat.embed.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.tomcat.embed\u003c/groupId\u003e \u003cartifactId\u003etomcat-embed-jasper\u003c/artifactId\u003e \u003cversion\u003e${tomcat.embed.version}\u003c/version\u003e \u003c!--\u003cscope\u003eprovided\u003c/scope\u003e--\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.tomcat.embed\u003c/groupId\u003e \u003cartifactId\u003etomcat-embed-logging-juli\u003c/artifactId\u003e \u003cversion\u003e${tomcat.embed.version}\u003c/version\u003e \u003c/dependency\u003e 编写启动类： public class SpringSourceMvcAnoApplication { private static final int PORT = 8080; private static final String CONTEXT_PATH = \"\"; private static final Logger LOG = LoggerFactory.getLogger(SpringSourceMvcAnoApplication.class); public static void main(String[] args) throws Exception { SpringSourceMvcAnoApplication starter = new SpringSourceMvcAnoApplication(); starter.start(); } public void start() throws Exception { LOG.info(\"=================开始加载内嵌tomcat=====================\"); String userDir = System.getProperty(\"user.dir\"); // 这种方式设置System.setProperty(\"tomcat.util.scan.StandardJarScanFilter.jarsToSkip\", \"\\\\,*\"); // 可以加快启动速度，但是由于读取的字节码文件是maven编译的（maven编译使用的本地仓库的jar包），会导致gradle项目中的代码断点无效。 // 这里设置为直接读取src/main/webapp下的文件，自动扫描baseDir下的java代码。（启动慢，可在gradle项目代码中打断点调试。） // String webappDir = userDir + File.separator + \"/target/spring-source-mvc-ano-1.0-SNAPSHOT\"; String webappDir = userDir + File.separator + \"/src/main/webapp\"; Tomcat tomcat = new Tomcat(); tomcat.setBaseDir(userDir); tomcat.setPort(PORT); tomcat.addWebapp(CONTEXT_PATH, webappDir); tomcat.enableNaming(); LOG.info(\"BaseDir:{}\", userDir); LOG.info(\"port:{}\", PORT); LOG.info(\"context_path:{}\", webappDir); // System.setProperty(\"tomcat.util.scan.StandardJarScanFilter.jarsToSkip\", \"\\\\,*\"); tomcat.start(); LOG.info(\"==================tomcat加载成功==========================\"); LOG.info(\"测试地址：http://localhost:8080/index\"); tomcat.getServer().await(); } } 通过运行 main() 方法来启动一个嵌入式 tomcat，它会根据 上面 的步骤，加载对应的实现类。 ","date":"2020-12-15","objectID":"/posts/spring/22-enable-web-mvc-main-embedded-tomcat/:2:0","tags":["spring源码"],"title":"22 MVC的支持入口及嵌入式Tomcat的使用","uri":"/posts/spring/22-enable-web-mvc-main-embedded-tomcat/"},{"categories":["spring"],"content":"昨天给spring提了一个issue，这个问题在 声明式事务注意事项 中有描述过。 关于spring声明式事务传播行为 REQUIRES_NEW，如果不做额外处理，可能会导致所有数据库连接被占用的问题。一直搞不明白，这里隐藏着很大的问题，为什么要有这个传播行为。于是就将问题提交给了spring官方。 issue链接传送门 当多个线程争用资源时，每个线程必须在结束任务之前抢占多个资源，这可能是一个隐患。因为此方法可能导致多个线程仅抢夺它们需要的部分资源，它们无法获得所需要的所有资源而释放所获得的东西。但是，到这个时候，资源已经用尽了。 spring声明式事务中的传播行为 REQUIRES_NEW 正是以上情况的表现。 最初提交的issue，我仅仅发了一段伪代码。内容如下： A method that opens a transaction calls another method that starts a new transaction，if all connections are exhausted before the last new transaction method is executed,then all threads in the process will block，this process will fail. Pseudo code： @Transactional methodA(){ // All the threads that started the transaction were executed here, but the connection was exhausted. // The latter method execution will get a new connection,but it will never get it. @Transactional(propagation=Propagation.REQUIRES_NEW) methodB(){ } } 刚开始对方并没有认真的查看，仅回复What's the problem?。之后数次的回复貌似不在一个频道。也许是因为沟通时礼貌的原因、又或者是我问题描述的不够清楚。经过几次沟通后，差点把对方惹毛了，对方回复道：这里不是论坛，如果您认为是错误，请粘贴测试用例，如果您认为是改进，请提交PR，讨论到此为止。 以下是原文： It's not forum here, if you think it's a bug please paste test case, if you think it's an improvement please submit PR, end of discussion. 看到对方不耐烦了，考虑到自己说话方式的问题，一番思虑后，决定再回复一下。回复内容尽可能将这个潜在问题描述清楚。 回复如下： Sorry, I didn't make it clear. This is the test code, where it blocks the real process. Methodb() will never execute. 百度翻译：抱歉，是我没有表达清楚。这是测试代码，它阻塞了整个进程。 methodB() 将永远不会执行。 示例代码： @slf4j @service public class PropagationExampleServiceImpl implements PropagationExampleService { @Autowired PropagationExampleService service; @Transactional @Override public void methodA() throws InterruptedException { Thread.sleep(100); log.info(\"methodA\"); service.methodB(); } @Transactional(propagation = Propagation.REQUIRES_NEW) @Override public void methodB() throws InterruptedException { log.info(\"methodB\"); Thread.sleep(100); } } @SpringBootTest public class PropagationExampleServiceTest { @Autowired PropagationExampleService service; ExecutorService executor = new ThreadPoolExecutor(10, 10, 60, TimeUnit.SECONDS, new ArrayBlockingQueue\u003c\u003e(1000)); @Test public void methodATest() { for (int i = 0; i \u003c 20; i++) { executor.execute(() -\u003e { try { service.methodA(); } catch (InterruptedException e) { e.printStackTrace(); } }); } LockSupport.park(); } } 连接池配置及日志： spring: datasource: name: druidDataSource type: com.alibaba.druid.pool.DruidDataSource druid: max-active: 10 Here is the log: 2020-12-11 10:15:56.385 INFO 10864 --- [pool-1-thread-1] c.j.s.s.i.PropagationExampleServiceImpl : methodA 2020-12-11 10:15:56.385 INFO 10864 --- [pool-1-thread-2] c.j.s.s.i.PropagationExampleServiceImpl : methodA 2020-12-11 10:15:56.385 INFO 10864 --- [pool-1-thread-5] c.j.s.s.i.PropagationExampleServiceImpl : methodA 2020-12-11 10:15:56.385 INFO 10864 --- [pool-1-thread-6] c.j.s.s.i.PropagationExampleServiceImpl : methodA 2020-12-11 10:15:56.385 INFO 10864 --- [pool-1-thread-8] c.j.s.s.i.PropagationExampleServiceImpl : methodA 2020-12-11 10:15:56.385 INFO 10864 --- [pool-1-thread-9] c.j.s.s.i.PropagationExampleServiceImpl : methodA 2020-12-11 10:15:56.385 INFO 10864 --- [pool-1-thread-3] c.j.s.s.i.PropagationExampleServiceImpl : methodA 2020-12-11 10:15:56.385 INFO 10864 --- [ool-1-thread-10] c.j.s.s.i.PropagationExampleServiceImpl : methodA 2020-12-11 10:15:56.385 INFO 10864 --- [pool-1-thread-7] c.j.s.s.i.PropagationExampleServiceImpl : methodA 2020-12-11 10:15:56.385 INFO 10864 --- [pool-1-thread-4] c.j.s.s.i.PropagationExampleServiceImpl : methodA 好吧，对方以为是我使用过程遇到了问题，在像他求助，回复道： I think the result is expected, you should increase max-active \u003e concurrency, so If you change max-active to 21, it will pass, waiting for your confirmation. You should set a max-wait on dataSource, then getConnection will timeout instead of endless blocking. 百度翻译：我认为结果是预期的，您应该增加 max-active 并发性，因此，如果将max-active更改为21，它将通过，等待确认。您应该在dataSource上设置一个max-wait，然后getConnection将超时而不是无限阻塞。 以下是我的回复： I know, I just want to express that. In fact, the number of connections in the connection pool is gen","date":"2020-12-11","objectID":"/posts/spring/an-issue-for-spring/:0:0","tags":["spring源码","spring问题"],"title":"向spring提交了一个issue","uri":"/posts/spring/an-issue-for-spring/"},{"categories":["spring"],"content":"在web容器启动时为提供给第三方组件机会做一些初始化的工作，例如注册 servlet 或者 filter 等，servlet 规范中通过 ServletContainerInitializer 实现此功能。","date":"2020-12-10","objectID":"/posts/spring/21-load-servlet-container-initializer-on-startup/","tags":["spring源码"],"title":"21 web容器启动时ServletContainerInitializer的加载","uri":"/posts/spring/21-load-servlet-container-initializer-on-startup/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 在web容器启动时为提供给第三方组件机会做一些初始化的工作，例如注册 servlet 或者 filter 等，servlet 规范中通过 ServletContainerInitializer 实现此功能。 伴随着 ServletContainerInitializer 一起起作用的还有 @HandlesTypes 注解，通过这个注解会将指定的类注入到 ServletContainerInitializer 的 onStartup 方法参数中。 \rServletContainerInitializer 是通过 SPI 的方式扫描加载的，在对应 jar 包的 META-INF/services 下，会扫描 javax.servlet.ServletContainerInitializer 文件，加载文件中定义的实现类。 SpringMvc 就是利用这种方式，完成 DispatcherServlet 的初始化工作。 在 spring-web 包 META-INF/services 下就有 javax.servlet.ServletContainerInitializer 文件，文件中是这么定义的： org.springframework.web.SpringServletContainerInitializer SpringServletContainerInitializer 源码如下： @HandlesTypes(WebApplicationInitializer.class) public class SpringServletContainerInitializer implements ServletContainerInitializer { @Override public void onStartup(@Nullable Set\u003cClass\u003c?\u003e\u003e webAppInitializerClasses, ServletContext servletContext) throws ServletException { // 根据servlet规范，tomcat会在启动的时候，以SPI方式加载 services/javax.servlet.ServletContainerInitializer，并调用onStartup方法。 // 而spring-web包下就定义了此类。所以服务器启动时，会执行到这里。 // 这个列表封装了所有SPI加载的 WebApplicationInitializer 实例。 List\u003cWebApplicationInitializer\u003e initializers = new LinkedList\u003c\u003e(); if (webAppInitializerClasses != null) { for (Class\u003c?\u003e waiClass : webAppInitializerClasses) { // Be defensive: Some servlet containers provide us with invalid classes, // no matter what @HandlesTypes says... // 非接口、非抽象类，且是WebApplicationInitializer实现类的，将会反射创建对象。封装到上面定义的列表中。 if (!waiClass.isInterface() \u0026\u0026 !Modifier.isAbstract(waiClass.getModifiers()) \u0026\u0026 WebApplicationInitializer.class.isAssignableFrom(waiClass)) { try { initializers.add((WebApplicationInitializer) ReflectionUtils.accessibleConstructor(waiClass).newInstance()); } catch (Throwable ex) { throw new ServletException(\"Failed to instantiate WebApplicationInitializer class\", ex); } } } } // 排序，按照排序后的顺序，遍历、调用onStartup()。 servletContext.log(initializers.size() + \" Spring WebApplicationInitializers detected on classpath\"); AnnotationAwareOrderComparator.sort(initializers); for (WebApplicationInitializer initializer : initializers) { initializer.onStartup(servletContext); } } } SpringServletContainerInitializer 类声明处定义了 @HandlesTypes(WebApplicationInitializer.class)，web容器启动时，会调用 SpringServletContainerInitializer 的 onStartup()，并将项目中存在的所有 WebApplicationInitializer 实现类的 Class 对象，作为参数传递给 onStartup()。 遍历这个集合，将所有的实现类通过反射调用无参构造函数进行实例化。实例化后，得到一个实例列表，给这个列表中实例进行排序后，依次调用每个实例的 onStartup()。 我们可以实现 WebApplicationInitializer，或者继承它的子类，通过实现一些特定的方法，来达到在容器启动时，加载一些内容的目的。 首先看已经实现了一些方法的子类。以下是 AbstractDispatcherServletInitializer 中 onStartup() 源码： public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer { @Override public void onStartup(ServletContext servletContext) throws ServletException { // 创建 RootApplicationContext，也就是spring父容器。 // 后面的流程中，设置子容器的父容器时，就是通过servletContext作为桥梁，进行获取的。父容器实例化后，会注册到servletContext。 super.onStartup(servletContext); registerDispatcherServlet(servletContext); } } 主要调用了两个方法 super.onStartup() 和 registerDispatcherServlet()。 super.onStartup() 源码中调用了 registerContextLoaderListener()，源码如下： public abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer { protected void registerContextLoaderListener(ServletContext servletContext) { // 创建 RootApplicationContext，这里面会有一个回调 getRootConfigClasses。这个回调中获取了实现类方法中返回的配置类。 WebApplicationContext rootAppContext = createRootApplicationContext(); if (rootAppContext != null) { // 创建监听器，监听器中封装了ApplicationContext，将这个监听器封装到servletContext中 ContextLoaderListener listener = new ContextLoaderListener(rootAppContext); listener.setContextInitializers(getRootApplicationContextInitializers()); servletContext.addListener(listener); } } } 创建了一个 ApplicationContext，这是spring父容器，后面会创建一个子容器。将其放到一个 ServletContextListener 监听器中。 创建 ApplicationContext 源码： public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServl","date":"2020-12-10","objectID":"/posts/spring/21-load-servlet-container-initializer-on-startup/:0:0","tags":["spring源码"],"title":"21 web容器启动时ServletContainerInitializer的加载","uri":"/posts/spring/21-load-servlet-container-initializer-on-startup/"},{"categories":["spring"],"content":"事务提交前后是可以自定义一些逻辑，嵌入到事务提交的流程中的，通过spring-tx包提供的TransactionSynchronization类、使用TransactionSynchronizationManager的静态方法registerSynchronization() 或者使用注解方式均可。","date":"2020-12-07","objectID":"/posts/spring/20-transaction-extention-transaction-synchronization/","tags":["spring源码"],"title":"20 声明式事务扩展 TransactionSynchronization","uri":"/posts/spring/20-transaction-extention-transaction-synchronization/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-12-07","objectID":"/posts/spring/20-transaction-extention-transaction-synchronization/:0:0","tags":["spring源码"],"title":"20 声明式事务扩展 TransactionSynchronization","uri":"/posts/spring/20-transaction-extention-transaction-synchronization/"},{"categories":["spring"],"content":"1 编程式设置扩展操作 在spring声明式事务中，事务提交前、以及提交后都有相应的策略模式去调用一些扩展方法。在开发过程中，如果我们有这样的需求，在一个事务提交后做一些操作，就可以用到这个功能。 示例： @Slf4j @Service public class TransactionSourceExtentionServiceImpl implements TransactionSourceExtentionService { @Transactional @Override public int addUserRequiredWithTransactionSynchronization(PropagationUser user) { userDao.insertSelective(user); TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() { @Override public void afterCommit() { log.info(\"事务成功提交了\"); } }); return 1; } } 上面的示例代码，在新增用户后，做一些自定义的操作，比如用户注册通知等。 我们可以在方法结尾，使用 TransactionSynchronizationManager.registerSynchronization，去注入一个事件，通过重写相应的方法，可以在事务提交流程的不同节点插入自定义的操作。 如以上代码，是在事务提交后，做的一个自定义操作。它会将这个事件对象，存储到一个线程绑定的变量中。在事务提交完成后，去获取这个对象，然后调用afterCommit()。 看一下这个方法的源码： public abstract class TransactionSynchronizationManager { private static final ThreadLocal\u003cSet\u003cTransactionSynchronization\u003e\u003e synchronizations = new NamedThreadLocal\u003c\u003e(\"Transaction synchronizations\"); public static void registerSynchronization(TransactionSynchronization synchronization) throws IllegalStateException { // 注册事务事件，后面再各个节点会调用到事件中的回调方法 // 省略无关代码... synchronizations.get().add(synchronization); } } 在事务的通知方法中，执行完提交操作后，最终会调用到 invokeAfterCommit()，源码如下 ： public abstract class TransactionSynchronizationUtils { public static void invokeAfterCommit(@Nullable List\u003cTransactionSynchronization\u003e synchronizations) { if (synchronizations != null) { for (TransactionSynchronization synchronization : synchronizations) { synchronization.afterCommit(); } } } } 在我们注册的时候，像synchronizations中添加了我们自定义的事件，这个线程绑定的静态常量，是一个 Set 集合，也就是说，这个事件是可以注册多个的。 然后在事务提交后，遍历 synchronizations，并调用每一个事件的 afterCommit()； 从源码中可以看到，这个过程是一个同步操作，在事务提交后插入操作，只是不影响事务的提交以及连接的归还，对业务方法的返回，还是会有一些影响的，所以这里一般会改为异步操作，通过本地线程池或者发送到mq来进行异步处理。 ","date":"2020-12-07","objectID":"/posts/spring/20-transaction-extention-transaction-synchronization/:1:0","tags":["spring源码"],"title":"20 声明式事务扩展 TransactionSynchronization","uri":"/posts/spring/20-transaction-extention-transaction-synchronization/"},{"categories":["spring"],"content":"2 注解方式设置扩展操作 示例代码如下： @Slf4j @Service public class TransactionSourceExtentionServiceImpl implements TransactionSourceExtentionService { @Autowired PropagationUserDao userDao; @Autowired ApplicationEventPublisher eventPublisher; @Transactional @Override public int addUserRequiredWithApplicationEventPublisher2(PropagationUser user) { userDao.insertSelective(user); eventPublisher.publishEvent(new UserAddEvent(user)); return 1; } static class UserAddEvent extends ApplicationEvent { public UserAddEvent(PropagationUser user) { super(user); } } @Component static class UserEventListener { @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) public void processUserAddEvent(UserAddEvent user) { log.info(\"事务提交后用户信息处理，用户信息:{}\", user.getSource()); } } } 在实例中注入 ApplicationEventPublisher，通过调用这个实例的 publishEvent()，来发布事件。 在另一个方法中，使用 @TransactionalEventListener 注解到方法上来接收这个事件，将事件注入到方法参数中，然后在方法中定义业务处理。 实际上，它和TransactionSynchronizationManager.registerSynchronization() 本质上是一样的，因为这个注解方式，底层就是基于 registerSynchronization() 来实现的。 在 publishEvent() 源码中经历了以下调用链： publishEvent() -\u003e multicastEvent() -\u003e invokeListener() -\u003e doInvokeListener() -\u003e onApplicationEvent() onApplicationEvent() 是 ApplicationListenerMethodTransactionalAdapter 中的一个方法，源码如下： class ApplicationListenerMethodTransactionalAdapter extends ApplicationListenerMethodAdapter { @Override public void onApplicationEvent(ApplicationEvent event) { if (TransactionSynchronizationManager.isSynchronizationActive()) { TransactionSynchronization transactionSynchronization = createTransactionSynchronization(event); // 在这里注册了事件 TransactionSynchronizationManager.registerSynchronization(transactionSynchronization); } // 省略无关代码... } } 从源码中可以看到，它最终也是通过调用 registerSynchronization() 来进行事件的注入的。 匹配监听器的过程源码如下： public abstract class AbstractApplicationEventMulticaster implements ApplicationEventMulticaster, BeanClassLoaderAware, BeanFactoryAware { private Collection\u003cApplicationListener\u003c?\u003e\u003e retrieveApplicationListeners( ResolvableType eventType, @Nullable Class\u003c?\u003e sourceType, @Nullable ListenerRetriever retriever) { List\u003cApplicationListener\u003c?\u003e\u003e allListeners = new ArrayList\u003c\u003e(); Set\u003cApplicationListener\u003c?\u003e\u003e listeners; Set\u003cString\u003e listenerBeans; // 这里会获取到容器中所有已注册的监听器，进行匹配，匹配到之后。 synchronized (this.retrievalMutex) { listeners = new LinkedHashSet\u003c\u003e(this.defaultRetriever.applicationListeners); listenerBeans = new LinkedHashSet\u003c\u003e(this.defaultRetriever.applicationListenerBeans); } for (ApplicationListener\u003c?\u003e listener : listeners) { // 关键点在这里，supportsEvent() 中判断了是否支持这个事件 if (supportsEvent(listener, eventType, sourceType)) { if (retriever != null) { retriever.applicationListeners.add(listener); } allListeners.add(listener); } } // 省略... return allListeners; } } 在上面源码中，获取到容器中所有的监听器，然后遍历，判断是否支持当前事件，如果支持，则将其添加到列表，最终经过一些处理后返回。 其实在外层方法调用这里的时候，是做了缓存的。只有第一次调用的时候，会走到这里，进行遍历并判断。之后再获取，都是从缓存中获取的。 再深入看的话，可以看一下 TransactionSynchronizationEventAdapter类，实际上注册的实例就是这个类型的。 源码如下: private static class TransactionSynchronizationEventAdapter extends TransactionSynchronizationAdapter { private final ApplicationListenerMethodAdapter listener; private final ApplicationEvent event; private final TransactionPhase phase; public TransactionSynchronizationEventAdapter(ApplicationListenerMethodAdapter listener, ApplicationEvent event, TransactionPhase phase) { this.listener = listener; this.event = event; this.phase = phase; } @Override public int getOrder() { return this.listener.getOrder(); } @Override public void beforeCommit(boolean readOnly) { if (this.phase == TransactionPhase.BEFORE_COMMIT) { processEvent(); } } @Override public void afterCompletion(int status) { if (this.phase == TransactionPhase.AFTER_COMMIT \u0026\u0026 status == STATUS_COMMITTED) { processEvent(); } else if (this.phase == TransactionPhase.AFTER_ROLLBACK \u0026\u0026 status == STATUS_ROLLED_BACK) { processEvent(); } else if (this.phase == TransactionPhase.AFTER_COMPLETION) { processEvent(); } } protected void processEvent() { // 总是会调用到这里，这里其实就是我们加了@TransactionalEventListener注解的方法调用 this.listener.","date":"2020-12-07","objectID":"/posts/spring/20-transaction-extention-transaction-synchronization/:2:0","tags":["spring源码"],"title":"20 声明式事务扩展 TransactionSynchronization","uri":"/posts/spring/20-transaction-extention-transaction-synchronization/"},{"categories":["spring"],"content":"事务的挂起、提交、回滚源码分析","date":"2020-12-07","objectID":"/posts/spring/19-transaction-source-suspend-rollback-commit/","tags":["spring源码"],"title":"19 声明式事务的挂起、提交、回滚、连接的释放原理","uri":"/posts/spring/19-transaction-source-suspend-rollback-commit/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-12-07","objectID":"/posts/spring/19-transaction-source-suspend-rollback-commit/:0:0","tags":["spring源码"],"title":"19 声明式事务的挂起、提交、回滚、连接的释放原理","uri":"/posts/spring/19-transaction-source-suspend-rollback-commit/"},{"categories":["spring"],"content":"1 事务的挂起 事务的挂起，调用的是 suspend()。 以下是 suspend() 源码： public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException { if (TransactionSynchronizationManager.isSynchronizationActive()) { List\u003cTransactionSynchronization\u003e suspendedSynchronizations = doSuspendSynchronization(); try { Object suspendedResources = null; if (transaction != null) { // TODO 重点：如果存在事务，则挂起事务，其实就是从ThreadLocal变量中解绑连接。 suspendedResources = doSuspend(transaction); } // 清楚TransactionSynchronizationManager中的当前事务的一些信息。将旧的事务对象信息封装到挂起对象中，最终会绑定到当前事务对象。 String name = TransactionSynchronizationManager.getCurrentTransactionName(); TransactionSynchronizationManager.setCurrentTransactionName(null); boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly(); TransactionSynchronizationManager.setCurrentTransactionReadOnly(false); Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel(); TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null); boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive(); TransactionSynchronizationManager.setActualTransactionActive(false); // 返回一个挂起资源持有对象，这个对象中封装了当前已存在事务的具体信息。这个对象会存储到新开启事务的TransactionStatus中。 return new SuspendedResourcesHolder( suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive); } catch (RuntimeException | Error ex) { // doSuspend failed - original transaction is still active... doResumeSynchronization(suspendedSynchronizations); throw ex; } } else if (transaction != null) { // Transaction active but no synchronization active. Object suspendedResources = doSuspend(transaction); return new SuspendedResourcesHolder(suspendedResources); } else { // Neither transaction nor synchronization active. return null; } } } 这个方法中，首先会挂起前一个事务，并把前一个事务信息返回，最终封装到SuspendedResourcesHolder中，之后会将 SuspendedResourcesHolder 封装到当前事务对象中。 在封装之前，会清除 TransactionSynchronizationManager 中记载的当前事务的一些信息。 具体的挂起操作，就在 doSuspend() 中： public class DataSourceTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, InitializingBean { @Override protected Object doSuspend(Object transaction) { DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; txObject.setConnectionHolder(null); // 解绑链接资源 return TransactionSynchronizationManager.unbindResource(obtainDataSource()); } } 可以看到，所谓的挂起，就是解绑resource，它存储在一个线程绑定的静态常量中。 来到 unbindResource()： public class DataSourceTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, InitializingBean { private static Object doUnbindResource(Object actualKey) { // 从ThreadLocal的map缓存中获取，如果为空，直接返回，如果不为空，则移除绑定关系。 Map\u003cObject, Object\u003e map = resources.get(); if (map == null) { return null; } // 这里会解绑当前线程的链接资源。 Object value = map.remove(actualKey); // Remove entire ThreadLocal if empty... if (map.isEmpty()) { resources.remove(); } // Transparently suppress a ResourceHolder that was marked as void... if (value instanceof ResourceHolder \u0026\u0026 ((ResourceHolder) value).isVoid()) { value = null; } if (value != null \u0026\u0026 logger.isTraceEnabled()) { logger.trace(\"Removed value [\" + value + \"] for key [\" + actualKey + \"] from thread [\" + Thread.currentThread().getName() + \"]\"); } return value; } } 事务的挂起，实际上就是将 DataSourceTransactionManager 中的静态常量 resources 中存储的值给移除掉。这是一个 ThreadLocal 类型的 map。 其定义是这样的：private static final ThreadLocal\u003cMap\u003cObject, Object\u003e\u003e resources = new NamedThreadLocal\u003c\u003e(\"Transactional resources\"); ","date":"2020-12-07","objectID":"/posts/spring/19-transaction-source-suspend-rollback-commit/:1:0","tags":["spring源码"],"title":"19 声明式事务的挂起、提交、回滚、连接的释放原理","uri":"/posts/spring/19-transaction-source-suspend-rollback-commit/"},{"categories":["spring"],"content":"2 事务的提交 在执行完被代理方法后，最终会在 finally 语句块中调用 commitTransactionAfterReturning()，这个方法就完成了事务的提交操作。 源码如下： public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean { protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) { if (txInfo != null \u0026\u0026 txInfo.getTransactionStatus() != null) { if (logger.isTraceEnabled()) { logger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() + \"]\"); } // 使用事务管理器，提交事务。 txInfo.getTransactionManager().commit(txInfo.getTransactionStatus()); } } } 其实这个方法中，不一定就是提交事务，如果设置了仅回滚，则会进行回滚操作。 具体逻辑在 commit()中： public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { @Override public final void commit(TransactionStatus status) throws TransactionException { if (status.isCompleted()) { throw new IllegalTransactionStateException( \"Transaction is already completed - do not call commit or rollback more than once per transaction\"); } DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status; // TODO 如果事务信息中保存的是仅回滚，则进行回滚操作。比如假如到这个事务中的方法抛出异常， // 则不会再那个方法就回滚，而是返回到事务的起点方法后，再进行回滚操作。 if (defStatus.isLocalRollbackOnly()) { if (defStatus.isDebug()) { logger.debug(\"Transactional code has requested rollback\"); } // 回滚事务 processRollback(defStatus, false); return; } // 判断是否仅回滚，主要是看connectionHolder是否设置了仅回滚。 if (!shouldCommitOnGlobalRollbackOnly() \u0026\u0026 defStatus.isGlobalRollbackOnly()) { if (defStatus.isDebug()) { logger.debug(\"Global transaction is marked as rollback-only but transactional code requested commit\"); } // 回滚事务 processRollback(defStatus, true); return; } // TODO 事务提交 processCommit(defStatus); } } 比如 RERUIRED 传播行为，前一个方法已经开启了事务，然后当前方法就会加入到这个已存在的事务中。如果这个内层的方法抛出异常，即使在外层方法中捕获异常，同样会回滚事务。 这个回滚操作并不是在内层方法中做的，在内层方法结束的时候，只会做一个 rollbackOnly 的标记。真正的回滚是在创建事务的起点方法做的。 所以上面代码中，会先判断是否仅回滚，如果是，则直接执行回滚操作。isGlobalRollbackOnly() 的判断于此类似。如果最终判断应该提交事务，则执行 processCommit() 进行事务的提交。 来到 processCommit() 源码： public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { private void processCommit(DefaultTransactionStatus status) throws TransactionException { try { boolean beforeCompletionInvoked = false; try { boolean unexpectedRollback = false; // 预提交，这是一个钩子方法，点进去可以看到是一个空方法。 prepareForCommit(status); // TransactionSynchronization的扩展点可在事务方法中向TransactionSynchronizationManager注入回调。不同的方法回调时机不一样。 // 也可以使用 @TransactionalEventListener，其原理也是注入 TransactionSynchronization 回调。 // 事务同步回调接口TransactionSynchronization.beforeCommit()的调用。 triggerBeforeCommit(status); // 事务同步回调接口TransactionSynchronization.beforeCompletion()的调用。 triggerBeforeCompletion(status); beforeCompletionInvoked = true; // TODO 是否有回滚点（保存点），如果是设置了回滚点，则仅仅吧回滚点抹除即可。真正的提交是在最外层事务提交做的。 // 这也是NESTED传播行为，在外围方法事务异常时，所有嵌套事务全部回滚的原因所在。 if (status.hasSavepoint()) { if (status.isDebug()) { logger.debug(\"Releasing transaction savepoint\"); } unexpectedRollback = status.isGlobalRollbackOnly(); status.releaseHeldSavepoint(); } else if (status.isNewTransaction()) { if (status.isDebug()) { logger.debug(\"Initiating transaction commit\"); } // TODO 事务提交 unexpectedRollback = status.isGlobalRollbackOnly(); doCommit(status); }else if (isFailEarlyOnGlobalRollbackOnly()) { unexpectedRollback = status.isGlobalRollbackOnly(); } // 省略... }// 省略... 这里会有一些catch，对 TransactionSynchronization 扩展点的调用。 finally { // TransactionSynchronization 扩展 triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED); } } finally { cleanupAfterCompletion(status); } } } 在 processCommit() 中，会先进行一些扩展钩子方法的回调。这里使用了策略模式，会对 synchronizations 遍历，里面封装了所有注册的 TransactionSynchronization，遍历去调用对应的方法。 如果设置了保存点，则将保存点抹除。在 NESTED 传播行为中，它的实现就是使用的保存点（savePoint），NESTED 传播行为并不会新启一个事务，而是标记一个 savePoint，如果这个方法异常，就会回滚至 savePoint处。 如果是一个事务创建的起点，就会执行提交操作。 在 doCommit() 中进行了事务的提交： public class DataSourceTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, InitializingBean { @Override protected void doCommit(DefaultTransactionSta","date":"2020-12-07","objectID":"/posts/spring/19-transaction-source-suspend-rollback-commit/:2:0","tags":["spring源码"],"title":"19 声明式事务的挂起、提交、回滚、连接的释放原理","uri":"/posts/spring/19-transaction-source-suspend-rollback-commit/"},{"categories":["spring"],"content":"3 事务的回滚 在调用业务方法抛出异常时，事务的通知方法中，会捕获这个异常。然后对事务进行回滚操作，之后将异常再次抛出。 事务的回滚入口方法在 completeTransactionAfterThrowing()： public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean { protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) { // 如果存在事务状态对象 if (txInfo != null \u0026\u0026 txInfo.getTransactionStatus() != null) { // 判断事务属性不为空并且满足回滚规则，就进行回滚，否则进行事务提交 if (txInfo.transactionAttribute != null \u0026\u0026 txInfo.transactionAttribute.rollbackOn(ex)) { // TODO 重点：具体的回滚代码 txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus()); // 省略 try catch 块... }else { // 如果抛出的异常，与回滚的异常定义不匹配，则提交事务。也就是说，抛出异常了，也不一定回滚。它存在一个异常类型匹配。 txInfo.getTransactionManager().commit(txInfo.getTransactionStatus()); // 这里省略了 try catch 块... } } } } 首先判断是否存在事务，如果存在事务，则判断，抛出的异常是否符合是需要回滚的异常。 具体哪些异常回滚是可以设置的，如果不设置，默认是 RuntimeException 和 Error。 简单看下 rollBackOn()： public class RuleBasedTransactionAttribute extends DefaultTransactionAttribute implements Serializable { @Override public boolean rollbackOn(Throwable ex) { RollbackRuleAttribute winner = null; int deepest = Integer.MAX_VALUE; // 判断回滚规则 if (this.rollbackRules != null) { for (RollbackRuleAttribute rule : this.rollbackRules) { // 递归调用异常的父类，如果异常名称中包含规则中封装的异常名称，则返回。 int depth = rule.getDepth(ex); // 如果不满足规则，会返回-1，如果满足了规则，会把这个规则赋值到winner临时变量中。 if (depth \u003e= 0 \u0026\u0026 depth \u003c deepest) { deepest = depth; winner = rule; } } } if (logger.isTraceEnabled()) { logger.trace(\"Winning rollback rule is: \" + winner); } // 如果没有配置回滚异常或不回滚异常，则会走默认的。默认回滚运行时异常及Error： // (ex instanceof RuntimeException || ex instanceof Error); // User superclass behavior (rollback on unchecked) if no rule matches. if (winner == null) { logger.trace(\"No relevant rollback rule found: applying default rules\"); return super.rollbackOn(ex); } // 判断规则如果是不回滚规则，则返回false，表示不需要回滚。 // 判断规则如果不是不回滚规则，返回true，表示需要回滚 return !(winner instanceof NoRollbackRuleAttribute); } } 如果事务声明中配置了需要回滚的异常，就递归的匹配异常，获取其 RollbackRuleAttribute，如果获取的到，返回这个规则不属于不回滚的异常规则 true/fasle。 如果匹配不到，就使用默认的回滚规则，默认回滚规则在 super.rollbackOn(ex); 中定义了。 public class DefaultTransactionAttribute extends DefaultTransactionDefinition implements TransactionAttribute { @Override public boolean rollbackOn(Throwable ex) { return (ex instanceof RuntimeException || ex instanceof Error); } } 回到 completeTransactionAfterThrowing() 中，接着看具体的回滚逻辑 rollback()，在这里会调用到 processRollback()。 源码如下： public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { private void processRollback(DefaultTransactionStatus status, boolean unexpected) { try { boolean unexpectedRollback = unexpected; try { // 如果是一个新建的事务，即到了事务的起点。 // 在回滚之前会循环调用TransactionSynchronization的beforeCompletion方法，这里是一个回调函数 triggerBeforeCompletion(status); // 有保存点（或者叫回滚点），回滚到保存点位置 if (status.hasSavepoint()) { if (status.isDebug()) { logger.debug(\"Rolling back transaction to savepoint\"); } status.rollbackToHeldSavepoint(); }// 如果是一个新建的事务，即回到了事务的起点。 else if (status.isNewTransaction()) { if (status.isDebug()) { logger.debug(\"Initiating transaction rollback\"); } // 从当前事务状态对象中获取到链接对象，进行回滚操作 doRollback(status); } else { // 如果是加入的已有事务，则将事务状态设置为仅回滚 rollbackOnly=true，最终返回到事务的起点时，是否向外抛出异常都会回滚。 // 所以在 REQUIRED 传播行为中，任何一个加入事务的方法异常，都会触发回滚。 // Participating in larger transaction if (status.hasTransaction()) { if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) { if (status.isDebug()) { logger.debug(\"Participating transaction failed - marking existing transaction as rollback-only\"); } doSetRollbackOnly(status); } else { if (status.isDebug()) { logger.debug(\"Participating transaction failed - letting transaction originator decide on rollback\"); } } } else { logger.debug(\"Should roll back transaction but cannot - no transaction available\"); } // Unexpected rollback only matters here if we're asked to fail early if (!isFailEarlyOnGlobalRollbackOnly()) { unexpectedRollback = false; } } } catch (RuntimeException | Error ex) { // TransactionSynchronization 扩展","date":"2020-12-07","objectID":"/posts/spring/19-transaction-source-suspend-rollback-commit/:3:0","tags":["spring源码"],"title":"19 声明式事务的挂起、提交、回滚、连接的释放原理","uri":"/posts/spring/19-transaction-source-suspend-rollback-commit/"},{"categories":["spring"],"content":"4 数据库连接的释放 无论是事务提交或是回滚，之后，都会调用一个方法 triggerAfterCompletion()，在这个方法中，就完成了数据库连接的释放。 在真正释放之前，同样也会调用已注册的 TransactionSynchronization 的一个扩展方法 resume()。 连接的释放，实际上就是通过 TransactionSynchronization 的扩展方法来实现的，这个方法是 afterCompletion()。 在 triggerAfterCompletion() 中，调用了 invokeAfterCompletion()。在这里就遍历了 synchronizations，进行 afterCompletion() 的调用。 源码如下（省略了try catch 代码块）： public abstract class TransactionSynchronizationUtils { public static void invokeAfterCompletion(@Nullable List\u003cTransactionSynchronization\u003e synchronizations, int completionStatus) { if (synchronizations != null) { for (TransactionSynchronization synchronization : synchronizations) { synchronization.afterCompletion(completionStatus); } } } } 在 afterCompletion() 中经历了以下调用链： releaseConnection() -\u003e doReleaseConnection() -\u003e doCloseConnection() -\u003e con.close() 以 druid 连接池为例，最终会调用到 recycle()，在recycle中，有这么一段代码： public class DruidDataSource extends DruidAbstractDataSource implements DruidDataSourceMBean, ManagedDataSource, Referenceable, Closeable, Cloneable, ConnectionPoolDataSource, MBeanRegistration { private volatile DruidConnectionHolder[] connections; // 步骤一 protected void recycle(DruidPooledConnection pooledConnection) throws SQLException { // 省略无关代码... lock.lock(); try { if (holder.active) { activeCount--; holder.active = false; } closeCount++; // 这个方法，将连接归还。 result = putLast(holder, currentTimeMillis); recycleCount++; } finally { lock.unlock(); } //省略无关代码... } // 步骤二 boolean putLast(DruidConnectionHolder e, long lastActiveTimeMillis) { if (poolingCount \u003e= maxActive || e.discard) { return false; } e.lastActiveTimeMillis = lastActiveTimeMillis; // 这里，将连接归还到数组的指定索引处。 connections[poolingCount] = e; incrementPoolingCount(); if (poolingCount \u003e poolingPeak) { poolingPeak = poolingCount; poolingPeakTime = lastActiveTimeMillis; } notEmpty.signal(); notEmptySignalCount++; return true; } } 从上面代码中可以看到，在 result = putLast(holder, currentTimeMillis); 中，就将连接进行回收了。 ","date":"2020-12-07","objectID":"/posts/spring/19-transaction-source-suspend-rollback-commit/:4:0","tags":["spring源码"],"title":"19 声明式事务的挂起、提交、回滚、连接的释放原理","uri":"/posts/spring/19-transaction-source-suspend-rollback-commit/"},{"categories":["spring"],"content":"事务注解 @Transaction 的支持，扫描原理。","date":"2020-12-07","objectID":"/posts/spring/18-transaction-source-ano-supports/","tags":["spring源码"],"title":"18 声明式事务注解@Transaction的解析原理","uri":"/posts/spring/18-transaction-source-ano-supports/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 [17 声明式事务执行流程源码分析] 中已经列举，通过 getTransactionAttribute() 获取到了方法上事务注解的一些信息。 来到其源码： public abstract class AbstractFallbackTransactionAttributeSource implements TransactionAttributeSource { public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class\u003c?\u003e targetClass) { // 获取事务注解属性 if (method.getDeclaringClass() == Object.class) { return null; } // 先从缓存中拿。如果一个方法的事务注解信息被获取过，就会将其缓存到一个并发安全的map中。后面再获取就从这个缓存中获取。 // First, see if we have a cached value. Object cacheKey = getCacheKey(method, targetClass); TransactionAttribute cached = this.attributeCache.get(cacheKey); if (cached != null) { // 省略... }else { // TODO 获取事务注解属性，放入缓存。 // We need to work it out. TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass); // Put it in the cache. if (txAttr == null) {// 放入缓存 this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE); } else { String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass); // 省略... this.attributeCache.put(cacheKey, txAttr); } return txAttr; } } } 先从缓存中获取，如果可以获取到直接返回。否则调用 computeTransactionAttribute() 从方法上进行事务注解信息的获取。 来到 computeTransactionAttribute() 源码： public abstract class AbstractFallbackTransactionAttributeSource implements TransactionAttributeSource { protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class\u003c?\u003e targetClass) { // Don't allow no-public methods as required. if (allowPublicMethodsOnly() \u0026\u0026 !Modifier.isPublic(method.getModifiers())) { return null; } // The method may be on an interface, but we need attributes from the target class. // If the target class is null, the method will be unchanged. Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass); // TODO 重点：查找事务属性，首先从目标方法上查找 // First try is the method in the target class. TransactionAttribute txAttr = findTransactionAttribute(specificMethod); if (txAttr != null) { return txAttr; } // 如果目标方法上查找不到，从目标类上查找。 // Second try is the transaction attribute on the target class. txAttr = findTransactionAttribute(specificMethod.getDeclaringClass()); if (txAttr != null \u0026\u0026 ClassUtils.isUserLevelMethod(method)) { return txAttr; } // 如果方法上找不到，到接口方法、接口上找对应注解。 if (specificMethod != method) { // Fallback is to look at the original method. txAttr = findTransactionAttribute(method); if (txAttr != null) { return txAttr; } // Last fallback is the class of the original method. txAttr = findTransactionAttribute(method.getDeclaringClass()); if (txAttr != null \u0026\u0026 ClassUtils.isUserLevelMethod(method)) { return txAttr; } } return null; } } 查找注解信息的顺序： 从缓存中获取，如果获取得到，就返回。 从目标对象的方法上找，如果能查找到注解信息，就返回。 从目标对象类上查找注解信息，如果查找到，就返回。 从目标接口、父类方法上查找注解信息，如果查找到，就返回。 从目标接口、父类上查找注解信息，如果查找到，就返回。 如果没有查找到注解信息，就返回null。 继续向下追踪源码就能看到，无论是从方法上获取、还是从类上获取注解信息，最终都是调用到 determineTransactionAttribute()。 源码如下： public class AnnotationTransactionAttributeSource extends AbstractFallbackTransactionAttributeSource implements Serializable { protected TransactionAttribute determineTransactionAttribute(AnnotatedElement element) { // TODO 循环所有的解析器，如果有解析器解析出的结果不为空，则直接返回事务属性，解析器列表是在当前对象构造函数时，加载的 // 如果是注解方式，用到的注解解析器是：SpringTransactionAnnotationParser for (TransactionAnnotationParser annotationParser : this.annotationParsers) { TransactionAttribute attr = annotationParser.parseTransactionAnnotation(element); if (attr != null) { return attr; } } return null; } } 遍历 annotationParsers，并调用 preTransactionAnnotation()，在 [14 声明式事务中XML配置及注解方式的注册入口] 中已经说明，在事务注解支持的入口，注册了 AnnotationTransactionAttributeSource，其中封装了一个解析类 SpringTransactionAnnotationParser，这个类就负责事务注解的解析。 SpringTransactionAnnotationParser 是 TransactionAnnotationParser 的其中一个实现。 以下是 SpringTransactionAnnotationParser.parseTransactionAnnotation() 源码： public class SpringTransactionAnnotationParser implements TransactionAnnotationParser, Serializable { @Override @Nullable public TransactionAttribute parseTransactionAnnotation(AnnotatedElemen","date":"2020-12-07","objectID":"/posts/spring/18-transaction-source-ano-supports/:0:0","tags":["spring源码"],"title":"18 声明式事务注解@Transaction的解析原理","uri":"/posts/spring/18-transaction-source-ano-supports/"},{"categories":["spring"],"content":"事务执行的主要流程源码分析","date":"2020-12-06","objectID":"/posts/spring/17-transaction-source-process/","tags":["spring源码"],"title":"17 声明式事务执行流程源码分析","uri":"/posts/spring/17-transaction-source-process/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-12-06","objectID":"/posts/spring/17-transaction-source-process/:0:0","tags":["spring源码"],"title":"17 声明式事务执行流程源码分析","uri":"/posts/spring/17-transaction-source-process/"},{"categories":["spring"],"content":"1 执行入口 在 声明式事务中XML配置及注解方式的注册入口 中，已经详细列举了事务注入入口的源码。 其中主要有三个比较关键的类： BeanFactoryTransactionAttributeSourceAdvisor 增强类，其中封装了Advice，以及TransactionAttributeSource TransactionAttributeSource 元数据检索的策略接口，对@Transactional的解析类支持，就在这里面封装。 TransactionInterceptor Advice实现，也是一个MethodInterceptor，具体的通知方法的执行就在这里面定义的。 在AOP生成代理实例时，会将所有搜集、或转换封装好的Advisor，缓存到AdvisedSupport.advisors中。 在第一次执行代理方法的时候，会遍历所有的Advisor，根据PointCut对方法进行匹配。匹配成功的，就添加到执行链，并缓存到AdvisedSupport.methodCache。后面再调用代理方法，就会优先从缓存中获取。 那么，BeanFactoryTransactionAttributeSourceAdvisor中，一定封装了PointCut。源码中是这样定义的： public class BeanFactoryTransactionAttributeSourceAdvisor extends AbstractBeanFactoryPointcutAdvisor { private TransactionAttributeSource transactionAttributeSource; private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() { @Override @Nullable protected TransactionAttributeSource getTransactionAttributeSource() { return transactionAttributeSource; } }; } 如果一个方法开启了事务，最终在getBean的时候，获取到的一定是代理对象。当第一次调用时，会生成执行链，并按执行链中的节点索引顺序来执行。事务的MethodInterceptor就是其中的一个节点。 既然 TransactionInterceptor 是一个 MethodInterceptor，那它一定实现了 invoke()，事务的执行入口，就在这个invoke()里面。 以下是 invoke() 的源码： public class TransactionInterceptor extends TransactionAspectSupport implements MethodInterceptor, Serializable { public Object invoke(MethodInvocation invocation) throws Throwable { Class\u003c?\u003e targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null); // 执行事务逻辑 // Adapt to TransactionAspectSupport's invokeWithinTransaction... return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed); } } ","date":"2020-12-06","objectID":"/posts/spring/17-transaction-source-process/:1:0","tags":["spring源码"],"title":"17 声明式事务执行流程源码分析","uri":"/posts/spring/17-transaction-source-process/"},{"categories":["spring"],"content":"2 主流程概览 进入到 invokeWithinTransaction() 的源码： public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean { protected Object invokeWithinTransaction(Method method, @Nullable Class\u003c?\u003e targetClass, final InvocationCallback invocation) throws Throwable { /* * TODO 其中事务传播行为的特点（这些特点，仔细分析代码是可以看出来的。相对比较烧脑。一般先了解特点，后面才会看源码）： * PROPAGATION_REQUIRED 如果当前存在事务，假如当前事务。如果不存在事务，新建事务。 * PROPAGATION_REQUIRES_NEW 如果当前存在事务，则挂起当前事务，新建一个事务。如果不存在事务，新建一个事务。使用频率高 * PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前不存在事务，则和PROPAGATION_REQUIRED一样新建事务。 * 特点：外围事务回滚，嵌套事务全部回滚。嵌套事务回滚，如果在外围中捕获了，则仅仅回滚嵌套事务。 * PROPAGATION_MANDATORY 以事务方式运行，如果当前不存在事务，则抛出异常 * PROPAGATION_NEVER 以非事务方式运行，如果当前存在事务，则抛出异常 * PROPAGATION_SUPPORTEDS 支持事务。如果当前存在事务，加入当前事务。如果不存在事务，则以非事务方式运行。 * PROPAGATION_NOT_SUPPORTED 以非事务方式运行。如果当前存在事务，挂起当前事务。 */ // 事务属性的获取 // If the transaction attribute is null, the method is non-transactional. TransactionAttributeSource tas = getTransactionAttributeSource(); // TODO getTransactionAttribute中是获取事务注解属性的具体逻辑。 final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null); // 获取事务管理器 final PlatformTransactionManager tm = determineTransactionManager(txAttr); final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) { // TODO 重点：如果有必要，创建事务 // Standard transaction demarcation with getTransaction and commit/rollback calls. TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try { // 上层方法中传入的回调函数，这里面是AOP执行链，火炬传递，直到调用了业务方法 // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. retVal = invocation.proceedWithInvocation(); } catch (Throwable ex) { // 业务方法执行出现异常 // target invocation exception completeTransactionAfterThrowing(txInfo, ex); throw ex; } finally { // TODO 清除事务信息，将当前事务清除，如果存在旧的事务对象，将旧的事务对象设置为当前持有的事务 // 存储在TransactionAspectSupport.transactionInfoHolder中，这是一个静态TrheadLocal常量。 cleanupTransactionInfo(txInfo); } // TODO 提交事务 commitTransactionAfterReturning(txInfo); return retVal; } else { // 此处省略... } } } 上面源码中，注释了前文中列举的spring声明式事务中的七种事务传播行为，以及它们的表现形式。 从源码中可以看出事务的主要流程： 获取到 TransactionAttributeSource。这个类封装了事务注解的解析操作。 根据第一步获取的结果，调用 getTransactionAttribute()，获取方法中的事务属性。 获取到方法的定义，实际上就是当前方法的全路径名。方法的描述在 TransactionAttribute 中有封装。 如果有必要，就创建事务。是否有必要、要看方法上是否有 @Transactional 注解，以及传播行为配置。当然，\u003ctx:advice/\u003e 这种全局配置也是。 执行被代理方法，即真正的业务方法。 如果抛出异常，按照抛出异常的处理方式，处理提交或回滚事务，将异常向上抛出。（抛出异常只是有可能会回滚，默认Error和RuntimeException会回滚，可以配置。） 清楚事务信息。如果存在旧的事务对象，将旧的事务对象设置为当前持有的事务对象。 提交事务。 如果看源码细节的话，这是一个很长的流程，要整体串联起来看。 ","date":"2020-12-06","objectID":"/posts/spring/17-transaction-source-process/:2:0","tags":["spring源码"],"title":"17 声明式事务执行流程源码分析","uri":"/posts/spring/17-transaction-source-process/"},{"categories":["spring"],"content":"3 传播行为的实现原理 进入到 createTransactionIfNecessary()，看一下源码中怎么做的： public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean { protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm, @Nullable TransactionAttribute txAttr, final String joinpointIdentification) { // 省略... TransactionStatus status = null; if (txAttr != null) { if (tm != null) { // TODO 重点：获取TransactionStatus对象 // 无论被代理对象的方法是否需要事务，在通过代理对象调用方法时，总会创建一个TransactionStatus，讲一些信息绑定到 // TrheadLocal的缓存变量中。这是为了在执行完方法的时候，可以回溯到调用方法存在的事务对象。类似责任链。 // 如果挂起了存在的事务，则当前方法执行的事务状态对象中会存储SuspendedResourcesHolder，及挂起的事务信息， // 当方法执行完后，将这个挂起从新设置到当前事务中来。 status = tm.getTransaction(txAttr); } // 省略... } // TODO 重点：将上面获取到的对象封装成TransactionInfo对象 return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status); } } 源码内容很简单，首先获取事务，封装成 TransactionStatus，然后将 TransactionStatus 封装成 TransactionInfo 返回。 ","date":"2020-12-06","objectID":"/posts/spring/17-transaction-source-process/:3:0","tags":["spring源码"],"title":"17 声明式事务执行流程源码分析","uri":"/posts/spring/17-transaction-source-process/"},{"categories":["spring"],"content":"3.1 前一个方法未开启事务时的处理 重点来到 getTransaction()，这里定义了针对不同的传播行为，做了不同的处理： 源码如下： public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { @Override public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException { // 获取事务对象 Object transaction = doGetTransaction(); // Cache debug flag to avoid repeated checks. boolean debugEnabled = logger.isDebugEnabled(); if (definition == null) { // Use defaults if no transaction definition given. definition = new DefaultTransactionDefinition(); } // 判断是否已经存在事务。如果当前事务对象已经持有了链接，并且事务是活跃状态，则表示已经存在事务。 // 如果当前已经存在事务，按照已存在事务的方式判断传播行为，进行处理 if (isExistingTransaction(transaction)) { // Existing transaction found -\u003e check propagation behavior to find out how to behave. // TODO 如果当前已存在事务，会走到此方法逻辑进行处理。 return handleExistingTransaction(definition, transaction, debugEnabled); } // TODO 以下是针对前一个方法未开启事务的情况的处理。 // 检测事务的超时时间设置是否正确 // Check definition settings for new transaction. if (definition.getTimeout() \u003c TransactionDefinition.TIMEOUT_DEFAULT) { throw new InvalidTimeoutException(\"Invalid transaction timeout\", definition.getTimeout()); } // 如果传播属性是PROPAGATION_MANDATORY，且当前不存在事务，则抛出异常 // No existing transaction found -\u003e check propagation behavior to find out how to proceed. if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) { throw new IllegalTransactionStateException( \"No existing transaction found for transaction marked with propagation 'mandatory'\"); }// 如果传播属性是PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED时，会走到这里 else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) { // 因为以上三种事务传播属性的特性，这里会挂起（如果当前存在事务） SuspendedResourcesHolder suspendedResources = suspend(null); if (debugEnabled) { logger.debug(\"Creating new transaction with name [\" + definition.getName() + \"]: \" + definition); } try { boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); // 创建事务状态对象 DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); // TODO 重点：开启事务。按照当前测试代码注册的事务管理器，使用的是DataSourceTransactionManager doBegin(transaction, definition); // 如果是新开启的事务，设置事务管理器相关属性。其实走到这里的代码，一定是新启的事务。 // 因为前面已经判断了，如果存在事务，就走handleExistingTransaction方法 prepareSynchronization(status, definition); return status; } catch (RuntimeException | Error ex) { resume(null, suspendedResources); throw ex; } } else { // 以非事务方式运行 NEVER SUPPORTS NOT_SUPPORTED，在外围未开启事务时，会走这里。 // Create \"empty\" transaction: no actual transaction, but potentially synchronization. if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT \u0026\u0026 logger.isWarnEnabled()) { logger.warn(\"Custom isolation level specified but no actual transaction initiated; \" + \"isolation level will effectively be ignored: \" + definition); } boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null); } } } 从上面源码中可以看到，getTransaction() 主要分为两个部分： 针对前一个方法（调用当前代理方法的方法），已经开启了事务的处理方式。 针对前一个方法，未开启事务的处理方式。 先看前一个方法未开启事务时，看以上源码中是怎么处理的。 检测事务的超时时间设置是否正确。（不能小于-1） 如果传播行为是 PROPAGATION_MANDATORY，直接抛出异常。（这也验证了，传播行为是 MADATORY 时，如果外围方法未开启事务，就抛出异常的行为。） 如果传播行为是 PROPAGATION_REQUIRED/PROPAGATION_REQUIRES_NEW/PROPAGATION_NESTED时，就挂起前一个事务（注意方法参数是null，也就是并没有事务挂起），然后调用 doBegin()，开启新的事务。 这三种传播行为，在前一个方法未开启事务时，都会新启一个事务。 如果传播行为是其余几种，则以非事务方式运行。所以参数中的事务对象传递的是null。 还有一个 prepareSynchronization 处理，这个是事务同步器的内容。它是对事务功能的扩展，可以在事务提交、异常回滚、及其他动作节点插入自定义的操作。在别的文章中列举。 ","date":"2020-12-06","objectID":"/posts/spring/17-transaction-source-process/:3:1","tags":["spring源码"],"title":"17 声明式事务执行流程源码分析","uri":"/posts/spring/17-transaction-source-process/"},{"categories":["spring"],"content":"3.2 判断前一个方法是否开启事务 上面源码中第一个方法 doGetTransaction()，是创建一个 DataSourceTransactionObject，在其中封装 ConnectionHolder，这个 ConnectionHolder 是从 TransactionSynchronizationManager中一个线程绑定的变量中获取的。 如果前一个方法开启了事务，它是有值的。 判断前一个方法中是否开启了事务正式基于此，如果 ConnectionHolder 有值，且 active 是true，说明它是开启了事务的。 以下是 doGetTransaction() 源码： public abstract class TransactionSynchronizationManager { private static final ThreadLocal\u003cMap\u003cObject, Object\u003e\u003e resources = new NamedThreadLocal\u003c\u003e(\"Transactional resources\"); private static Object doGetResource(Object actualKey) { Map\u003cObject, Object\u003e map = resources.get(); if (map == null) { return null; } Object value = map.get(actualKey); if (value instanceof ResourceHolder \u0026\u0026 ((ResourceHolder) value).isVoid()) { map.remove(actualKey); if (map.isEmpty()) { resources.remove(); } value = null; } return value; } } resource是一个与线程绑定的map，之所以要用map，是因为一个线程多个方法调用栈内，可能有多个数据源，它的键值就跟数据源相关。 判断前一个方法是否开启了事务的源码： public class DataSourceTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, InitializingBean { protected boolean isExistingTransaction(Object transaction) { DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; return (txObject.hasConnectionHolder() \u0026\u0026 txObject.getConnectionHolder().isTransactionActive()); } } doGetTransaction() 中创建了一个DataSourceTransactionObject，内部封装了 ConnectionHolder，这个 ConnectionHolder 与线程绑定，所以在这里根据获取到的 ConnectionHolder，判断是否存在，且事务状态活跃。根据判断结果来确定前一个方法是否存在事务。 ","date":"2020-12-06","objectID":"/posts/spring/17-transaction-source-process/:3:2","tags":["spring源码"],"title":"17 声明式事务执行流程源码分析","uri":"/posts/spring/17-transaction-source-process/"},{"categories":["spring"],"content":"3.3 前一个方法开启事务时的处理 这段逻辑在 handleExistingTransaction()，源码如下： public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { private TransactionStatus handleExistingTransaction( TransactionDefinition definition, Object transaction, boolean debugEnabled) throws TransactionException { // 如果当前方法传播属性为从不开启事务，直接抛出异常。 // PROPAGATION_NEVER特性决定，如果当前存在事务，则抛出异常 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) { throw new IllegalTransactionStateException( \"Existing transaction found for transaction marked with propagation 'never'\"); } // PROPAGATION_NOT_SUPPORTED特性：如果当前存在事务，挂起当前事务，以非事务方式运行 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) { if (debugEnabled) { logger.debug(\"Suspending current transaction\"); } // 挂起事务 Object suspendedResources = suspend(transaction); boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); // 返回事务状态对象 return prepareTransactionStatus( definition, null, false, newSynchronization, debugEnabled, suspendedResources); } // TODO 重点：PROPAGATION_REQUIRES_NEW特性：无论当前是否存在事务，都新建一个事务。 // 如果存在事务，将会把当前事务挂起，被挂起的事务会存储到新的事务状态对象中。 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) { if (debugEnabled) { logger.debug(\"Suspending current transaction, creating new transaction with name [\" + definition.getName() + \"]\"); } // 挂起当前事务，由于PROPAGATION_REQUIRES_NEW的特性，需要使用新的事务，所以要将当前事务挂起，当新的事务执行完毕时，会恢复这个挂起的事务。 SuspendedResourcesHolder suspendedResources = suspend(transaction); try { boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); // TODO 可以看到，这里创建事务对象时，构造函数中的参数newTransaction为true。 DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); // PROPAGATION_REQUIRES_NEW表示总是新启一个事务，这里会新开启事务。 doBegin(transaction, definition); prepareSynchronization(status, definition); return status; } catch (RuntimeException | Error beginEx) { resumeAfterBeginException(transaction, suspendedResources, beginEx); throw beginEx; } } // TODO PROPAGATION_NESTED嵌套事务，如果存在事务，则在嵌套事务中运行。如果不存在事务，则新建一个事务。 // 嵌套事务是用savePoint来实现的。具体过程： // 1.新建事务状态对象时，会设置一个保存点（或者叫回滚点）。 // 2.如果业务方法执行抛出异常，则会被事务切面捕获，如果存在保存点，则会回滚值保存点。 // 3.正常执行完业务方法，如果这个方法对应的事务状态对象中具有保存点，则会擦除这个保存点。 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) { if (!isNestedTransactionAllowed()) { throw new NestedTransactionNotSupportedException( \"Transaction manager does not allow nested transactions by default - \" + \"specify 'nestedTransactionAllowed' property with value 'true'\"); } if (debugEnabled) { logger.debug(\"Creating nested transaction with name [\" + definition.getName() + \"]\"); } // 是否使用保存点，在测试中用到的事务管理器来看，总是返回true if (useSavepointForNestedTransaction()) { // Create savepoint within existing Spring-managed transaction, // through the SavepointManager API implemented by TransactionStatus. // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization. DefaultTransactionStatus status = prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null); // 创建savePoint，保存点（或者叫回滚点） status.createAndHoldSavepoint(); return status; } else { boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, null); doBegin(transaction, definition); prepareSynchronization(status, definition); return status; } } // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED. if (debugEnabled) { logger.debug(\"Participating in existing transaction\"); } // 省略无关代码... boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); // 创建事务状态对象，如果是新创建的事务，则设置事务管理器的相关属性。 return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null); } } 源码中的流程： 如果方法中事务传播行为设置","date":"2020-12-06","objectID":"/posts/spring/17-transaction-source-process/:3:3","tags":["spring源码"],"title":"17 声明式事务执行流程源码分析","uri":"/posts/spring/17-transaction-source-process/"},{"categories":["spring"],"content":"4 事务的开启 从上面的代码中，已经知道了事务开启是通过 doBegin()。 以下是 doBegin() 源码： public class DataSourceTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, InitializingBean { protected void doBegin(Object transaction, TransactionDefinition definition) { DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; Connection con = null; try { // 如果当前事务对象没有持有链接，就获取一个，并设置到链接持有变量中。 if (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) { Connection newCon = obtainDataSource().getConnection(); if (logger.isDebugEnabled()) { logger.debug(\"Acquired Connection [\" + newCon + \"] for JDBC transaction\"); } txObject.setConnectionHolder(new ConnectionHolder(newCon), true); } // 设置事务同步为true，标识使用了事务。 txObject.getConnectionHolder().setSynchronizedWithTransaction(true); // 获取数据库连接对象。 con = txObject.getConnectionHolder().getConnection(); // 设置事务隔离级别 Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition); txObject.setPreviousIsolationLevel(previousIsolationLevel); // TODO 重点：开启事务核心点：将事务自动提交关闭。即手动提交事务（由spring控制事务提交） // Switch to manual commit if necessary. This is very expensive in some JDBC drivers, // so we don't want to do it unnecessarily (for example if we've explicitly // configured the connection pool to set it already). if (con.getAutoCommit()) { txObject.setMustRestoreAutoCommit(true); if (logger.isDebugEnabled()) { logger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\"); } con.setAutoCommit(false); } // 如果Transaction中配置了只读，这里会将事务设置为只读属性 prepareTransactionalConnection(con, definition); // 在事务链接持有对象中，设置事务活跃状态为true txObject.getConnectionHolder().setTransactionActive(true); // 查找配置的事务超时时间，如果未配置，会使用默认的。默认值为-1，表示永不超时。 int timeout = determineTimeout(definition); if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) { // 在链接持有对象中设置超时时间，从这里可以看出，单位是秒。 txObject.getConnectionHolder().setTimeoutInSeconds(timeout); } // 如果事务对象是在当前代理方法中new的，则绑定到ThreadLocal变量中。 // Bind the connection holder to the thread. if (txObject.isNewConnectionHolder()) { TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder()); } } catch (Throwable ex) { // 如果出现异常，释放数据库连接对象。 if (txObject.isNewConnectionHolder()) { DataSourceUtils.releaseConnection(con, obtainDataSource()); txObject.setConnectionHolder(null, false); } throw new CannotCreateTransactionException(\"Could not open JDBC Connection for transaction\", ex); } } } 方法第一次执行时，肯定是没有连接的。首先，获取到一个数据库连接。并将这个链接封装成 ConnectionHolder，添加到 DataSourceTransactionObject 中。 获取到链接对象，设置事务隔离级别、超时时间等信息。最关键的一行代码是 con.setAutoCommit(false)，将自动提交关闭，改为手动提交事务。在后面的流程，调用代理方法后，根据执行结果进行事务提交或回滚。 ","date":"2020-12-06","objectID":"/posts/spring/17-transaction-source-process/:4:0","tags":["spring源码"],"title":"17 声明式事务执行流程源码分析","uri":"/posts/spring/17-transaction-source-process/"},{"categories":["spring"],"content":"详细描述不正确使用声明式事务的危害，像本类自调用问题、事务方法嵌套等。","date":"2020-12-05","objectID":"/posts/spring/16-transaction-declare-attention/","tags":["spring源码"],"title":"16 声明式事务注意事项","uri":"/posts/spring/16-transaction-declare-attention/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-12-05","objectID":"/posts/spring/16-transaction-declare-attention/:0:0","tags":["spring源码"],"title":"16 声明式事务注意事项","uri":"/posts/spring/16-transaction-declare-attention/"},{"categories":["spring"],"content":"1 不正确使用声明式事务的危害 作为后端开发人员，spring声明式事务是我们经常使用的。一定要透彻理解事务的传播行为，否则开发出来的代码大概率是有问题的。影响性能是其一，还可能会出现一些极难排查的“脏数据”，甚至发生死锁、影响整个进程的服务。 影响性能的原因：事务的范围跨度过大，可能有一些点，不要求原子操作的，写到了声明了事务的方法中，那么在这个事务方法执行完之前，数据库相关的锁会迟迟无法释放（根据不同的隔离级别，数据库会有不同粒度的锁。）；同时会延缓数据库连接的释放。 脏数据产生的原因：业务上应该在一个事务中执行的原子操作，由于传播行为设置问题，或者事务声明范围过小，导致其未能串联到一个事务中，就很有可能产生脏数据。事务隔离级别过小也可能导致这种情况，这是数据库的范畴，不做讨论。 总的来说，事务的跨度过大会影响性能。业务上的多项操作，要求原子性的执行的，没有全部包含到一个事务中，就会产生脏数据。 ","date":"2020-12-05","objectID":"/posts/spring/16-transaction-declare-attention/:1:0","tags":["spring源码"],"title":"16 声明式事务注意事项","uri":"/posts/spring/16-transaction-declare-attention/"},{"categories":["spring"],"content":"2 本类中自调用方法的问题 有这么一段伪代码： class OrderService{ @Transactional public void order1(){ this.order2(); } @Transactional public void order2(){ } } 在 order1() 调用 order2() 的时候，order2() 的事务注解中的配置是不会生效的。由于声明式事务是使用代理实现的，只有通过代理对象调用方法时，相应的通知方法才会执行，声明式事务本身的事务开启和提交、回滚就是通过一个通知方法来实现的。 获取代理对象的方式有两种： AopContext.currentProxy()，会返回正在执行的当前方法所在实例的代理对象。需要在代理配置中指定 exposeProxy = true。 注入自身实例，即在本类中注入自身实例作为一个成员变量，如果有本类中方法自调用的情况，使用这个变量来调用。就会走代理对象的通知方法。 注入自身实例伪代码： class OrderService{ @Autowired OrderService orderService; @Transactional public void order1(){ orderService.order2(); } @Transactional public void order2(){ } } 之所以可以这么将自身注入为变量，在循环依赖问题的解决源码章节中有详细列举。 ","date":"2020-12-05","objectID":"/posts/spring/16-transaction-declare-attention/:2:0","tags":["spring源码"],"title":"16 声明式事务注意事项","uri":"/posts/spring/16-transaction-declare-attention/"},{"categories":["spring"],"content":"3 避免事务的嵌套 注意\r\r事务方法中，尽量避免嵌套新启事务： 一个方法调用开启了事务的另一个方法，如此嵌套很多事务，会延长外层事务的提交时间，也会延缓数据库连接的释放。因为在方法执行完之前，无法走到代理的后置通知，就无法触发提交或回滚代码，更无法释放数据库连接。 另一个原因就是，开启事务是需要数据库连接的，连接在连接池中的数量有限。事务方法中嵌套新启事务，会使得这个方法的执行占用多个连接。 如果多个请求并发执行这种方法，或者事务嵌套个数本身就超出了连接池的数量（这种基本不存在）。为了打开多个事务，每个线程要获取多个数据库连接，就很可能在获取过程中发生死锁的情况。 传播行为 NESTED ，本质上和外围方法在一个事务中。只是在事务通知方法中，标识了 savePoint。它们使用的数据库连接，还是同一个。 \r\r 下面代码展示由于事务方法中多层事务嵌套，导致的死锁问题。 首先，将连接池最大连接数设置为1。写一个开启事务的方法，让它调用另一个新启事务的方法。那么外层方法执行时，就需要开启两个事务，占用两个连接。 使用 声明式事务七种传播行为的表现形式案例 中的一块测试代码，唯一的改变是修改连接池大小。 数据库连接池设置如下： public class GlobalTransactionConfig { @Bean public DruidDataSource getDruidDataSource(){ DruidDataSource ds = new DruidDataSource(); // 省略... ds.setMaxActive(1); return ds; } } 模拟业务方法如下 方法1 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionExceptionRequiresNewRequiresNew() { userService.addRequiredNew(new PropagationUser(\"张三\")); userService.addRequiredNew(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 方法2 public class PropagationUserServiceImpl implements PropagationUserService { @Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class) @Override public void addRequiredNew(PropagationUser user) { userDao.insertSelective(user); } } 在我们调用 transactionExceptionRequiresNewRequiresNew() 的时候就会发现，实际上代码执行到 userService.addRequiredNew(new PropagationUser(\"张三\")) 时，就会发生死锁。 道理很简单，addRequiredNew() 在等待数据库连接池给它链接，而连接池已经没有连接了，唯一的一个连接被外层方法给占用了，所以它也在等待 transactionExceptionRequiresNewRequiresNew() 释放连接，这样就产生了死锁。 有限数量的资源，被多个线程并发的请求各自占有多个，就可能发生死锁。很有可能在占有过程中，资源已经用尽了。即使仅嵌套一个事务，假设总数100个数据库连接， 也是有可能发生死锁的（有100个线程各占了一个连接，这100个线程就会等待在获取第二个连接处）。 注：这和并发编程中死锁的概念是有区别的。并发编程中的死锁跟锁的获取顺序有关，获取多个锁对象，只要顺序一致就不会死锁。而这里占用数据库连接，仅是资源的争抢，资源耗尽就会阻塞在争抢的过程中，跟获取顺序无关。 ","date":"2020-12-05","objectID":"/posts/spring/16-transaction-declare-attention/:3:0","tags":["spring源码"],"title":"16 声明式事务注意事项","uri":"/posts/spring/16-transaction-declare-attention/"},{"categories":["spring"],"content":"spring声明式事务的传播行为，严格来说是spring特有的，数据库本身并没有这个概念。本文会列举出spring事务其中传播行为，以案例的方式展示不同的传播行为的表现是怎样的。","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:0:0","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"1 基础概念 spring声明式事务的传播行为，严格来说是spring特有的，数据库本身并没有这个概念。本文会列举出spring事务的七种传播行为，并以代码案例的方式展示不同的传播行为的表现是怎样的。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:1:0","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"1.1 什么是事务传播行为 事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法时事务如何传播。 伪代码： public class A{ @AutoWired private B b; public void a(){ b.b(); // 业务代码... } } public class B{ @AutoWired private A a; @Transaction(Propagation=XXX) public void b(){ // 业务代码... } } 上面代码中 a() 嵌套了 b() 。b() 的事务传播行为由 @Transaction(Propagation=XXX) 决定。注意，a() 并没有开启事务。某一个事务传播行为修饰的方法并不是必须要在开启事务的外围方法中调用。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:1:1","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"1.2 spring声明式事务中七种传播行为 传播类型 说明 REQUIRED 如果当前没有事务，就新建一个事务；如果当前存在事务，就加入到当前事务。 SUPPORTS 如果当前没有事务，就以非事务方式运行；如果当前存在事务，就加入到当前事务。 MANDATORY 如果当前没有事务，就抛出异常；如果当前存在事务，就加入到当前事务。 REQUIRES_NEW 总是在新建事务中运行。如果当前已存在事务，就挂起当前事务。 NOT_SUPPORTED 以非事务方式运行；如果当前存在事务，挂起当前事务。 NEVER 以非事务的方式运行。如果当前存在事务，就抛出异常。 NESTED 如果当前存在事务，则在嵌套事务内运行；如果当前不存在事务，则新建一个事务（这时与 REQUIRED 类似）。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:1:2","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"2 基础代码准备 文中代码以 Service 和 Dao 两层展示。使用测试用例调用 Service 的方式，框架采用 spring + mybatis ，数据库 mysql。dao 层及实体类代码使用插件生成。 自动代理激活及扫描包配置类 AspectAnoForTransactionConfiguration ： @Configuration @EnableAspectJAutoProxy @ComponentScan(basePackages = {\"top.wlz922.service\"}) public class AspectAnoForTransactionConfiguration { } 事务配置类： @Configuration @MapperScan(basePackages = \"top.wlz922.dao\") @EnableTransactionManagement public class GlobalTransactionConfig { @Autowired ApplicationContext context; @Bean public DataSourceTransactionManager getTransactionManager(@Autowired DataSource ds){ DataSourceTransactionManager manager = new DataSourceTransactionManager(); manager.setDataSource(ds); return manager; } @Bean public SqlSessionFactoryBean getSqlSessionFactoryBean(@Autowired DataSource ds) throws IOException { SqlSessionFactoryBean fb = new SqlSessionFactoryBean(); fb.setDataSource(ds); ResourcePatternResolver resolver = ResourcePatternUtils.getResourcePatternResolver(context); Resource[] resources = resolver.getResources(\"classpath:sqlmaps/*.xml\"); fb.setMapperLocations(resources); return fb; } @Bean public DruidDataSource getDruidDataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setUsername(\"root\"); ds.setPassword(\"123456\"); ds.setUrl(\"jdbc:mysql://127.0.0.1:3306/test?serverTimezone=Asia/Shanghai\"); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); return ds; } } 实体类 PropagationUser ： @Data @NoArgsConstructor public class PropagationUser implements Serializable { private Long id; private String name; private static final long serialVersionUID = 1L; public PropagationUser(String name) { this.name = name; } } PropagationUserService （其实现类的事务注解配置与方法名一致）： public interface PropagationUserService { void addRequired(PropagationUser user); void addRequiredException(PropagationUser user); void addRequiredNew(PropagationUser user); void addRequiredNewException(PropagationUser user); void addSupports(PropagationUser user); void addSupportsException(PropagationUser user); void addNotSupported(PropagationUser user); void addNotSupportedException(PropagationUser user); void addMadatory(PropagationUser user); void addMadatoryException(PropagationUser user); void addNever(PropagationUser user); void addNeverException(PropagationUser user); void addNestead(PropagationUser user); void addNesteadException(PropagationUser user); } PropagationUserDao ： public interface PropagationUserDao { int insertSelective(PropagationUser record); // 省略... } 测试类： public class TransactionPropagationServiceTest { private TransactionPropagationService service; @Before public void before() { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext( GlobalTransactionConfig.class, AspectAnoForTransactionConfiguration.class); service = context.getBean(TransactionPropagationService.class); } } 具体的验证代码由 TransactionPropagationService 层实现，根据不同的传播行为分别列举。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:2:0","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"3 REQUIRED ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:3:0","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"3.1 外围方法未开启事务 验证方法 1 ：外围方法抛出异常 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionExceptionRequiredRequired() { userService.addRequired(new PropagationUser(\"张三\")); userService.addRequired(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2 ：内部方法抛出异常 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionRequiredRequiredException() { userService.addRequired(new PropagationUser(\"张三\")); userService.addRequiredException(new PropagationUser(\"李四\")); } } 分别执行验证方法，结果： 验证方法序号 执行结果 结果分析 1 “张三”插入，“李四”插入 外围方法未开启事务，“张三”、“李四”插入，外围方法异常不影响内部插入，“张三”、“李四”方法在独立的事务中运行。 2 “张三”插入，“李四”未插入 外围方法未开启事务，内部方法异常。“张三”插入，“李四”未插入，说明“张三”、“李四”方法是在不同的事务中运行。 结论：通过这两个方法，说明在外围方法不开启事务时，事务设置为 REQUIRED 传播行为的内部方法，都会新建事务。在不同的事务中运行，互不影响。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:3:1","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"3.2 外围方法开启事务 验证方法 1 ：外围方法抛出异常 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionExceptionRequiredRequired() { userService.addRequired(new PropagationUser(\"张三\")); userService.addRequired(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2 ：内部方法抛出异常 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionRequiredRequiredException() { userService.addRequired(new PropagationUser(\"张三\")); userService.addRequiredException(new PropagationUser(\"李四\")); } } 验证方法 3 ：内部方法抛出异常被外围捕获 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionRequiredRequiredCatchException() { userService.addRequired(new PropagationUser(\"张三\")); try { userService.addRequiredException(new PropagationUser(\"李四\")); } catch (Exception ignored) { } } } 分别执行验证方法，结果： 验证方法序号 执行结果 结果分析 1 “张三”未插入，“李四”未插入 外围方法开启事务，内部方法加入外围方法事务。外围方法回滚，内部方法也要回滚。 2 “张三”未插入，“李四”未插入 外围方法开启事务，内部方法加入外围方法事务。内部方法抛出异常回滚，外围方法感知到异常。 3 “张三”未插入，“李四”未插入 外围方法开启事务，内部方法加入到外围方法事务。内部方法抛出异常，传递到外围，外围方法捕获。由于在同一个事务中，所以总体回滚。 结论：以上结果表明，在外围方法开启事务，内部方法事务传播行为使用 REQUIRED 时，会加入到外围方法的事务。任何一个节点方法回滚，都会触发整体事务回滚。因为他们本就在同一个事务中。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:3:2","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"4 SUPPORTS ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:4:0","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"4.1 外围方法未开启事务 验证方法 1：外部方法抛出异常 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionExceptionSupportsSupports() { userService.addSupports(new PropagationUser(\"张三\")); userService.addSupports(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2：内部方法抛出异常 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionSupportsSupportsException() { userService.addSupports(new PropagationUser(\"张三\")); userService.addSupportsException(new PropagationUser(\"李四\")); } } 验证结果： 验证方法序号 执行结果 结果分析 1 “张三”插入，“李四”插入 外围方法未开启事务，外围方法抛出异常，内部方法均插入成功。说明内部方法要么没有事务，要么在独立的事务中。 2 “张三”插入，“李四”插入 外围方法未开启事务，内部方法抛出异常，内部方法均插入成功。说明内部方法没有开启事务。 结论：当外围方法未开启事务时，内部方法事务传播行为使用 SUPPORTS，那么内部方法会以非事务的方式运行。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:4:1","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"4.2 外围方法开启事务 验证方法 1：外部方法抛出异常 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionExceptionSupportsSupports() { userService.addSupports(new PropagationUser(\"张三\")); userService.addSupports(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2：内部方法抛出异常 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionSupportsSupportsException() { userService.addSupports(new PropagationUser(\"张三\")); userService.addSupportsException(new PropagationUser(\"李四\")); } } 验证方法 3：内部方法抛出异常被外围方法捕获 public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionSupportsSupportsCatchException() { userService.addRequired(new PropagationUser(\"张三\")); try { userService.addRequiredException(new PropagationUser(\"李四\")); } catch (Exception ignored) { } } } 验证结果： 验证方法序号 执行结果 结果分析 1 “张三”未插入，“李四”未插入 外围方法开启事务，内部方法加入到外围方法事务，外围方法抛出异常。事务回滚，内部方法插入数据均回滚。 2 “张三”未插入，“李四”未插入 外围方法开启事务，内部方法加入到外围方法事务，内部方法抛出异常，外围方法感知。事务回滚。 3 “张三”未插入，“李四”未插入 外围方法开启事务，内部方法加入到外围方法事务，内部方法抛出异常回滚，外围方法捕获。由于在同一个事务中，所以整体回滚。 结论：当外围方法开启事务，内部方法事务传播行为使用 SUPPORTS 时，会加入到外围方法的事务中，外围、内部方法逻辑代码，实际上是在一个事务内执行，任何一个方法抛出异常，都会回滚。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:4:2","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"5 MANDATORY 验证方法 1： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionMandatoryMandatory() { userService.addMandatory(new PropagationUser(\"张三\")); userService.addMandatory(new PropagationUser(\"李四\")); } } 验证方法 2： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionExceptionMandatoryMandatory() { userService.addMandatory(new PropagationUser(\"张三\")); userService.addMandatory(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 3： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionMandatoryMandatoryCatchException() { userService.addMandatory(new PropagationUser(\"张三\")); try { userService.addMandatoryException(new PropagationUser(\"李四\")); } catch (Exception ignored) { } } } 验证结果： 验证方法序号 执行结果 结果分析 1 ”张三“未插入，”李四“未插入，内部方法未执行，抛出IllegalTransactionStateException 外围方法未开启事务，内部方法在调用前就抛出了异常。说明只允许开启了事务的方法调用此方法，否则就会抛出异常。 2 “张三“未插入，”李四“未插入 外围方法开启事务，外围方法抛出异常。由于内部方法加入了外围方法事务，所以全部回滚。 3 “张三”未插入，“李四”未插入 外围方法开启事务，内部方法抛出异常。由于内部方法加入了外围方法事务，索引任何一个节点方法异常，都会回滚。 结论： 如果外围方法未开启事务，内部方法事务传播行为使用 Mandatory，会在调用被代理方法之前，事务切面抛出异常。 如果外围方法开启事务，内部方法会加入到外围方法的事务中。由于在同一个事务中，任何一个方法节点抛出异常，会全部回滚。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:5:0","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"6 REQUIRES_NEW ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:6:0","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"6.1 外围方法未开启事务 验证方法 1： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionExceptionRequiresNewRequiresNew() { userService.addRequiredNew(new PropagationUser(\"张三\")); userService.addRequiredNew(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionRequiresNewRequiresNewException() { userService.addRequiredNew(new PropagationUser(\"张三\")); userService.addRequiredNewException(new PropagationUser(\"李四\")); } } 验证结果： 验证方法序号 执行结果 结果分析 1 “张三”插入，“李四”插入 外围方法未开启事务，内部方法分别新建一个事务。外围方法异常，不影响内部方法独立开启的事务。 2 “张三”插入，“李四为插入 外围方法未开启事务，内部方法分别新建一个事务。由于两个内部方法事务是独立的，互不影响，所以只回滚了一个。 结论：外围方法未开启事务，内部方法事务传播行为如果使用 REQUIRES_NEW，那么内部方法总是会创建一个新的事务，在这个新的事务中执行自己的逻辑。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:6:1","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"6.2 外围方法开启事务 验证方法 1： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionExceptionRequiresNewRequiresNew() { userService.addRequiredNew(new PropagationUser(\"张三\")); userService.addRequiredNew(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionRequiresNewRequiresNewException() { userService.addRequiredNew(new PropagationUser(\"张三\")); userService.addRequiredNewException(new PropagationUser(\"李四\")); } } 验证方法 3： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionRequiresNewRequiresNewCatchException() { userService.addRequiredNew(new PropagationUser(\"张三\")); try { userService.addRequiredNewException(new PropagationUser(\"李四\")); } catch (Exception ignored) { } } } 验证结果： 验证方法序号 执行结果 结果分析 1 “张三”插入，”李四“插入 外围方法开启事务，内部方法在新建事务中运行。外围方法异常回滚，不影响内部方法独立的事务。 2 “张三”插入，“李四”未插入 外围方法开启事务，内部方法在新建事务中运行。“李四”方法抛出异常，外围方法感知，两个方法事务回滚。”张三“方法由于在独立的事务中，不受影响。 2 “张三”插入，“李四”未插入 外围方法开启事务，内部方法在新建事务中运行。“李四”方法抛出异常，外围方法捕获，”李四“方法事务回滚。”张三“方法由于在独立的事务中，不受影响。 结论：无论外围方法是否开启事务，事务传播行为使用 REQUIRES_NEW 的方法，总是会新启一个事务，在这个新的事务中执行内部逻辑。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:6:2","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"7 NOT_SUPPORTED ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:7:0","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"7.1 外围方法未开启事务 验证方法 1： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionExceptionNotSupportedNotSupported() { userService.addNotSupported(new PropagationUser(\"张三\")); userService.addNotSupported(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionNotSupportedNotSupportedException() { userService.addNotSupported(new PropagationUser(\"张三\")); userService.addNotSupportedException(new PropagationUser(\"李四\")); } } 验证结果： 验证方法序号 执行结果 结果分析 1 “张三”插入，“李四”插入 外围方法未开启事务，内部方法均未开启事务，所以外围方法抛出异常，都没有回滚。 2 “张三”插入，“李四”插入 外围方法未开启事务，内部方法均未开启事务，所以内部方法抛出异常，也没有回滚。 结论：外围方法未开启事务，内部方法事务传播行为如果使用 NOT_SUPPORTED，后者会在非事务的环境中运行。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:7:1","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"7.2 外围方法开启事务 验证方法 1： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionExceptionNotSupportedNotSupported() { userService.addNotSupported(new PropagationUser(\"张三\")); userService.addNotSupported(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionNotSupportedNotSupportedException() { userService.addNotSupported(new PropagationUser(\"张三\")); userService.addNotSupportedException(new PropagationUser(\"李四\")); } } 验证结果： 验证方法序号 执行结果 结果分析 1 “张三”插入，“李四”插入 外围方法开启事务，内部方法会将事务挂起，以非事务方式运行，所以外围方法回滚，内部方法不回滚。 2 “张三”插入，“李四”插入 外围方法开启事务，内部方法会将事务挂起，以非事务方式运行，所以外围方法回滚，内部方法不回滚。 结论：外围方法开启事务，内部方法事务传播行为如果使用 NOT_SUPPORTED，则后者会将外围方法的事务挂起，以非事务的方式运行。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:7:2","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"8 NEVER 验证方法 1： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionExceptionNeverNever() { userService.addNever(new PropagationUser(\"张三\")); userService.addNever(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionNeverNeverException() { userService.addNever(new PropagationUser(\"张三\")); userService.addNeverException(new PropagationUser(\"李四\")); } } 验证方法 3： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionNeverNever() { userService.addNever(new PropagationUser(\"张三\")); userService.addNever(new PropagationUser(\"李四\")); } } 验证结果： 验证方法序号 执行结果 结果分析 1 “张三”插入，“李四”插入 外围方法未开启事务，内部方法以非事务方式运行，因为根本就没有事务，外围方法抛出异常，也不会回滚。 2 “张三”插入，“李四”插入 外围方法未开启事务，内部方法以非事务方式运行，因为根本就没有事务，内部方法抛出异常，也不会回滚。 3 “张三”未插入，“李四”未插入 外围方法开启事务，内部方法未执行，在事务切面中抛出IllegalTransactionStateException，方法都没有执行，所以数据没有插入. 结论： 方法的事务传播行为使用 NEVER。外围方法未开启事务时，方法以非事务方式运行。外围方法开启事务时，直接抛出异常。 即这种方式的传播行为，调用者只能是未开启事务的，才可以调用，否则业务方法根本不会执行，直接抛出异常。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:8:0","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"9 NESTED ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:9:0","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"9.1 外围方法未开启事务 验证方法 1： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionExceptionNestedNested() { userService.addNestead(new PropagationUser(\"张三\")); userService.addNestead(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Override public void noTransactionNestedNestedException() { userService.addNestead(new PropagationUser(\"张三\")); userService.addNesteadException(new PropagationUser(\"李四\")); } } 验证结果： 验证方法序号 执行结果 结果分析 1 “张三”插入，“李四”插入 外围方法未开启事务，内部方法均开启一个新的事务，所以外围范方法抛出异常不影响两个独立的事务。 2 “张三”插入，“李四”未插入 外围方法未开启事务，内部方法各自开启新的事务，所以“李四”所在事务回滚。而“张三”插入。 结论：方法事务传播行为使用 NESTED，如果外围方法未开启事务，那么内部方法会各自开启自己的事务。 ","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:9:1","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"9.2 外围方法开启事务 验证方法 1： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionExceptionNestedNested() { userService.addNestead(new PropagationUser(\"张三\")); userService.addNestead(new PropagationUser(\"李四\")); throw new RuntimeException(); } } 验证方法 2： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionNestedNestedException() { userService.addNestead(new PropagationUser(\"张三\")); userService.addNesteadException(new PropagationUser(\"李四\")); } } 验证方法 3： public class TransactionPropagationServiceImpl implements TransactionPropagationService { @Transactional(rollbackFor = Exception.class) @Override public void transactionNestedNestedCatchException() { userService.addNestead(new PropagationUser(\"张三\")); try { userService.addNesteadException(new PropagationUser(\"李四\")); } catch (Exception ignore) { } } } 验证结果： 验证方法序号 执行结果 结果分析 1 “张三”未插入，“李四”未插入 外围方法开启事务，内部方法会在嵌套事务内执行，外围方法异常回滚，所有的嵌套事务都会回滚。 2 “张三”未插入，“李四”未插入 外围方法开启事务，内部方法会在嵌套事务内执行，“李四”插入抛出异常，外部方法感知异常，全部回滚。 3 “张三”插入，“李四”未插入 外围方法开启事务，内部方法在嵌套事务内执行，“李四”插入抛出异常回滚。外部方法捕获异常未抛出。所以只回滚局部的嵌套事务。 结论：一个方法事务传播行为使用 NESTED。外围方法未开启事务时，方法会新启一个事务。在外围方法开启事务时，方法会在嵌套事务内执行。 注意\r\r嵌套事务的特点：如果外围方法异常回滚，所有的嵌套事务都会回滚。如果某些节点的嵌套事务回滚，异常在外围方法中没有继续向上抛出，那么仅仅回滚异常的嵌套事务。 关于嵌套事务的实现原理，在事务源码中会详细列出。不只是嵌套事务，事务的其中传播行为源码实现流程都会详细列出。 \r\r","date":"2020-12-05","objectID":"/posts/spring/15-transaction-propagation-example/:9:2","tags":["spring源码"],"title":"15 声明式事务七种传播行为的表现形式案例","uri":"/posts/spring/15-transaction-propagation-example/"},{"categories":["spring"],"content":"事务以xml配置方式使用时，xml是怎么解析，并将事务功能注册到容器中的？注解方式启动时，是怎么扫描注解将事务功能注册到容器中的？本文给出了详细的解析。","date":"2020-12-03","objectID":"/posts/spring/14-transaction-xml-annotation-registry/","tags":["spring源码"],"title":"14 声明式事务中XML配置及注解方式的注册入口","uri":"/posts/spring/14-transaction-xml-annotation-registry/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 事务以xml配置方式使用时，xml是怎么解析，并将事务功能注册到容器中的？注解方式启动时，是怎么扫描注解将事务功能注册到容器中的？本文给出了详细的解析。 ","date":"2020-12-03","objectID":"/posts/spring/14-transaction-xml-annotation-registry/:0:0","tags":["spring源码"],"title":"14 声明式事务中XML配置及注解方式的注册入口","uri":"/posts/spring/14-transaction-xml-annotation-registry/"},{"categories":["spring"],"content":"1 xml方式 xml方式开启事务注解，是使用 \u003ctx:annotation-driven/\u003e 标签。根据 SPI 加载的规律，找到 spring-tx 包下的 spring.handlers 文件。 内容如下： http\\://www.springframework.org/schema/tx=org.springframework.transaction.config.TxNamespaceHandler 在 TxNamespaceHandler.init() 中，注册了事务相关标签的解析支持。 init() 源码如下： public class TxNamespaceHandler extends NamespaceHandlerSupport { public void init() { // advice通知方法有关的，\u003ctx:advice /\u003e \u003ctx:attributes /\u003e \u003ctx:method /\u003e 标签支持在这里。 registerBeanDefinitionParser(\"advice\", new TxAdviceBeanDefinitionParser()); // \u003ctx:annotation-driven /\u003e 解析支持 registerBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser()); // 可以不看。 registerBeanDefinitionParser(\"jta-transaction-manager\", new JtaTransactionManagerBeanDefinitionParser()); } } 着重看 \u003ctx:annotation-driven /\u003e 标签的解析类，\u003ctx:advice /\u003e 解析支持原理类似。 直接来到方法 parse()： class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser { public BeanDefinition parse(Element element, ParserContext parserContext) { // 当前方法注册了InfrastructureAdvisorAutoProxyCreator Infrastructure--\u003e基础设施，优先级最低。 // 注意：区分@Aspect以及\u003caop:aspectj-autoproxy/\u003e：两者注册的是AnnotationAwareAspectJAutoProxyCreator，最终按照优先级来确定使用哪个的。 // 注册事务事件监听器，@TransactionalEventListener注解的支持。可以不看。 registerTransactionalEventListenerFactory(parserContext); String mode = element.getAttribute(\"mode\"); // 根据mode的值，来确定注册哪种类型的事务支持。这个不常用，可以不看。着重看else里面的内容。 if (\"aspectj\".equals(mode)) { // mode=\"aspectj\" registerTransactionAspect(element, parserContext); if (ClassUtils.isPresent(\"javax.transaction.Transactional\", getClass().getClassLoader())) { registerJtaTransactionAspect(element, parserContext); } } else { // TODO 默认值是proxy，主要看这个。 // mode=\"proxy\" AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext); } return null; } } 代码第一行注册了事务的事件监听，可以不看。 实际开发中，mode 属性基本不会配置，直接略过。默认值是 proxy。也就是说，会走到else代码块中。重点看 configureAutoProxyCreator() private static class AopAutoProxyConfigurer { public static void configureAutoProxyCreator(Element element, ParserContext parserContext) { // TODO 注册Advisor AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element); // 这里是一个常量，事务Advisor，等后面实例化时，如果匹配到方法，Advisor会封装到代理对象的执行链里面。 String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME; if (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) { Object eleSource = parserContext.extractSource(element); // 创建AnnotationTransactionAttributeSource的BeanDefinition，这是一个策略接口的实现。用于获取事务注解的属性值。 // Create the TransactionAttributeSource definition. RootBeanDefinition sourceDef = new RootBeanDefinition( \"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource\"); sourceDef.setSource(eleSource); sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef); // 创建对应的MethodInterceptor，这是事务的方法拦截器，最终在生成代理的时候，会缓存到AdvisedSupport中，第一次调用执行生成执行链的时候， // 如果匹配对应的方法，就会将方法名-MethodInterceptor的映射关系存储到执行链。同样是缓存到AdvisedSupport中。 // Create the TransactionInterceptor definition. RootBeanDefinition interceptorDef = new RootBeanDefinition(TransactionInterceptor.class); interceptorDef.setSource(eleSource); interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); // 注意，这里只注入了一个名字，PlatformTransactionManager需要我们手动注入到容器，在创建TransactionInterceptor时，会通过getBean()来获取 registerTransactionManager(element, interceptorDef); interceptorDef.getPropertyValues().add(\"transactionAttributeSource\", new RuntimeBeanReference(sourceName)); String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef); // 创建BeanFactoryTransactionAttributeSourceAdvisor的BeanDefinition，并注册到registry中。当bean在实例化， // 查找容器中所有的增强方法时，会对所有的@Aspect封装成Advisor并实例化，以及直接注入进来的Advisor提前实例化，缓存到AdvisedSupport中。 // 从接口层面说，这里创建一个Advisor。 // Create the TransactionAttributeSourceAdvisor definition. RootBeanDefinition advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class); advisorDef.setSource(eleSource); advisorDe","date":"2020-12-03","objectID":"/posts/spring/14-transaction-xml-annotation-registry/:1:0","tags":["spring源码"],"title":"14 声明式事务中XML配置及注解方式的注册入口","uri":"/posts/spring/14-transaction-xml-annotation-registry/"},{"categories":["spring"],"content":"2 注解方式 在使用注解方式激活@Transaction支持时，使用的是@EnableTransactionManagement，在这个注解声明中可以看到，使用了@Import导入TransactionManagementConfigurationSelector。 源码如下： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented // TODO 重点：事务注册入口类 @Import(TransactionManagementConfigurationSelector.class) public @interface EnableTransactionManagement { // 省略... } 在spring容器启动时，就会加载TransactionManagementConfigurationSelector，调用 selectImports()，在这个方法中，就添加了两个类的支持。 selectImports() 源码如下： public class TransactionManagementConfigurationSelector extends AdviceModeImportSelector\u003cEnableTransactionManagement\u003e { @Override protected String[] selectImports(AdviceMode adviceMode) { switch (adviceMode) { case PROXY: return new String[] {AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()}; case ASPECTJ: return new String[] {determineTransactionAspectClass()}; default: return null; } } } 从上面源码中可以看到，共添加了两个类，主要看 ProxyTransactionManagementConfiguration 这个类。 在这个类中，定义了三个方法，使用@Bean，向容器中注入了BeanFactoryTransactionAttributeSourceAdvisor、TransactionInterceptor、AnnotationTransactionAttributeSource。这三个分别是Advisor、Advice（MethodInterceptor）、TransactionAttributeSource的实现类。 源码如下： @Configuration public class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration { @Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME) @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() { // 事务切面类 BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor(); advisor.setTransactionAttributeSource(transactionAttributeSource()); advisor.setAdvice(transactionInterceptor()); if (this.enableTx != null) { advisor.setOrder(this.enableTx.\u003cInteger\u003egetNumber(\"order\")); } return advisor; } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public TransactionAttributeSource transactionAttributeSource() { // TODO 事务属性解析类 return new AnnotationTransactionAttributeSource(); } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public TransactionInterceptor transactionInterceptor() { // 事务拦截器 TransactionInterceptor interceptor = new TransactionInterceptor(); interceptor.setTransactionAttributeSource(transactionAttributeSource()); if (this.txManager != null) { interceptor.setTransactionManager(this.txManager); } return interceptor; } } xml方式注入中，也是像容器中注入了这几个类。同样创建的流程也都是一样的。 接着看一下 AnnotationTransactionAttributeSource，在创建实例的时候，封装了对@Transactional的支持。 来到构造方法源码： public class AnnotationTransactionAttributeSource extends AbstractFallbackTransactionAttributeSource implements Serializable { // 步骤一 public AnnotationTransactionAttributeSource() { this(true); } // 步骤二 public AnnotationTransactionAttributeSource(boolean publicMethodsOnly) { // 这里注入了注解解析类。 SpringTransactionAnnotationParser，解析时就用到的这个类中的方法 this.publicMethodsOnly = publicMethodsOnly; if (jta12Present || ejb3Present) { this.annotationParsers = new LinkedHashSet\u003c\u003e(4); // TODO 重点看这里 this.annotationParsers.add(new SpringTransactionAnnotationParser()); if (jta12Present) { this.annotationParsers.add(new JtaTransactionAnnotationParser()); } if (ejb3Present) { this.annotationParsers.add(new Ejb3TransactionAnnotationParser()); } } else { this.annotationParsers = Collections.singleton(new SpringTransactionAnnotationParser()); } } } 在构造方法中，封装了SpringTransactionAnnotationParser对象。 这个类是对@Transactional注解的支持，在bean实例化完成之后，调用代理方法执行时，首先会生成执行链，然后按照索引顺序递归调用执行链。 在调用到事务的节点时，会获取事务属性对象，通过事务属性来被代理方法中@Transactional注解中配置的属性值。以此来判断是否开启事务、以及设置事务隔离级别、传播行为等属性值。 SpringTransactionAnnotationParser中具体有哪些方法，执行了哪些行为，在声明式事务执行流程源码分析中会详细列出。 ","date":"2020-12-03","objectID":"/posts/spring/14-transaction-xml-annotation-registry/:2:0","tags":["spring源码"],"title":"14 声明式事务中XML配置及注解方式的注册入口","uri":"/posts/spring/14-transaction-xml-annotation-registry/"},{"categories":["spring"],"content":"AOP中代理方法执行时，自定义切面通知方法的MethodInterceptor执行原理解析。","date":"2020-12-02","objectID":"/posts/spring/13-aop-method-interceptor-execute/","tags":["spring源码"],"title":"13 AOP 内置的五种MethodInterceptor源码解析","uri":"/posts/spring/13-aop-method-interceptor-execute/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-12-02","objectID":"/posts/spring/13-aop-method-interceptor-execute/:0:0","tags":["spring源码"],"title":"13 AOP 内置的五种MethodInterceptor源码解析","uri":"/posts/spring/13-aop-method-interceptor-execute/"},{"categories":["spring"],"content":"1 代理方法执行回顾 在代理对象方法被调用时，会获取到执行链，将其封装在 ProxyMethodInvocation 中，调用 proceed()，通过递归方式，依次调用执行链中的通知方法节点，最终会调用到代理方法，然后回转到调用处。回转过程中可能存在后置通知方法的节点调用，其顺序与前置的调用刚好相反。 多个切面通知方法，执行顺序实际上是环环相扣的，被代理方法在中间，与内存模型的栈有点类似，先进后出。 业务开发中我们自定义的切面共有五种，实际上并不是每种都常用。 列举这五种通知方法的MethodInterceptor实现类和对应注解： MethodBeforeAdviceInterceptor –\u003e @Before AspectJAroundAdvice –\u003e @Around AspectJAfterAdvice –\u003e @After AspectJAfterReturningAdvice –\u003e @AfterReturning AspectJAfterThrowingAdvice –\u003e @AfterThrowing ","date":"2020-12-02","objectID":"/posts/spring/13-aop-method-interceptor-execute/:1:0","tags":["spring源码"],"title":"13 AOP 内置的五种MethodInterceptor源码解析","uri":"/posts/spring/13-aop-method-interceptor-execute/"},{"categories":["spring"],"content":"2 MethodBeforeAdviceInterceptor MethodBeforeAdviceInterceptor.invoe() 中，封装了 MethodBeforeAdvice，在这个 Advice 中，通过调用 before()，来完成通知方法的调用。 首先会调用 before()，接着，调用 MethodInvocation.proceed()。继续向下递归，直到执行链的末尾，调用被代理方法，然后返回。 源码如下： public class MethodBeforeAdviceInterceptor implements MethodInterceptor, BeforeAdvice, Serializable { // 封装了前置通知方法的具体执行内容。 private final MethodBeforeAdvice advice; @Override public Object invoke(MethodInvocation mi) throws Throwable { // 调用advice.before()，执行内容封装的前置通知方法。调用MethodInvocation.proceed()，火炬传递。实际上就是一个递归调用。 this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis()); return mi.proceed(); } } 来到 before() ： public class AspectJMethodBeforeAdvice extends AbstractAspectJAdvice implements MethodBeforeAdvice, Serializable { @Override public void before(Method method, Object[] args, @Nullable Object target) throws Throwable { // 前置增强知识调用切面通知方法，并未理会参数中传递的目标对象、参数列表、以及方法 invokeAdviceMethod(getJoinPointMatch(), null, null); } } 参数 JoinPointMatch 暂且忽略。 继续往下跟踪源码： public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable { protected Object invokeAdviceMethod( @Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex) throws Throwable { // 获取到绑定参数，调用通知方法。 return invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex)); } } 上面源码中有两个关键方法，invokeAdviceMethodWithGivenArgs()、argBinding()。它们的作用分别是执行通知方法、获取通知方法的参数。 由于五种拦截器调用和获取参数绑定的逻辑都是相同的方法，这两个方法放到后面列出。 ","date":"2020-12-02","objectID":"/posts/spring/13-aop-method-interceptor-execute/:2:0","tags":["spring源码"],"title":"13 AOP 内置的五种MethodInterceptor源码解析","uri":"/posts/spring/13-aop-method-interceptor-execute/"},{"categories":["spring"],"content":"3 AspectJAroundAdvice 进入 invoke() 源码： public class AspectJAroundAdvice extends AbstractAspectJAdvice implements MethodInterceptor, Serializable { @Override public Object invoke(MethodInvocation mi) throws Throwable { ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi; ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi); JoinPointMatch jpm = getJoinPointMatch(pmi); // 执行环绕通知方法，注意，这里相对AspectJAfterAdvice，多传递了了一个参数pjp，这里是一个MethodInvocationProceedingJoinPoint， // 内部封装了代理调用对象ProxyMethodInvocation。也就是说，在环绕通知方法中，是可以拿到ProxyMethodInvocation，并可以在其方法任意位置 // 进行执行链的火炬传递。 return invokeAdviceMethod(pjp, jpm, null, null); } } 来到 lazyGetProceedingJoinPoint()： public class AspectJAroundAdvice extends AbstractAspectJAdvice implements MethodInterceptor, Serializable { protected ProceedingJoinPoint lazyGetProceedingJoinPoint(ProxyMethodInvocation rmi) { return new MethodInvocationProceedingJoinPoint(rmi); } } 在 new MethodInvocationProceedingJoinPoint(rmi) 参数中，传递了一个 ProxyMethodInvocation，这个类是用来调用执行链中通知方法的。这里把它封装到了ProceedingJoinPoint中。 在 invokeAdviceMethod() 中将这个创建的 ProceedingJoinPoint 传递下去。我们在使用 @Around 时，会将 ProceedingJoinPoint 作为通知方法的参数，这个参数就来自这里。 接着，会执行到 invokeAdviceMethod()： public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable { protected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable t) throws Throwable { // 获取到绑定参数，调用通知。 return invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t)); } } 最终，这里有两个方法调用，invokeAdviceMethodWithGivenArgs()、argBinding()。 ","date":"2020-12-02","objectID":"/posts/spring/13-aop-method-interceptor-execute/:3:0","tags":["spring源码"],"title":"13 AOP 内置的五种MethodInterceptor源码解析","uri":"/posts/spring/13-aop-method-interceptor-execute/"},{"categories":["spring"],"content":"4 AspectJAfterAdvice invoke() 源码： public class AspectJAfterAdvice extends AbstractAspectJAdvice implements MethodInterceptor, AfterAdvice, Serializable { @Override public Object invoke(MethodInvocation mi) throws Throwable { try { // 先执行执行链，当所有执行链中的通知方法，及被代理方法执行完毕，会继续往下走。 // 最终，在finally语句块中，调用后置通知方法。卸载finally语句块里，是让在执行链中及被代理方法执行完毕，但还未返回时，执行后置通知方法。 // 这里有点绕。 A(around) -\u003e B(after) -\u003e C(around)，假设有这三个切面组成执行链，他们执行顺序按照前面的排序。 // 执行顺序是这样的：A环绕前置通知 -\u003e B invoke中通知调用执行链下一个节点（这里没有实际的执行内容，只是做一个火炬传递） -\u003e C环绕前置通知 -\u003e C环绕后置通知 -\u003e B后置通知（这时候B中调用完，返回前掉finally语句块） -\u003e A环绕后置通知。 return mi.proceed(); } finally { invokeAdviceMethod(getJoinPointMatch(), null, null); } } } 先将执行链中剩余节点执行完毕，在执行完之后，方法返回之前，finally块中调用了后置通知方法。仔细看下源码中注释部分。 接着到 invokeAdviceMethod()，与前面的一致，都是到这个方法： public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable { protected Object invokeAdviceMethod( @Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex) throws Throwable { // 获取到绑定参数，调用通知方法。 return invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex)); } } ","date":"2020-12-02","objectID":"/posts/spring/13-aop-method-interceptor-execute/:4:0","tags":["spring源码"],"title":"13 AOP 内置的五种MethodInterceptor源码解析","uri":"/posts/spring/13-aop-method-interceptor-execute/"},{"categories":["spring"],"content":"5 AfterReturningAdviceInterceptor 先调用执行链中剩余节点，拿到返回值之后，再调用 afterReturning() 通知方法。afterReturning() 中一样会调到 invokeAdviceMethod()。 public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable { @Override public Object invoke(MethodInvocation mi) throws Throwable { // 首先执行执行链方法，当执行链中的通知方法、及被代理方法都执行完毕。才执行afterReturning方法。 Object retVal = mi.proceed(); // 执行afterReturning通知方法。 this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis()); return retVal; } } afterReturning() 源码： public class AspectJAfterReturningAdvice extends AbstractAspectJAdvice implements AfterReturningAdvice, AfterAdvice, Serializable { @Override public void afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target) throws Throwable { if (shouldInvokeOnReturnValueOf(method, returnValue)) { invokeAdviceMethod(getJoinPointMatch(), returnValue, null); } } } 这里会传入 returnValue。 ","date":"2020-12-02","objectID":"/posts/spring/13-aop-method-interceptor-execute/:5:0","tags":["spring源码"],"title":"13 AOP 内置的五种MethodInterceptor源码解析","uri":"/posts/spring/13-aop-method-interceptor-execute/"},{"categories":["spring"],"content":"6 AspectJAfterThrowingAdvice 调用执行链中剩余的节点通知，当这些通知方法抛出异常，就执行当前通知方法。invokeAdviceMethod() 中会调用 invokeAdviceMethod()。 public class AspectJAfterThrowingAdvice extends AbstractAspectJAdvice implements MethodInterceptor, AfterAdvice, Serializable { @Override public Object invoke(MethodInvocation mi) throws Throwable { try { // 调用执行链，如果执行链中的剩余节点中，有任何一个节点抛出异常，在这里捕获，在catch语句块传递给afterThrowing通知方法。 return mi.proceed(); } catch (Throwable ex) { if (shouldInvokeOnThrowing(ex)) { invokeAdviceMethod(getJoinPointMatch(), null, ex); } throw ex; } } } 这里传入了异常对象。 ","date":"2020-12-02","objectID":"/posts/spring/13-aop-method-interceptor-execute/:6:0","tags":["spring源码"],"title":"13 AOP 内置的五种MethodInterceptor源码解析","uri":"/posts/spring/13-aop-method-interceptor-execute/"},{"categories":["spring"],"content":"7 argBinding() 参数绑定 以下是 argBinding() 源码： public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable { protected Object[] argBinding(JoinPoint jp, @Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex) { // 计算参数绑定 calculateArgumentBindings(); // AMC start Object[] adviceInvocationArgs = new Object[this.parameterTypes.length]; int numBound = 0; // 如果存在参数JointPoint，则在这里放入参数。 if (this.joinPointArgumentIndex != -1) { adviceInvocationArgs[this.joinPointArgumentIndex] = jp; numBound++; }// 如果存在参数JoinPoint.StaticPart，则在这里绑定 else if (this.joinPointStaticPartArgumentIndex != -1) { adviceInvocationArgs[this.joinPointStaticPartArgumentIndex] = jp.getStaticPart(); numBound++; } // 省略... return adviceInvocationArgs; } } adviceInvocationArgs[this.joinPointArgumentIndex] = jp 设置了 JoinPoint 参数。 看一下calculateArgumentBindings() 都做了什么： public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable { public final synchronized void calculateArgumentBindings() { if (this.argumentsIntrospected || this.parameterTypes.length == 0) { return; } int numUnboundArgs = this.parameterTypes.length; // 获取切面通知方法的参数列表 Class\u003c?\u003e[] parameterTypes = this.aspectJAdviceMethod.getParameterTypes(); // 从这里可以看出，方法的第一个参数必须是JoinPoint类型的 if (maybeBindJoinPoint(parameterTypes[0]) || maybeBindProceedingJoinPoint(parameterTypes[0]) || maybeBindJoinPointStaticPart(parameterTypes[0])) { numUnboundArgs--; } // 类似这种 @Around(\"pc1()\") around(ProceedingJoinPoint joinPoint) // 方法只有一个参数，numUnboundArgs是0，就不需要参数绑定了 if (numUnboundArgs \u003e 0) { // 需要通过切入点匹配返回的名称绑定参数 // need to bind arguments by name as returned from the pointcut match bindArgumentsByName(numUnboundArgs); } this.argumentsIntrospected = true; } } 获取通知方法参数的个数赋值给 numUnboundArgs，获取到通知方法的所有参数类型。 拿第一个参数，去判断是否符合条件，如果符合条件，将变量 numUnboundArgs 减一。 如果方法中参数有多个，需要调用 bindArgumentsByName()。 看一下 maybeBindJoinPoint()，另外两个方法与这个类似： public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable { private boolean maybeBindJoinPoint(Class\u003c?\u003e candidateParameterType) { if (JoinPoint.class == candidateParameterType) {// 如果候选的参数类型是JoinPoint类型，则返回true，标识绑定成功。 this.joinPointArgumentIndex = 0; return true; }else { return false; } } } bindArgumentsByName会调用到bindExplicitArguments() ： public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable { private void bindExplicitArguments(int numArgumentsLeftToBind) { Assert.state(this.argumentNames != null, \"No argument names available\"); this.argumentBindings = new HashMap\u003c\u003e(); // 获取参数的数量 int numExpectedArgumentNames = this.aspectJAdviceMethod.getParameterCount(); // 省略... // 参数索引偏移量，也就是前面已经绑定过的参数，需要跳过，这里记录的是跳过已绑定参数后的下一个索引值。 int argumentIndexOffset = this.parameterTypes.length - numArgumentsLeftToBind; for (int i = argumentIndexOffset; i \u003c this.argumentNames.length; i++) { this.argumentBindings.put(this.argumentNames[i], i); } // 省略部分代码... // 把参数对应的名称和对应的参数的类型设置到pointcut中 // configure the pointcut expression accordingly. configurePointcutParameters(this.argumentNames, argumentIndexOffset); } } 获取到参数索引偏移量，这个偏移量是指前面已绑定的 JoinPoint。 来到 configurePointcutParameters() ： public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable { private void configurePointcutParameters(String[] argumentNames, int argumentIndexOffset) { int numParametersToRemove = argumentIndexOffset; if (this.returningName != null) { numParametersToRemove++; } if (this.throwingName != null) { numParametersToRemove++; } // 这里装的是参数名称，排除了已绑定的JoinPoint String[] pointcutParameterNames = new String[argumentNames.length - numParametersToRemove]; Class\u003c?\u003e[] pointcutParameterTypes = new Class\u003c?\u003e[pointcutParameterNames.length]; Class\u003c?\u003e[] methodParameterTypes = this.aspectJAdviceMethod.getParameterTypes(); int index = 0; for (int i = 0; i \u003c argumentNames.length; i++) { if (i \u003c argumentIndexOffset) { continue; } i","date":"2020-12-02","objectID":"/posts/spring/13-aop-method-interceptor-execute/:7:0","tags":["spring源码"],"title":"13 AOP 内置的五种MethodInterceptor源码解析","uri":"/posts/spring/13-aop-method-interceptor-execute/"},{"categories":["spring"],"content":"8 invokeAdviceMethodWithGivenArgs() 通知方法调用 通过反射，根据绑定的参数，方法，切面类，进行通知方法调用。 public abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation, Serializable { protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable { Object[] actualArgs = args; if (this.aspectJAdviceMethod.getParameterCount() == 0) { actualArgs = null; } // 省略try块... ReflectionUtils.makeAccessible(this.aspectJAdviceMethod); // 根据绑定的参数，反射调用通知方法。 // TODO AopUtils.invokeJoinpointUsingReflection return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs); } } 不同种类的 MethodInterceptor，有不同的实现，而最终调用时，都是通过反射进行方法调用的。 ","date":"2020-12-02","objectID":"/posts/spring/13-aop-method-interceptor-execute/:8:0","tags":["spring源码"],"title":"13 AOP 内置的五种MethodInterceptor源码解析","uri":"/posts/spring/13-aop-method-interceptor-execute/"},{"categories":["spring"],"content":"AOP 中代理对象生成后，在调用代理方法时，以 JDK 动态代理为例，执行链的生成、执行链火炬传递式的调用源码解析。","date":"2020-12-01","objectID":"/posts/spring/12-aop-proxy-execute-processor/","tags":["spring源码"],"title":"12 AOP 执行链的创建和执行原理","uri":"/posts/spring/12-aop-proxy-execute-processor/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-12-01","objectID":"/posts/spring/12-aop-proxy-execute-processor/:0:0","tags":["spring源码"],"title":"12 AOP 执行链的创建和执行原理","uri":"/posts/spring/12-aop-proxy-execute-processor/"},{"categories":["spring"],"content":"1 主流程 以 jdk 动态代理为例，在代理对象生成后，会加入到 ioc 容器中。当有代码调用到对应的方法时，会走到 InvocationHandler 的 invoke()。 在 spring-aop 模块中，jdk动态代理是在 JdkDynamicAopProxy.getProxy() 中生成的。在生成代理对象时，Proxy.newProxyInstance() 中第三个参数传入的是 this，JdkDynamicAopProxy本身也是 InvocationHandler 的实现类。那么，在调用代理对象方法时，一定会调用到 JdkDynamicAopProxy.invoke()。 来到 invoke() 源码： final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { MethodInvocation invocation; // 存储在调用方法之前，当前线程中的方法调用链中的上一个代理对象。 // 比如 代理A -\u003e 代理B -\u003e 当前代理方法。那么方法内 oldProxy 会存储前面的代理对象。因为在这个方法执行完之前，会将 // 一个全局的ThreadLocal变量置换为当前的代理对象，旧的值需要缓存起来，等到当前方法执行结束，再设置回原值。 Object oldProxy = null; boolean setProxyContext = false; // 从代理工厂中拿到TargetSource对象，该对象包装了被代理实例bean TargetSource targetSource = this.advised.targetSource; Object target = null; try { // 被代理对象的equals方法和hashCode方法不被代理的，不会走切面，此处代码省略... Object retVal; // 如果需要暴露代理对象（在配置文件或者注解中全局配置的），则将当前代理对象放入到一个全局的ThreadLocal变量中。 if (this.advised.exposeProxy) { oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; } // 这个target就是被代理实例 target = targetSource.getTarget(); Class\u003c?\u003e targetClass = (target != null ? target.getClass() : null); // 从代理工厂中拿过滤器链 Object是一个MethodInterceptor类型的对象，其实就是一个advice对象，或者说是MethodInterceptor List\u003cObject\u003e chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); // 如果该方法没有执行链，则说明这个方法不需要被拦截，则直接反射调用。 // 因为执行链不论是否为空，都会被缓存到一个ConcurrentHashMap中，执行只有第一次相对较慢。 if (chain.isEmpty()) { Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); // 这里返回了method.invoke()执行后的返回值。 retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse); } else { // 这里面调用了执行链，在执行链的调用中，会进行火炬传递。具体执行流程，重点在ReflectiveMethodInvocation.proceed()。 invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); // 在递归结束后，这里最终也会返回实际方法的返回值。火炬传递的过程，实际上也是递归，只是将ReflectiveMethodInvocation // 本身当做参数不断地向下传递。 retVal = invocation.proceed(); } // 省略无关代码... return retVal; }finally { // 单例情况下，targetSource类型是SingletonTargetSource，这个类中的releaseTarget是个空方法，不用看。 if (target != null \u0026\u0026 !targetSource.isStatic()) { targetSource.releaseTarget(target); }// 如果配置了允许暴露代理对象，在前面设置ThreadLocal变量时，会把局部变量setProxyContext设置为true if (setProxyContext) { // 将旧的代理对象设置到当前代理对象中，这里和执行链火炬传递式无关的。 // 如果当前代理方法是从一个代理对象方法内调用过来的，那么这个ThreadLocal变量中是有值的，执行当前代理对象方法时， // 设置为当前的代理对象，执行完后，需要重新设置回原来的代理对象，这样才不会乱套。 // 其用途是，当项目中配置允许暴露代理对象时，可以通过AopContext.currentProxy() 来获取到当前线程正在执行的代理对象。 // Restore old proxy. AopContext.setCurrentProxy(oldProxy); } } } } 以上代码有点长，删去了一些非关键点的代码。着重看代码中高亮部分，这些是关键节点。 invoke() 的主流程： 如果允许暴露代理对象，将 ThreadLocal 类型的全局变量 currentProxy 设置为当前代理对象，将旧的代理对象放到局部变量 oldProxy 中，setProxyContext 设置为 true。 获取通知方法执行链。（执行链的构建） 如果执行链不为空，将其封装到 ReflectiveMethodInvocation 中，调用 proceed()。（执行链递归调用的火炬传递） 如果有必要，全局变量 currentProxy 还原为调入当前方法时的状态。 第1、4条相对简单，主要是第2、3条相对复杂些。 ","date":"2020-12-01","objectID":"/posts/spring/12-aop-proxy-execute-processor/:1:0","tags":["spring源码"],"title":"12 AOP 执行链的创建和执行原理","uri":"/posts/spring/12-aop-proxy-execute-processor/"},{"categories":["spring"],"content":"2 执行链的构建 来到 getInterceptorsAndDynamicInterceptionAdvice()： public class AdvisedSupport extends ProxyConfig implements Advised { public List\u003cObject\u003e getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class\u003c?\u003e targetClass) { MethodCacheKey cacheKey = new MethodCacheKey(method); List\u003cObject\u003e cached = this.methodCache.get(cacheKey); if (cached == null) { // 根据Method来获取执行链。将获取到的执行链加入到缓存中，键值是根据MethodCacheKey，实际上包装的就是Method对象。 cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice( this, method, targetClass); this.methodCache.put(cacheKey, cached); } return cached; } } 这里使用了一个并发安全的map作为缓存，因为执行链的构建相对还是比较耗时的（相对 ConcurrentHashMap 的 get()），构建工作只执行一次，后面都是从缓存中获取。 往下追踪代码： public class DefaultAdvisorChainFactory implements AdvisorChainFactory, Serializable { @Override public List\u003cObject\u003e getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, @Nullable Class\u003c?\u003e targetClass) { AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); Advisor[] advisors = config.getAdvisors(); List\u003cObject\u003e interceptorList = new ArrayList\u003c\u003e(advisors.length); Class\u003c?\u003e actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()); Boolean hasIntroductions = null; for (Advisor advisor : advisors) { if (advisor instanceof PointcutAdvisor) { PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) { MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); boolean match; // 省略部分代码... match = mm.matches(method, actualClass); if (match) { // TODO 重点 获取MethodInterceptor列表。 MethodInterceptor[] interceptors = registry.getInterceptors(advisor); if (mm.isRuntime()) { // Creating a new object instance in the getInterceptors() method // isn't a problem as we normally cache created chains. for (MethodInterceptor interceptor : interceptors) { interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); } } else { interceptorList.addAll(Arrays.asList(interceptors)); } } } } // 省略... } return interceptorList; } } 从 Advised 中拿到 advisors，里面包含了前面流程搜集的所有通知方法包装的 Advisor，对其遍历，对 PointcutAdvisor 类型的执行方法匹配，匹配为 true，调用 getInterceptors()，将获取到的 MethodInterceptor 封装到 list 中。 下次再调用到当前方法时，从缓存中直接获取的就是这个 MethodInterceptor 列表。 来到 getInterceptors()，看一下是怎么获取的： public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable { public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException { // 从Advice获取MethodInterceptor。before、afterReturning的增强会被AdvisorAdapter匹配到。 // 其他自定义的增强方法，都是MethodInterceptor类型，被强转后，直接加入到interceptors中。 List\u003cMethodInterceptor\u003e interceptors = new ArrayList\u003c\u003e(3); Advice advice = advisor.getAdvice(); // 如果是MethodInterceptor，将其添加到拦截器链中 if (advice instanceof MethodInterceptor) { interceptors.add((MethodInterceptor) advice); } // 如果有AdviceorAdapter支持当前advice，进行适配，获取interceptor。adapters变量的值，是在无参构造函数中初始化的。 for (AdvisorAdapter adapter : this.adapters) { if (adapter.supportsAdvice(advice)) { interceptors.add(adapter.getInterceptor(advisor)); } } if (interceptors.isEmpty()) { throw new UnknownAdviceTypeException(advisor.getAdvice()); } return interceptors.toArray(new MethodInterceptor[0]); } } 上面代码流程： 从 advisor 中获取 Advice 对象，如果这个 Advice 是 MethodInterceptor 类型，则直接添加到 interceptors 中 遍历 adapters，如果支持当前 Advice，使用 getInterceptor 获取对应的 MethodInterceptor（至于adapters存储了什么，在哪里初始化的，前文中有）。 将 interceptors 转换为数组返回。 这里看两个典型的getInterceptor得实现。 @Before 注解的通知方法： class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable { // 是否支持指定的 Advice @Override public boolean supportsAdvice(Advice advice) { return (advice instanceof MethodBeforeAdvice); } // 从Advisor中获取Advice，并封装到MethodBeforeAdviceInterceptor @Override public MethodInterceptor getInterceptor(Advisor advisor) { MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice(); return new MethodBeforeAdviceInterceptor(advice); } } @AfterReturning 注解的通知方法： cl","date":"2020-12-01","objectID":"/posts/spring/12-aop-proxy-execute-processor/:2:0","tags":["spring源码"],"title":"12 AOP 执行链的创建和执行原理","uri":"/posts/spring/12-aop-proxy-execute-processor/"},{"categories":["spring"],"content":"3 执行链递归调用的火炬传递 构建完执行链之后，就是执行了。 从主流程源码中已经知道，真正的执行是在 proceed() 中进行的。 看一下 proceed() 源码： public class ReflectiveMethodInvocation implements ProxyMethodInvocation, Cloneable { // 当前执行链的索引，标识执行到哪一个通知方法了。 private int currentInterceptorIndex = -1; public Object proceed() throws Throwable { // We start with an index of -1 and increment early. // 如果执行链中的advice全部执行完，则直接调用joinPoint方法，就是被代理方法。 // 这里的成员变量currentInterceptorIndex会记录目前执行到哪一个增强方法了。 // 最终一定会返回代理方法的返回值，因为没有其他路径返回了，其他路径都是递归调用。 if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) { return invokeJoinpoint(); } // 执行到这个方法，说明进入到了增强方法，当前执行的索引+1，当执行到最后一个时，此值会与执行链的长度-1相等，这时候就会调用被代理方法。 Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); // 这段不用看，直接看else里面的代码。 if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) { // 省略... } else { // 调用MethodInterceptor中的invoke方法,并将自身作为参数向下传递，这里就是个火炬传递的过程。 // It's an interceptor, so we just invoke it: The pointcut will have // been evaluated statically before this object was constructed. return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); } } } 已经知道，我们定义的切面通知方法，在执行链中都被封装为 MethodInterceptor 类型了。 注意成员变量 currentInterceptorIndex，它是用来标识执行链执行到哪个节点了。初始值是-1，每调用一个通知方法都会自增，当达到执行链的末尾，就会通过反射执行被代理方法。 执行到上面源码方法末尾时，会调用执行链中索引为 ++this.currentInterceptorIndex 节点的 MethodInterceptor，执行 invoke(this)，注意这个 invoke(this) 中的参数，将 this 传递进去，也就是说每一个 MethodInterceptor 都持有了 ReflectiveMethodInvocation。而调用执行链是通过调用 ReflectiveMethodInvocation.proceed()。 ","date":"2020-12-01","objectID":"/posts/spring/12-aop-proxy-execute-processor/:3:0","tags":["spring源码"],"title":"12 AOP 执行链的创建和执行原理","uri":"/posts/spring/12-aop-proxy-execute-processor/"},{"categories":["spring"],"content":"4 总结 执行链的缓存是在 AdvisedSupport 中封装的，成员变量名 methodCache。执行链的构建是在 AdvisorChainFactory 的实现类 DefaultAdvisorChainFactory 中完成的，AdvisedSupport 中有成员变量 advisorChainFactory。AdvisedSupport 负责缓存和获取执行链，AdvisorChainFactory负责构建执行链。 AdvisedSupport 中缓存了所有的 Advisor，在调用代理方法时，第一次调用会计算有哪些 Advisor 匹配到这个代理方法，将匹配到的 Advisor 获取到 Advice，转换为 MethodInterceptor，封装到执行链中，并将 方法名-执行链 缓存到 methodCache 中，methodCache 是一个 ConcurrentHashMap（并发安全的map）。后面再调用会从 methodCache 中获取。 调用代理方法时，火炬传递式的递归执行，这个操作封装在 ReflectiveMethodInvocation 类中，也就是说 ReflectiveMethodInvocation 负责代理方法的执行。其执行逻辑是递归调用自身，每次调用取执行链中下一个索引的通知方法，并将自身作为参数在通知方法中传递，直至执行链末尾，调用完被代理方法，返回被代理方法执行后的返回值。 之所以这么做，也是为了解耦。充分体现了开发原则中的单一职责原则（一个类只干一件事，也是最重要的一个原则，其他原则都是为其展开的）。 使用 currentInterceptorIndex 索引来标识执行节点的位置的好处：不用在具体节点中，关心执行链参数是什么、以及如何传递的，可以看到 ReflectiveMethodInvocation.proceed() 是一个无参数的方法。 至于为什么在构建执行链的时候，要把所有类型的 Advice 都封装成 MethodInterceptor ？设想一下，如果不这么做，在火炬传递的过程中，会存在大量的 if 语句，且会在一定程度丧失扩展性。这也是策略模式的一种体现，消除了大量 if 语句，且使得代码变得可扩展。 至于执行链中每一个节点是如何执行，并将 ReflectiveMethodInvocation 向下传递的，在别的章节说明。 附 - 感想 spring 真的是将代码写成了艺术。不愧是音乐学博士写出的代码，真的很优雅。 附 - 递归的定义（来源百度百科） 程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有 直接或间接 调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。 ","date":"2020-12-01","objectID":"/posts/spring/12-aop-proxy-execute-processor/:4:0","tags":["spring源码"],"title":"12 AOP 执行链的创建和执行原理","uri":"/posts/spring/12-aop-proxy-execute-processor/"},{"categories":["spring"],"content":"AOP 代理实例的创建","date":"2020-12-01","objectID":"/posts/spring/11-aop-proxy-create-processor/","tags":["spring源码"],"title":"11 AOP 代理实例的创建","uri":"/posts/spring/11-aop-proxy-create-processor/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-12-01","objectID":"/posts/spring/11-aop-proxy-create-processor/:0:0","tags":["spring源码"],"title":"11 AOP 代理实例的创建","uri":"/posts/spring/11-aop-proxy-create-processor/"},{"categories":["spring"],"content":"1 创建实例的流程 创建代理实例在 createProxy() 中进行。 createProxy() 中有两个比较关键的方法： buildAdvisors() getProxy() 源码如下： public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware { protected Object createProxy(Class\u003c?\u003e beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) { // 省略... // 注意这个ProxyFactory，里面封装了 Advisors ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); // 省略... // TODO 重点：构建增强对象，这里会在原有的Advisor列表中，增加存在的MethodInterceptor Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) { proxyFactory.setPreFiltered(true); } // TODO 重点：生成代理对象 return proxyFactory.getProxy(getProxyClassLoader()); } } ","date":"2020-12-01","objectID":"/posts/spring/11-aop-proxy-create-processor/:1:0","tags":["spring源码"],"title":"11 AOP 代理实例的创建","uri":"/posts/spring/11-aop-proxy-create-processor/"},{"categories":["spring"],"content":"2 构建Advisor - buildAdvisors 来到 buildAdvisors() 源码： public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware { protected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors) { // Handle prototypes correctly... // 获取已有的方法拦截器，名称，并包装成Advisor Advisor[] commonInterceptors = resolveInterceptorNames(); List\u003cObject\u003e allInterceptors = new ArrayList\u003c\u003e(); if (specificInterceptors != null) { allInterceptors.addAll(Arrays.asList(specificInterceptors)); if (commonInterceptors.length \u003e 0) { if (this.applyCommonInterceptorsFirst) { allInterceptors.addAll(0, Arrays.asList(commonInterceptors)); } else { allInterceptors.addAll(Arrays.asList(commonInterceptors)); } } } // 省略部分代码... Advisor[] advisors = new Advisor[allInterceptors.size()]; for (int i = 0; i \u003c allInterceptors.size(); i++) { // 在这里进行构建的，最终，所有的通知方法都会封装成Advisor。 // 实际上我们自己定义的切面，到这里时，都已经是Advisor了，没有做任何处理直接返回了。 // 之所以在这里要再进行封装，是因为Spring中涉及过多的拦截器，增强器，增强方法等方式来对逻辑进行增强， // 有些情况allInterceptors中可能存在Advice对象，所以非常有必要统一封装成Advisor advisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i)); } return advisors; } } 从源码中可以看出，首选获取了一个 Advisor 数组，然后与之前搜集好的 Advisor 数组进行合并。 对合并后的结果进行遍历，然后调用 advisorAdapterRegistry.wrap()，wrap() 方法的作用，源码注释中有详细说明。 简单看一下 resolveInterceptorNames() 的过程： public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware { private Advisor[] resolveInterceptorNames() { BeanFactory bf = this.beanFactory; ConfigurableBeanFactory cbf = (bf instanceof ConfigurableBeanFactory ? (ConfigurableBeanFactory) bf : null); List\u003cAdvisor\u003e advisors = new ArrayList\u003c\u003e(); // 这里会根据interceptorNames中存储的拦截器名称，获取到对应的bean实例，最终包装成Advisor，添加到列表中返回。 for (String beanName : this.interceptorNames) { if (cbf == null || !cbf.isCurrentlyInCreation(beanName)) { Assert.state(bf != null, \"BeanFactory required for resolving interceptor names\"); Object next = bf.getBean(beanName); advisors.add(this.advisorAdapterRegistry.wrap(next)); } } return advisors.toArray(new Advisor[0]); } } 代码流程是：首先对 interceptorNames 进行遍历，依次对其进行 getBean 操作，然后使用 advisorAdapterRegistry.wrap() 将其包装成 Advisor。 来到 advisorAdapterRegistry.wrap()： public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable { public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException { //如果要封装的对象本身就是Advisor类型的，无须做任何处理 if (adviceObject instanceof Advisor) { return (Advisor) adviceObject; } //因为此封装只对Advisor和Advice两种类型的数据有效，如果不是将不能封装 if (!(adviceObject instanceof Advice)) { throw new UnknownAdviceTypeException(adviceObject); } Advice advice = (Advice) adviceObject; if (advice instanceof MethodInterceptor) { //如果是MethodInterceptor类型则使用DefaultPointcutrAdvisor封装 // So well-known it doesn't even need an adapter. return new DefaultPointcutAdvisor(advice); } // 如果存在Advisor类型的适配器那么也同样需要进行封装 for (AdvisorAdapter adapter : this.adapters) { // Check that it is supported. // @Before,@After使用的DefaultPointcutAdvisor if (adapter.supportsAdvice(advice)) { return new DefaultPointcutAdvisor(advice); } } throw new UnknownAdviceTypeException(advice); } } 上面源码逻辑比较简单： 首先判断传入的实例是否为 Advisor 实现类，如果为 true 不作任何处理，直接返回。 对 MethodInterceptor 的实例，包装成 DefaultPointcutAdvisor 返回。 循环成员 adapters 中预定义的所有 AdvisorAdapter，进行适配操作，如果有适配器支持这个 Advice，就包装成 DefaultPointcutAdvisor 返回。 如果以上条件都未处理成功，直接抛出异常。所以这里传入的对象一定得是一个 Advice 实现。 其实我们自定义的切面类中的通知增强，在这里都已经包装为 Advisor了，大多数都是走的直接返回。 关于成员变量 adapters，是在无参构造中初始化的: public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable { public DefaultAdvisorAdapterRegistry() { // 注册三种适配器。 registerAdvisorAdapter(new MethodBeforeAdviceAdapter()); registerAdvisorAdapter(new AfterReturningAdviceAdapter()); registerAdvisorAdapter(new ThrowsAdviceAdapter()); } } 关于 MethodInterceptor、 Advice、 AdvisorAdapter暂且跳过。 ","date":"2020-12-01","objectID":"/posts/spring/11-aop-proxy-create-processor/:2:0","tags":["spring源码"],"title":"11 AOP 代理实例的创建","uri":"/posts/spring/11-aop-proxy-create-processor/"},{"categories":["spring"],"content":"3 生成代理实例 - getProxy getProxy() 中只有一行代码： public class ProxyFactory extends ProxyCreatorSupport { public Object getProxy(@Nullable ClassLoader classLoader) { //根据目标对象是否有接口来判断采用什么代理方式，cglib代理还是jdk动态代理 return createAopProxy().getProxy(classLoader); } } 先看第一个方法 createAopProxy()。 步骤一（注意调用下一步方法的参数）： public class ProxyCreatorSupport extends AdvisedSupport { protected final synchronized AopProxy createAopProxy() { if (!this.active) { activate(); } return getAopProxyFactory().createAopProxy(this); } } 从上面代码看出，会调到另一个方法，注意这个参数，传入了一个 AdvisedSupport，里面封装了通知方法、切点等信息。 步骤二： public class DefaultAopProxyFactory implements AopProxyFactory, Serializable { @Override public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) { Class\u003c?\u003e targetClass = config.getTargetClass(); // 如果目标类是一个接口，则使用JDK动态代理 if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) { return new JdkDynamicAopProxy(config); } // 使用cglib代理。 return new ObjenesisCglibAopProxy(config); } else { return new JdkDynamicAopProxy(config); } } } 从上面代码可以看出，将 AdvisedSupport 封装到了创建代理的对象中。 有两种情况，可能会使用 JDK 动态代理、或者使用 Cglib 子类代理。无论是xml方式还是注解方式配置，激活代理时都可以配置一个布尔类型的属性 proxyTargetClass，如果不配置，默认值是 false。这个属性的作用是：指明是否要创建基于子类（CGLIB）的代理，而不是基于Java标准接口的代理。 默认是使用 JDK 动态代理，如果配置了 proxyTargetClass=true，会默认使用 Cglib 子类代理，但如果被代理的类本身是接口的话，依然会使用JDK动态代理。 以上规律从上面的源码中可以看到，在两个 if 条件中判断的。 接着看 getProxy()，这里真正生成了代理对象，以 JDK 动态代理为例（cglib也类似，其实都是将 Advisor 的必要信息封装到一个类中，将执行行为封装到对应的回调函数中）： final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable { public Object getProxy(@Nullable ClassLoader classLoader) { Class\u003c?\u003e[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); // 创建代理对象，参数中的InvocationHandler传入的是this，那么本类中一定有invoke()，在调用代理类方法时，就会执行这个invoke()。 return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this); } } 源码中调用了 Proxy.newProxyInstance() 生成代理，这是典型的 JDK 动态代理的生成方式。 注意\r\r仔细看 Proxy.newProxyInstance(classLoader, proxiedInterfaces, this)，这里第三个传输是 this，那么这个 this 一定实现了 InvocationHandler 接口、并实现了 invoke()。 记一下 JdkDynamicAopProxy 的声明： final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable 可以看到 JdkDynamicAopProxy 实现了 InvocationHandler。 \r\r 到这里，代理对象创建完成。 动态代理的入口方法 wrapIfNecessary() 到这里执行完成，会将创建的代理对象返回。将代码执行流程回转到 doCreateBean 中: –\u003e wrapIfNecessary() –\u003e postProcessAfterInitialization() –\u003e applyBeanPostProcessorsAfterInitialization() –\u003e applyBeanPostProcessorsAfterInitialization() –\u003e initializeBean() –\u003e exposedObject = initializeBean(beanName, exposedObject, mbd); 实际上，Spring对AOP的支持，这一整块儿，都是基于 BeanPostProcessor.applyBeanPostProcessorsAfterInitialization() 完成的。 冗长的流程，最终回转到 doCreateBean 中，在遍历 BeanPostProcessor 并依次调用 applyBeanPostProcessorsAfterInitialization() 时，传入创建好的bean实例，返回一个实例，而AbstractAutoProxyCreator中定义了骨架方法wrapIfNecessary()，这里面返回了一个代理实例，由此沿着调用链向上返回，最终getBean()得到的就可能是一个代理实例。 之所以说是可能，因为后面的流程，还有一个 getObjectForBeanInstance() 执行，如果 bean 是 FactoryBean 类型，会返回 getObject() 中返回的实例。文章 复杂对象的构建方式 - FactoryBean 中有详细说明。 ","date":"2020-12-01","objectID":"/posts/spring/11-aop-proxy-create-processor/:3:0","tags":["spring源码"],"title":"11 AOP 代理实例的创建","uri":"/posts/spring/11-aop-proxy-create-processor/"},{"categories":["spring"],"content":"AOP Advisor 的搜集","date":"2020-11-30","objectID":"/posts/spring/10-aop-advisor-collect/","tags":["spring源码"],"title":"10 AOP Advisor的封装与搜集","uri":"/posts/spring/10-aop-advisor-collect/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-11-30","objectID":"/posts/spring/10-aop-advisor-collect/:0:0","tags":["spring源码"],"title":"10 AOP Advisor的封装与搜集","uri":"/posts/spring/10-aop-advisor-collect/"},{"categories":["spring"],"content":"1 主流程 AOP是通过 BeanPostProcessor.postProcessAfterInitialization() 实现的，来到 doCreateBean() -\u003e initializeBean()，在初始化方法执行完成后，会调用 applyBeanPostProcessorsAfterInitialization()，这里循环调用了所有 BeanPostProcessor 的 postProcessAfterInitialization()，AOP 的入口就在其中的一个实现类，也是 AbstractAutoProxyCreator 的子类实现。 在生成代理之前，spring 会根据扫描规则，搜集容器中注册的所有 Advisor 实例、并搜集通知方法（@Aspect 注解的类中的@Before、@Around等注解标识的方法），将其封装成 Advisor。然后逐个与当前 bean 实例匹配，匹配到的放入一个集合中。 来到入口方法 postProcessAfterInitialization()，源码如下： public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware { @Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) { if (bean != null) { // 如果是FactoryBean，cacheKey是 \u0026+beanName拼接而成，如果benaName为空，则是类名称。 Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) { // TODO 必要时包装给定的bean，即是否有资格被代理。 return wrapIfNecessary(bean, beanName, cacheKey); } } return bean; } } 如果需要生成代理（自定义切面、事务等），会调用 wrapIfNecessary()。 wrapIfNecessary() 是这么定义的： public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware { protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) { // 省略无关代码... // TODO 重点：如果有需要增强，就创建代理对象，这里会循环此类中所有的方法，如果有增强匹配到类中的方法，就会将增强对象封装到list中。 // Create proxy if we have advice. Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) { this.advisedBeans.put(cacheKey, Boolean.TRUE); // TODO 重点：创建代理对象 Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } } 注意\r\r从源码中可以看到，关键点有两个： 搜集容器中所有匹配当前bean的通知方法。（如果当前bean中有方法被 pointCut 匹配到，就满足条件，将对应的通知方法封装到数组中返回） 根据匹配的通知方法列表，创建代理对象。（这里会将已排序的通知方法列表，生成一个执行链，缓存起来，当代理对象方法被调用时调用回调方法的时候，会火炬传递式的调用执行链中的通知方法。JDK动态代理和cgliib封装方式大同小异，通知方法都在回调函数所在的类中作为一个成员缓存。） \r\r ","date":"2020-11-30","objectID":"/posts/spring/10-aop-advisor-collect/:1:0","tags":["spring源码"],"title":"10 AOP Advisor的封装与搜集","uri":"/posts/spring/10-aop-advisor-collect/"},{"categories":["spring"],"content":"2 搜集封装Advisor ","date":"2020-11-30","objectID":"/posts/spring/10-aop-advisor-collect/:2:0","tags":["spring源码"],"title":"10 AOP Advisor的封装与搜集","uri":"/posts/spring/10-aop-advisor-collect/"},{"categories":["spring"],"content":"2.1 搜集流程 getAdvicesAndAdvisorsForBean() 会调用到 findEligibleAdvisors()。来到这个方法： public abstract class AbstractAdvisorAutoProxyCreator extends AbstractAutoProxyCreator { protected List\u003cAdvisor\u003e findEligibleAdvisors(Class\u003c?\u003e beanClass, String beanName) { //查找到所有的增强方法，封装成Advisor对象。这里查找了两种增强，一种是实现了Advisor的实例，一种是带有@Aspect注解的bean实例中定义的增强方法。 List\u003cAdvisor\u003e candidateAdvisors = findCandidateAdvisors(); // 根据每个增强中的切点表达式，进行匹配，筛选出合适的增强实例列表。 List\u003cAdvisor\u003e eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); // 对增强方法进行排序，可以不看。 if (!eligibleAdvisors.isEmpty()) { eligibleAdvisors = sortAdvisors(eligibleAdvisors); } return eligibleAdvisors; } } 这里分为了两步： 收集到容器中所有的增强方法、封装成 Advisor（如果本身就是 Advisor，直接返回）。 从这所有的 Advisor 中筛选出匹配当前 bean 的 Advisor 列表。 从 AbstractAutoProxyCreator的注册 已经知道，这里使用的是 AnnotationAwareAspectJAutoProxyCreator。 进入 findCandidateAdvisors()： public class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator { @Override protected List\u003cAdvisor\u003e findCandidateAdvisors() { // TODO 从父类中获取，这里获取了所有注入到容器中的Advisor类型的实例。事务的增强实例，就是在这里查找的。 // Add all the Spring advisors found according to superclass rules. List\u003cAdvisor\u003e advisors = super.findCandidateAdvisors(); // Build Advisors for all AspectJ aspects in the bean factory. if (this.aspectJAdvisorsBuilder != null) { // TODO 将beanFactory中缓存的所有bean实例，依次校验是否带有@Aspect注解，如果有，将其中的 // 增强方法、切点表达式等信息，封装成Advisor。advisors变量最终存储了所有切面的增强方法封装。 advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors()); } return advisors; } } 看上面代码，首先，从父类中查找 Advisor列表，然后调用 buildAspectJAdvisors()，将两者结果聚合到一个列表。 先看父类中的代码： public class BeanFactoryAdvisorRetrievalHelper { public List\u003cAdvisor\u003e findAdvisorBeans() { String[] advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) { // 从容器中获取所有的Advisor类型的额bean名称 advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; } // 省略非关键代码... List\u003cAdvisor\u003e advisors = new ArrayList\u003c\u003e(); for (String name : advisorNames) { if (isEligibleBean(name)) { // 从beanFactory中获取所有的Advisor类型的实例，事务支持TransactionAttributeSourceAdvisor实际上就是一个Advisor。 advisors.add(this.beanFactory.getBean(name, Advisor.class)); } } return advisors; } } 这里搜集了容器中所有 Advisor 类型的 beanName，并将其缓存。然后调用 getBean()，将其实例化。（事务的 Advisor 其实就是在这里创建的） 再看子类中的代码 buildAspectJAdvisors()： public class BeanFactoryAspectJAdvisorsBuilder { public List\u003cAdvisor\u003e buildAspectJAdvisors() { List\u003cString\u003e aspectNames = this.aspectBeanNames; // 第一次进来时为空，这里用到了双检索 if (aspectNames == null) { synchronized (this) { aspectNames = this.aspectBeanNames; if (aspectNames == null) { List\u003cAdvisor\u003e advisors = new ArrayList\u003c\u003e(); aspectNames = new ArrayList\u003c\u003e(); String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Object.class, true, false); for (String beanName : beanNames) { // 如果不是合格的beanName，则跳过 if (!isEligibleBean(beanName)) { continue; } Class\u003c?\u003e beanType = this.beanFactory.getType(beanName); if (beanType == null) { continue; } // 判断当前beanType是否是一个切面。判断类上是否有@Aspect if (this.advisorFactory.isAspect(beanType)) { aspectNames.add(beanName); // 创建切面元数据实例，里面封装了切面类型，切点表达式等信息。 AspectMetadata amd = new AspectMetadata(beanType, beanName); // 默认就是SINGLETON if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) { MetadataAwareAspectInstanceFactory factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName); // TODO 获取Advisor，这里封装了当前Aspect类中的增强方法，每个增强方法都会封装成一个Advisor。 List\u003cAdvisor\u003e classAdvisors = this.advisorFactory.getAdvisors(factory); if (this.beanFactory.isSingleton(beanName)) { // 将Advisor放入到缓存中，从上面的流程获取时，会先走缓存，缓存中有，就不会遍历查找了。 // 这个代码块使用了双检索，这块代码在spring容器启动时，只会执行一次。 this.advisorsCache.put(beanName, classAdvisors); } else { this.aspectFactoryCache.put(beanName, factory); } advisors.addAll(classAdvisors); } // 省略... } } this.aspectBeanNames = aspectNames; return advisors; } } } // 省略... // 根据切面名称，从缓存中获取到","date":"2020-11-30","objectID":"/posts/spring/10-aop-advisor-collect/:2:1","tags":["spring源码"],"title":"10 AOP Advisor的封装与搜集","uri":"/posts/spring/10-aop-advisor-collect/"},{"categories":["spring"],"content":"2.2 PointCut的获取 关于如何获取 PointCut 的，源码如下： public class ReflectiveAspectJAdvisorFactory extends AbstractAspectJAdvisorFactory implements Serializable { private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class\u003c?\u003e candidateAspectClass) { // 找到切面相关注解，并把注解信息解析出来，包装成AspectJAnnotation AspectJAnnotation\u003c?\u003e aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); if (aspectJAnnotation == null) { return null; } // 将切点表达式封装到AspectJExpressionPointcut中。这里封装了切点表达式、切面类型等信息。 AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class\u003c?\u003e[0]); ajexp.setExpression(aspectJAnnotation.getPointcutExpression()); if (this.beanFactory != null) { ajexp.setBeanFactory(this.beanFactory); } return ajexp; } } 接着看 findAspectJAnnotationOnMethod()： public abstract class AbstractAspectJAdvisorFactory implements AspectJAdvisorFactory { /** 这里定义了切面中支持的注解，前置、后置、环绕等通知类型 */ private static final Class\u003c?\u003e[] ASPECTJ_ANNOTATION_CLASSES = new Class\u003c?\u003e[] { Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class}; // 步骤一 protected static AspectJAnnotation\u003c?\u003e findAspectJAnnotationOnMethod(Method method) { for (Class\u003c?\u003e clazz : ASPECTJ_ANNOTATION_CLASSES) { // 循环去找注解，并把注解信息解析出来，包装成AspectJAnnotation AspectJAnnotation\u003c?\u003e foundAnnotation = findAnnotation(method, (Class\u003cAnnotation\u003e) clazz); if (foundAnnotation != null) { return foundAnnotation; } } return null; } // 步骤二 private static \u003cA extends Annotation\u003e AspectJAnnotation\u003cA\u003e findAnnotation(Method method, Class\u003cA\u003e toLookFor) { // 找的规则就是找注解的父注解，递归的方式去找，直到找到目标注解为止 A result = AnnotationUtils.findAnnotation(method, toLookFor); if (result != null) { // 把注解里面对的信息解析出来，然后包装成AspectJAnnotation对象 return new AspectJAnnotation\u003c\u003e(result); } else { return null; } } } 从上面代码可以看到，ASPECTJ_ANNOTATION_CLASSES数组常量中，预定义了支持切点表达式的注解。如果能在当前方法上找到任何一种，就将这个切点信息封装成 AspectJAnnotation。 ","date":"2020-11-30","objectID":"/posts/spring/10-aop-advisor-collect/:2:2","tags":["spring源码"],"title":"10 AOP Advisor的封装与搜集","uri":"/posts/spring/10-aop-advisor-collect/"},{"categories":["spring"],"content":"2.3 Advisor的初始化 这里还有一个重点，new InstantiationModelAwarePointcutAdvisorImpl 中的初始化过程。 构造函数源码如下： final class InstantiationModelAwarePointcutAdvisorImpl implements InstantiationModelAwarePointcutAdvisor, AspectJPrecedenceInformation, Serializable { public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut, Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) { // 切点、切面名称、通知方法名称、等等一系列信息的封装 this.declaredPointcut = declaredPointcut; // 省略... if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) { // 省略... }else { // A singleton aspect. this.pointcut = this.declaredPointcut; this.lazy = false; // TODO 重点，实例化的过程，这里封装了具体的Advice this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut); } } } 重点方法是 instantiateAdvice()，这里完成了 Advice 的创建。 继续向下跟踪代码： final class InstantiationModelAwarePointcutAdvisorImpl implements InstantiationModelAwarePointcutAdvisor, AspectJPrecedenceInformation, Serializable { private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) { // TODO 重点getAdvice Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut, this.aspectInstanceFactory, this.declarationOrder, this.aspectName); return (advice != null ? advice : EMPTY_ADVICE); } } 来到 getAdvice()： public class ReflectiveAspectJAdvisorFactory extends AbstractAspectJAdvisorFactory implements Serializable { public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) { // 获取切面类 Class\u003c?\u003e candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass(); validate(candidateAspectClass); // 查找切点表达式、五种通知增强注解。@Before等五种。 AspectJAnnotation\u003c?\u003e aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); if (aspectJAnnotation == null) { return null; } // 省略部分代码... AbstractAspectJAdvice springAdvice; // TODO 执行判断，针对不同类型的通知，封装不同类型的Advice // 这几个Advice的实现类要记一下。主要以是否实现MethodInterceptor来区分，有的实现了，有的没有。 switch (aspectJAnnotation.getAnnotationType()) { case AtPointcut: if (logger.isDebugEnabled()) { logger.debug(\"Processing pointcut '\" + candidateAdviceMethod.getName() + \"'\"); } return null; case AtAround: springAdvice = new AspectJAroundAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtBefore: springAdvice = new AspectJMethodBeforeAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtAfter: springAdvice = new AspectJAfterAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtAfterReturning: springAdvice = new AspectJAfterReturningAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation(); if (StringUtils.hasText(afterReturningAnnotation.returning())) { springAdvice.setReturningName(afterReturningAnnotation.returning()); } break; case AtAfterThrowing: springAdvice = new AspectJAfterThrowingAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation(); if (StringUtils.hasText(afterThrowingAnnotation.throwing())) { springAdvice.setThrowingName(afterThrowingAnnotation.throwing()); } break; default: throw new UnsupportedOperationException( \"Unsupported advice type on method: \" + candidateAdviceMethod); } // 省略... return springAdvice; } } 注意\r\r上面代码中，AspectJMethodBeforeAdvice 等几个Advice的实现要看一下，这里五个 Advice 实现，部分实现了MethodInterceptor。 实现了MethodInterceptor的： AspectJAroundAdvice AspectJAfterAdvice AspectJAfterThrowingAdvice 未实现MethodInterceptor的 –\u003e 生成执行链时依赖的适配器： AspectJMethodBeforeAdvice –\u003e MethodBeforeAdviceAdapter AspectJAfterReturningAdvice –\u003e AfterReturningAdviceAdapter 另外还有一个未用到","date":"2020-11-30","objectID":"/posts/spring/10-aop-advisor-collect/:2:3","tags":["spring源码"],"title":"10 AOP Advisor的封装与搜集","uri":"/posts/spring/10-aop-advisor-collect/"},{"categories":["spring"],"content":"3 筛选出匹配的Advisor 在获取到容器中所有的通知方法封装成的 Advisor 后，会调用 findAdvisorsThatCanApply()，将 beanName 放入到一个 ThreadLocal 类型的变量中，然后调用 findAdvisorsThatCanApply() 的重载方法。调用完毕之后，会将 ThreadLocal 变量中的 beanName置空。 findAdvisorsThatCanApply() 重载方法源码如下： public abstract class AopUtils { public static List\u003cAdvisor\u003e findAdvisorsThatCanApply(List\u003cAdvisor\u003e candidateAdvisors, Class\u003c?\u003e clazz) { if (candidateAdvisors.isEmpty()) { return candidateAdvisors; } List\u003cAdvisor\u003e eligibleAdvisors = new ArrayList\u003c\u003e(); // 先处理IntroductionAdvisor类型的增强 for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor \u0026\u0026 canApply(candidate, clazz)) { eligibleAdvisors.add(candidate); } } boolean hasIntroductions = !eligibleAdvisors.isEmpty(); // 再处理其他类型的增强 for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor) { // already processed continue; } // 我们自定义的切面，就会走到这里，使用已经封装的PointcutAdvisor，根据切点表达式进行匹配，具体的匹配过程，不用看。 if (canApply(candidate, clazz, hasIntroductions)) { eligibleAdvisors.add(candidate); } } return eligibleAdvisors; } } 调用 canApply()，这里进行了切点表达式与方法的匹配，如果匹配成功，将 Advisor 放入到集合中，否则就跳过。 当将所有的 Advisor 遍历完毕，最终匹配成功的 Advisor 会被筛选出来，放入到一个新的集合中，最终生成的执行链中的通知方法，就来自筛选后的 Advisor 集合（这个集合在创建代理前还有一次新增操作）。 看 canApply()，这里进行了匹配： public abstract class AopUtils { // 步骤一 public static boolean canApply(Advisor advisor, Class\u003c?\u003e targetClass, boolean hasIntroductions) { if (advisor instanceof IntroductionAdvisor) { return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass); } else if (advisor instanceof PointcutAdvisor) { PointcutAdvisor pca = (PointcutAdvisor) advisor; //切点表达式匹配。 return canApply(pca.getPointcut(), targetClass, hasIntroductions); } else { // It doesn't have a pointcut so we assume it applies. return true; } } public static boolean canApply(Pointcut pc, Class\u003c?\u003e targetClass, boolean hasIntroductions) { // 省略... // 这里做了切入点表达式的匹配，匹配通过的返回true，具体的匹配过程不用看，不是重点。 for (Class\u003c?\u003e clazz : classes) { Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz); for (Method method : methods) { if (introductionAwareMethodMatcher != null ? introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) : methodMatcher.matches(method, targetClass)) { return true; } } } return false; } } 从上面代码可以看到，PointcutAdvisor 类型的，最终会遍历类中所有的方法，根据切点表达式，进行一一匹配，如果匹配成功，返回true，否则返回false。 ","date":"2020-11-30","objectID":"/posts/spring/10-aop-advisor-collect/:3:0","tags":["spring源码"],"title":"10 AOP Advisor的封装与搜集","uri":"/posts/spring/10-aop-advisor-collect/"},{"categories":["spring"],"content":"4 搜集容器中所有的Advisor的流程 父类调用流程： 子类调用流程： ","date":"2020-11-30","objectID":"/posts/spring/10-aop-advisor-collect/:4:0","tags":["spring源码"],"title":"10 AOP Advisor的封装与搜集","uri":"/posts/spring/10-aop-advisor-collect/"},{"categories":["spring"],"content":"AOP - AbstractAutoProxyCreator的注册流程解析","date":"2020-11-29","objectID":"/posts/spring/09-aop-support-register/","tags":["spring源码"],"title":"09 AOP AbstractAutoProxyCreator的注册","uri":"/posts/spring/09-aop-support-register/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-11-29","objectID":"/posts/spring/09-aop-support-register/:0:0","tags":["spring源码"],"title":"09 AOP AbstractAutoProxyCreator的注册","uri":"/posts/spring/09-aop-support-register/"},{"categories":["spring"],"content":"1 AOP入口 AOP是通过 BeanPostProcessor.postProcessAfterInitialization() 实现的，来到 doCreateBean() -\u003e initializeBean()，在初始化方法执行完成后，会调用 applyBeanPostProcessorsAfterInitialization()，这里循环调用了所有 BeanPostProcessor 的 postProcessAfterInitialization()，AOP 的入口就在其中的一个实现类，也是 AbstractAutoProxyCreator 的子类实现。 要看代理对象的生成过程，首先要看支持这个功能的类，是在哪里注册的，它源自哪里？ ","date":"2020-11-29","objectID":"/posts/spring/09-aop-support-register/:1:0","tags":["spring源码"],"title":"09 AOP AbstractAutoProxyCreator的注册","uri":"/posts/spring/09-aop-support-register/"},{"categories":["spring"],"content":"2 XMl配置方式BeanPostProcessor的注册 XMl方式注入AOP支持的BeanPostProcessor，是通过 \u003caop:aspectj-autoproxy/\u003e 标签注入的。 根据SPI加载规则，找到 spring-aop 模块下的 META-INF/spring.handlers 文件。 可以看到以下内容： http\\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler 来到 AopNamespaceHandler 类，源码如下： public class AopNamespaceHandler extends NamespaceHandlerSupport { public void init() { registerBeanDefinitionParser(\"config\", new ConfigBeanDefinitionParser()); // AspectJAutoProxyBeanDefinitionParser标签 \u003caop:aspectj-autoproxy/\u003e 的支持， // 在其 parse() 中注册了AOP的入口类 AnnotationAwareAspectJAutoProxyCreator，是一个 BeanPostProcessor registerBeanDefinitionParser(\"aspectj-autoproxy\", new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(\"scoped-proxy\", new ScopedProxyBeanDefinitionDecorator()); registerBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser()); } } 我们在使用Spring XML配置方式使用 \u003caop:aspectj-autoproxy/\u003e 标签激活代理，在 init() 中注册了 aspectj-autoproxy 属性的解析类，在这个解析类中，注入了 AnnotationAwareAspectJAutoProxyCreator 的 BeanDefinition。 源码如下： 步骤一： class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser { public BeanDefinition parse(Element element, ParserContext parserContext) { // 对aspectj-autoproxy属性的支持 AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 添加IncludePatterns extendBeanDefinition(element, parserContext); return null; } } 步骤二： public abstract class AopNamespaceUtils { public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary( ParserContext parserContext, Element sourceElement) { // 这里注册了AnnotationAwareAspectJAutoProxyCreator BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary( parserContext.getRegistry(), parserContext.extractSource(sourceElement)); useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement); registerComponentIfNecessary(beanDefinition, parserContext); } } 步骤三： public abstract class AopConfigUtils { public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary( BeanDefinitionRegistry registry, @Nullable Object source) { // 注入此类 AnnotationAwareAspectJAutoProxyCreator，本质还是一个BeanPostProcessor, // 实现了BeanPostProcessor的子接口：SmartInstantiationAwareBeanPostProcessor return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source); } } 可以看到，步骤三中，最后 return 语句后注册了 AnnotationAwareAspectJAutoProxyCreator。 信息\r\r回顾：BeanPostProcessor 提前注册到IOC容器的流程。 创建 BeanFactory，完成所有 BeanDefinition 的搜集。 执行 invokeBeanFactoryPostProcessors()（BeanDefinition的后置处理）。BeanFactoryPostProcessor 及子接口 BeanDefinitionRegistryPostProcessor 实现类的方法。 执行 registerBeanPostProcessors。从 beanFactory 中获取所有的 BeanPostProcessor，优先进行 getBean() 操作，实例化。 \r\r ","date":"2020-11-29","objectID":"/posts/spring/09-aop-support-register/:2:0","tags":["spring源码"],"title":"09 AOP AbstractAutoProxyCreator的注册","uri":"/posts/spring/09-aop-support-register/"},{"categories":["spring"],"content":"3 注解方式BeanPostProcessor的注册 ","date":"2020-11-29","objectID":"/posts/spring/09-aop-support-register/:3:0","tags":["spring源码"],"title":"09 AOP AbstractAutoProxyCreator的注册","uri":"/posts/spring/09-aop-support-register/"},{"categories":["spring"],"content":"3.1 注解方式案例 先看一个案例： 切面类： @Component @Aspect @Slf4j public class CustomAspect { @Pointcut(\"execution(* top.wlz922.aspect.*.*(..))\") public void pointCut(){} @Before(\"pointCut()\") public void before(){ log.info(\"CustomAspect.before execute...\"); } } 业务类： @Component @Slf4j public class Apple { public void showTaste(){ log.info(\"Apple is sour and sweet.\"); } } 配置类： @Configuration @EnableAspectJAutoProxy @ComponentScan(basePackages = \"top.wlz922\") public class AspectAnoConfiguration { } 测试类： @Slf4j public class ApplicationContextTest { @Test public void testAnoAop(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AspectAnoConfiguration.class); Apple apple = context.getBean(Apple.class); apple.showTaste(); } } 执行结果： 12:23:34.294 [main] INFO top.wlz922.aspect.CustomAspect 16 - CustomAspect.before execute... 12:23:34.325 [main] INFO top.wlz922.aspect.Apple 10 - Apple is sour and sweet. 以上是一个简单的注解方式激活AOP功能的案例。 ","date":"2020-11-29","objectID":"/posts/spring/09-aop-support-register/:3:1","tags":["spring源码"],"title":"09 AOP AbstractAutoProxyCreator的注册","uri":"/posts/spring/09-aop-support-register/"},{"categories":["spring"],"content":"3.2 AspectJAutoProxyRegistrar的注册 下面来看注解方式，注入对应支持的 BeanPostProcessor 的入口。 这是 @EnableAspectJAutoProxy 的声明： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(AspectJAutoProxyRegistrar.class) public @interface EnableAspectJAutoProxy { boolean proxyTargetClass() default false; boolean exposeProxy() default false; } 可以看到，@EnableAspectJAutoProxy 上有一个 @Import，那么它在创建 BeanFactory，扫描注册 BeanDefinition 时，会把 AspectJAutoProxyRegistrar 类包装为 BeanDefinition 注册到容器中。 看 AspectJAutoProxyRegistrar 的声明： class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions( AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { // TODO 注册自动代理的支持类的BeanDefinition到容器中。 AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry); AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class); // 如果激活了自动代理，这里会设置AnnotationAwareAspectJAutoProxyCreator的BeanDefinition对应的属性值 if (enableAspectJAutoProxy != null) { if (enableAspectJAutoProxy.getBoolean(\"proxyTargetClass\")) { AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); } if (enableAspectJAutoProxy.getBoolean(\"exposeProxy\")) { AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); } } } } 来到 registerAspectJAnnotationAutoProxyCreatorIfNecessary()： public abstract class AopConfigUtils { @Nullable public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary( BeanDefinitionRegistry registry, @Nullable Object source) { // 注入此类 AnnotationAwareAspectJAutoProxyCreator，本质还是一个BeanPostProcessor, // 实现了BeanPostProcessor的子接口：SmartInstantiationAwareBeanPostProcessor return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source); } } 可以看到，在这里对 AnnotationAwareAspectJAutoProxyCreator 进行了注册。 具体的注册逻辑源码（注意参数的传递）： public abstract class AopConfigUtils { public static final String AUTO_PROXY_CREATOR_BEAN_NAME = \"org.springframework.aop.config.internalAutoProxyCreator\"; private static BeanDefinition registerOrEscalateApcAsRequired( Class\u003c?\u003e cls, BeanDefinitionRegistry registry, @Nullable Object source) { // 前面注册的类没用，注册不进来，这里会根据等级返回BeanDefinition，注解方式会返回AnnotationAwareAspectJAutoProxyCreator if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) { BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME); if (!cls.getName().equals(apcDefinition.getBeanClassName())) { // 这里会有一个比较，在注册AbstractAdvisorAutoProxyCreator时，会有一个优先级。 // 如果这里已经注册过AbstractAdvisorAutoProxyCreator，在此注册的时候， // 会与之前的注册的进行优先级比较，优先级高的会覆盖掉优先级低的。注解的优先级最高。 int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName()); int requiredPriority = findPriorityForClass(cls); if (currentPriority \u003c requiredPriority) { apcDefinition.setBeanClassName(cls.getName()); } } return null; } // 创建BeanDefinition，并设置一些属性。 RootBeanDefinition beanDefinition = new RootBeanDefinition(cls); beanDefinition.setSource(source); beanDefinition.getPropertyValues().add(\"order\", Ordered.HIGHEST_PRECEDENCE); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); // 注册到BeanDefinitionRegistry registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition); return beanDefinition; } } 首先这里会判断容器中是否包含指定名称的 BeanDefinition，如果包含，拿这次将要注册的类型与已存在的类型进行优先级比对，以优先级高的为准进行 BeanDefinition 的注册。 看一下获取优先级的代码： public abstract class AopConfigUtils { private static final List\u003cClass\u003c?\u003e\u003e APC_PRIORITY_LIST = new ArrayList\u003c\u003e(3); static { // 这里默认包含三个代理生成类 // Set up the escalation list... APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class); APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class); APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class); } private static int findPriorityForClass(@Nullable String className) { for (int i = 0; i \u003c APC_PRIORITY_LIST.size(); i++) { Class\u003c?\u003e clazz = APC_PRIORITY_LIST.get(i); if (clazz.getName().equals(className","date":"2020-11-29","objectID":"/posts/spring/09-aop-support-register/:3:2","tags":["spring源码"],"title":"09 AOP AbstractAutoProxyCreator的注册","uri":"/posts/spring/09-aop-support-register/"},{"categories":["spring"],"content":"这个 BeanDefinitionRegistryPostProcessor 的实现类 ConfigurationClassPostProcessor 很重要，有必要单独列举一下。","date":"2020-11-29","objectID":"/posts/spring/08-configuration-class-post-processor/","tags":["spring源码"],"title":"08 ConfigurationClassPostProcessor源码解析","uri":"/posts/spring/08-configuration-class-post-processor/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-11-29","objectID":"/posts/spring/08-configuration-class-post-processor/:0:0","tags":["spring源码"],"title":"08 ConfigurationClassPostProcessor源码解析","uri":"/posts/spring/08-configuration-class-post-processor/"},{"categories":["spring"],"content":"1 主流程 在调用 invokeBeanDefinitionRegistryPostProcessors() 是，会调用到这个实现类中，来到源码： public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware { public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) { List\u003cBeanDefinitionHolder\u003e configCandidates = new ArrayList\u003c\u003e(); // 获取到所有的BeanDefinitionNames String[] candidateNames = registry.getBeanDefinitionNames(); // 循环调用 for (String beanName : candidateNames) { BeanDefinition beanDef = registry.getBeanDefinition(beanName); // 省略无关代码... //检查给定的bean定义是否适合配置类（或在配置/组件类中声明的嵌套组件类，也要自动注册），并进行相应标记。 if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) { configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); } } // 省略无关代码... // Parse each @Configuration class ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set\u003cBeanDefinitionHolder\u003e candidates = new LinkedHashSet\u003c\u003e(configCandidates); Set\u003cConfigurationClass\u003e alreadyParsed = new HashSet\u003c\u003e(configCandidates.size()); do { // TODO 重要程度：5 ConfigurationClassParser的parse方法调用，这里解析了一系列的注解 parser.parse(candidates); parser.validate(); Set\u003cConfigurationClass\u003e configClasses = new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) { this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); } // 这里装载了BeanDefinition this.reader.loadBeanDefinitions(configClasses); // 省略无关代码... } while (!candidates.isEmpty()); // 省略无关代码... } } 划重点（上面源码中的高亮部分）： 校验是否符合条件，完成对@Configuration、@Component、@ComponentScan、@Import、@ImportResource、方法上包含@Bean 的支持。 执行 parse()，完成解析。 loadBeanDefinitions()，装载 BeanDefinition。 ","date":"2020-11-29","objectID":"/posts/spring/08-configuration-class-post-processor/:1:0","tags":["spring源码"],"title":"08 ConfigurationClassPostProcessor源码解析","uri":"/posts/spring/08-configuration-class-post-processor/"},{"categories":["spring"],"content":"2 循环所有benaName、校验bean是否符合 进入 checkConfigurationClassCandidate() 源码： abstract class ConfigurationClassUtils { public static boolean checkConfigurationClassCandidate( BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) { // 省略无关代码... // 类上是否包含@Configuration if (isFullConfigurationCandidate(metadata)) { beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL); } // 类上是包含@Component、@ComponentScan、@Import、@ImportResource。方法上包含@Bean else if (isLiteConfigurationCandidate(metadata)) { beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE); } else { return false; } // 省略无关代码 return true; } } isFullConfigurationCandidate() 源码： abstract class ConfigurationClassUtils { public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) { return metadata.isAnnotated(Configuration.class.getName()); } } isLiteConfigurationCandidate() 源码： abstract class ConfigurationClassUtils { // 注意这个成员变量，包含了对一些内置注解的支持。 private static final Set\u003cString\u003e candidateIndicators = new HashSet\u003c\u003e(8); static { // 添加了一系列注解的支持。 candidateIndicators.add(Component.class.getName()); candidateIndicators.add(ComponentScan.class.getName()); candidateIndicators.add(Import.class.getName()); candidateIndicators.add(ImportResource.class.getName()); } public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) { // 类上是包含@Component、@ComponentScan、@Import、@ImportResource。方法上包含@Bean for (String indicator : candidateIndicators) { if (metadata.isAnnotated(indicator)) { return true; } } // @Bean的支持 return metadata.hasAnnotatedMethods(Bean.class.getName()); } } ","date":"2020-11-29","objectID":"/posts/spring/08-configuration-class-post-processor/:2:0","tags":["spring源码"],"title":"08 ConfigurationClassPostProcessor源码解析","uri":"/posts/spring/08-configuration-class-post-processor/"},{"categories":["spring"],"content":"3 解析 来到 parse() 源码： class ConfigurationClassParser { public void parse(Set\u003cBeanDefinitionHolder\u003e configCandidates) { for (BeanDefinitionHolder holder : configCandidates) { BeanDefinition bd = holder.getBeanDefinition(); //这是哪个分支的解析会走到同一个方法里 if (bd instanceof AnnotatedBeanDefinition) { //执行解析 parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); } else if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) { //执行解析 parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()); } else { // TODO 执行解析，记着这个方法，这里在满足条件时会被递归调用。 parse(bd.getBeanClassName(), holder.getBeanName()); } } this.deferredImportSelectorHandler.process(); } } 对不同类型的 BeanDefinition 会调用不同的重载 parse()，实际上，最终都会进到这个方法： class ConfigurationClassParser { protected void processConfigurationClass(ConfigurationClass configClass) throws IOException { // 省略无关代码... // Recursively process the configuration class and its superclass hierarchy. SourceClass sourceClass = asSourceClass(configClass); do { // 执行解析 sourceClass = doProcessConfigurationClass(configClass, sourceClass); } while (sourceClass != null); // 这里将配置类的信息放入缓存中，等解析完之后，会将配置类进行LoadBeanDefinitions(); this.configurationClasses.put(configClass, configClass); } } 是在一个循环中调用的，如果返回不为空，就一直执行。每次会更新sourceClass的值。 进入 doProcessConfigurationClass()： class ConfigurationClassParser { protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException { // Component注解支持 if (configClass.getMetadata().isAnnotated(Component.class.getName())) { // Recursively process any member (nested) classes first processMemberClasses(configClass, sourceClass); } // Process any @PropertySource annotations for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) { if (this.environment instanceof ConfigurableEnvironment) { processPropertySource(propertySource); } else { logger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\"); } } // @ComponentScan，@ComponentScans支持 // Process any @ComponentScan annotations Set\u003cAnnotationAttributes\u003e componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) { for (AnnotationAttributes componentScan : componentScans) { // 使用@ComponentScan注释配置类-\u003e立即执行扫描 // The config class is annotated with @ComponentScan -\u003e perform the scan immediately Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) { BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) { bdCand = holder.getBeanDefinition(); } // TODO 如果是配置类，则递归调用ConfigurationClassParser.parse() if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) { parse(bdCand.getBeanClassName(), holder.getBeanName()); } } } } // 处理@Import注解导入 // Process any @Import annotations processImports(configClass, sourceClass, getImports(sourceClass), true); // 处理@ImportResource注解导入 // Process any @ImportResource annotations AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) { String[] resources = importResource.getStringArray(\"locations\"); Class\u003c? extends BeanDefinitionReader\u003e readerClass = importResource.getClass(\"reader\"); for (String resource : resources) { String resolvedResource = thi","date":"2020-11-29","objectID":"/posts/spring/08-configuration-class-post-processor/:3:0","tags":["spring源码"],"title":"08 ConfigurationClassPostProcessor源码解析","uri":"/posts/spring/08-configuration-class-post-processor/"},{"categories":["spring"],"content":"4 装载BeanDefinition loadBeanDefinitions() 方法参数是一个 ConfigurationClass 的集合，从名字就可以看出，这是一个配置类的集合。 这些配置类是在上面的流程中，扫描包中的类时，扫描到有配置信息的类。 最终会进行以下调用，又会回到 springioc 容器初始化时，解析标签的那段代码。 关键源码： class ConfigurationClassBeanDefinitionReader { private void loadBeanDefinitionsForConfigurationClass( ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) { // 省略无关代码... // @Import注解中，导入的类，包装为BeanDefinition并注册到容器。 if (configClass.isImported()) { registerBeanDefinitionForImportedConfigurationClass(configClass); } // @Bean注解的方法，将对应的metadata包装为BeanDefinition并注册到容器。 // 这里并没有执行方法，真正执行方法是在实例化的时候。 for (BeanMethod beanMethod : configClass.getBeanMethods()) { loadBeanDefinitionsForBeanMethod(beanMethod); } // 加载导入资源 loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); // 这里是加载ImportBeanDefinitionRegistrar接口注册的BeanDefinition，通过调用registerBeanDefinitions()来注入 loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); } } 从源码注释中可以很清楚的看到，loadBeanDefinitions() 都做了那些事情。 解析@Import 导入的类，包装为 BeanDefinition 并注册到容器。 解析 @Bean 注解的方法，包装成 BeanDefinition 并注册到容器。 加载导入资源的BeanDefinition，这个是import标签的支持。 调用容器中已注册的 ImportBeanDefinitionRegistrar 实现类的 registerBeanDefinitions()。 技巧\r\rAOP的支持，就是通过 ImportBeanDefinitionRegistrar.registerBeanDefinitions() 注册进来的，其实现类是 AspectJAutoProxyRegistrar。\r\r 调用链流程如下： ","date":"2020-11-29","objectID":"/posts/spring/08-configuration-class-post-processor/:4:0","tags":["spring源码"],"title":"08 ConfigurationClassPostProcessor源码解析","uri":"/posts/spring/08-configuration-class-post-processor/"},{"categories":["spring"],"content":"介绍FactoryBean的使用方法和FactoryBean在Spring中的实现原理，执行流程。","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/","tags":["spring源码"],"title":"07 复杂对象的构建方式 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:0:0","tags":["spring源码"],"title":"07 复杂对象的构建方式 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"1 FactoryBean 的作用 Spring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该FactoryBean的getObject方法所返回的对象。创建出来的对象是否属于单例由isSingleton中的返回决定。 一般情况下，Spring通过反射机制利用的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean的形式 以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个\u0026符号来获取。 ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:1:0","tags":["spring源码"],"title":"07 复杂对象的构建方式 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"2 FactoryBean 接口的定义 以下是 Spring 中 FactoryBean 接口的定义： public interface FactoryBean\u003cT\u003e { T getObject() throws Exception; Class\u003c?\u003e getObjectType(); default boolean isSingleton() { return true; } } ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:2:0","tags":["spring源码"],"title":"07 复杂对象的构建方式 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"3 应用场景 FactoryBean 通常是用来创建比较复杂的 bean，一般的 bean 直接用 xml 配置即可，但如果一个 bean 的创建过程中涉及到很多其他的 bean 和复杂的逻辑，用 xml 配置比较困难，这时可以考虑用 FactoryBean。 很多开源项目在集成 Spring 时都使用到 FactoryBean，比如 MyBatis3 提供 mybatis-spring 项目中的 org.mybatis.spring.SqlSessionFactoryBean： \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"/\u003e \u003c!-- 自动扫描mapping.xml文件 --\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"\u003e\u003c/property\u003e \u003c/bean\u003e public class SqlSessionFactoryBean implements FactoryBean\u003cSqlSessionFactory\u003e, InitializingBean, ApplicationListener\u003cApplicationEvent\u003e { // ... public SqlSessionFactory getObject() throws Exception { if (this.sqlSessionFactory == null) { this.afterPropertiesSet(); } return this.sqlSessionFactory; } // ... } ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:3:0","tags":["spring源码"],"title":"07 复杂对象的构建方式 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"4 源码分析 ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:4:0","tags":["spring源码"],"title":"07 复杂对象的构建方式 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"4.1 初次创建 AbstractBeanFactory 通过 getBean 向 IOC 容器获取被管理的 Bean。 AbstractBeanFactory.getBean() -\u003e doGetBean()。 来到 doGetBean()，看 bean 第一次创建实例后，调用的地方： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -\u003e { try { //创建Bean实例 return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); /* TODO 重要程度 5 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 否则调用FactoryBean的getObject(),且将返回的bean替换为getObject()的返回值。 FactoryBean接口很重要，具体应用场景见FactoryBean接口注释。 */ bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } } 可以看到，在 getSingleton() 之后，又调用了 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd)，给 bean 重新赋值，这里bean的实例就可能被改变了。 如果当前创建的 bean 是 FactoryBean 类型的，调用 getObjectForBeanInstance() 时，最终会返回 FactoryBean.getObject() 返回的对象，也就是最终 getBean() 返回的是这个 getObject() 获取到的实例。 以下是 getObjectForBeanInstance() 的源码： public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) { String currentlyCreatedBean = this.currentlyCreatedBean.get(); if (currentlyCreatedBean != null) { registerDependentBean(beanName, currentlyCreatedBean); } // 从父类方法中获取 return super.getObjectForBeanInstance(beanInstance, name, beanName, mbd); } } 这里调用到了父类的方法，继续看父类的方法： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) { // ... // 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) { return beanInstance; } Object object = null; // 如果BeanDefinition为null，从缓存中获取，doGetBean() 中传入的就是null // createBean后进入这里的话，传入的就不是null if (mbd == null) { object = getCachedObjectForFactoryBean(beanName); } if (object == null) { FactoryBean\u003c?\u003e factory = (FactoryBean\u003c?\u003e) beanInstance; if (mbd == null \u0026\u0026 containsBeanDefinition(beanName)) { mbd = getMergedLocalBeanDefinition(beanName); } boolean synthetic = (mbd != null \u0026\u0026 mbd.isSynthetic()); // 调用FactoryBean的getObject方法 object = getObjectFromFactoryBean(factory, beanName, !synthetic); } return object; } } 上面代码的尾部，调用到了 object = getObjectFromFactoryBean(factory, beanName, !synthetic)，这个方法中调用了 getObject()。 源码如下（关键点 - 注意源码中高亮部分）： public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry { protected Object getObjectFromFactoryBean(FactoryBean\u003c?\u003e factory, String beanName, boolean shouldPostProcess) { if (factory.isSingleton() \u0026\u0026 containsSingleton(beanName)) { synchronized (getSingletonMutex()) { Object object = this.factoryBeanObjectCache.get(beanName); if (object == null) { // 调用 factory.getObject(); object = doGetObjectFromFactoryBean(factory, beanName); Object alreadyThere = this.factoryBeanObjectCache.get(beanName); if (alreadyThere != null) { object = alreadyThere; } else { if (shouldPostProcess) { if (isSingletonCurrentlyInCreation(beanName)) { // Temporarily return non-post-processed object, not storing it yet.. return object; } beforeSingletonCreation(beanName); try { // 这里调用了BeanPostProcessor的后置处理 object = postProcessObjectFromFactoryBean(object, beanName); } catch (Throwable ex) { throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's singleton object failed\", ex); } finally { afterSingletonCreation(beanName); } } // 加入到缓存，缓存位置：BeanFactory的 factoryBeanO","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:4:1","tags":["spring源码"],"title":"07 复杂对象的构建方式 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"4.2 缓存中获取 从上面的代码分析中已经知道，最终调用了 getObject() 之后，会将这个实例缓存到一个变量中，这个变量是 factoryBeanObjectCache。 回到 doGetBean() 中开始的代码块，先从缓存中获取实例，如果获取到了，同样会调用 getObjectForBeanInstance()，判断实例是否是 FactoryBean 类型。 源码如下： Object sharedInstance = getSingleton(beanName); if (sharedInstance != null \u0026\u0026 args == null) { // ... // 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 // 否则将bean强转为FactoryBean类型，并调用getObject()方法返回。 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } 在 [06 循环依赖的实现原理 - getSingleton()] 中有提到，这里可能返回一个bean实例。实际上在 bean 第一次创建后，后面再获取都是从缓存中拿的。拿到了之后，经过一些处理，就返回。这个处理就是判断 FactoryBean 的处理。 从上面源码中可以看到，如果从缓存中获取到，会调用 getObjectForBeanInstance() 。很明显，在第一次创建 bean 实例时，就调用过这个方法，会把创建的结果缓存到 factoryBeanObjectCache 变量中，这里就直接从 factoryBeanObjectCache 变量中获取的实例。 最终，如果这个 bean 是 FactoryBean 类型，会被替换掉。 ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:4:2","tags":["spring源码"],"title":"07 复杂对象的构建方式 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"4.3 获取原始bean 关于获取原始bean的方式，在 beanName 前加一个前缀 \u0026，就可以获取到原始 bean 实例。 在 getObjectForBeanInstance() 中有这么一段源码： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { protected Object getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) { // 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) { return beanInstance; } } } 看一下 isFactoryDereference() 的源码： public abstract class BeanFactoryUtils { public static boolean isFactoryDereference(@Nullable String name) { return (name != null \u0026\u0026 name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)); } } 可以看到，如果 beanName以 BeanFactory.FACTORY_BEAN_PREFIX 开头，就会返回true。 BeanFactory.FACTORY_BEAN_PREFIX 常量的声明： public interface BeanFactory { String FACTORY_BEAN_PREFIX = \"\u0026\"; } 结合上面的源码，如果 getBean() 时，传入的 beanName 是以 \u0026 开头，走到 getObjectForBeanInstance() 时，就不会执行 FactoryBean 的逻辑，而是直接返回 bean 实例。 ","date":"2020-11-28","objectID":"/posts/spring/07-factory-bean/:4:3","tags":["spring源码"],"title":"07 复杂对象的构建方式 - FactoryBean","uri":"/posts/spring/07-factory-bean/"},{"categories":["spring"],"content":"本章着重介绍了spring中在多个bean有相互依赖关系时，是怎么样进行依赖注入的。","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:0:0","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"1 什么是循环依赖 在我们日常开发中，肯定存在这种情况：bean A 某个成员是 bean B，bean B 中某个属性是 bean A。那A类和B类就是相互依赖的关系，也叫循环依赖。 当然，也可以是这种情况 A -\u003e B -\u003e C -\u003e D -\u003e E -\u003e A。这种关系也是循环依赖。 ","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:1:0","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"2 循环依赖在spring中的实现原理 @Service public class CyclicGoodsServiceImpl implements CyclicGoodsService { @Autowired private CyclicOrderService cyclicOrderService; @Override public CyclicOrderService getCyclicOrderService() { return cyclicOrderService; } } ","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:2:0","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"2.1 源码分析 在这之前，先看一个简单的循环依赖代码案例： @Service public class CyclicGoodsServiceImpl implements CyclicGoodsService { @Autowired private CyclicOrderService cyclicOrderService; @Override public CyclicOrderService getCyclicOrderService() { return cyclicOrderService; } } @Service public class CyclicOrderServiceImpl implements CyclicOrderService { @Autowired private CyclicGoodsService cyclicGoodsService; @Override public CyclicGoodsService getCyclicGoodsService() { return cyclicGoodsService; } } @Slf4j public class ApplicationContextTest { @Test public void testCyclicDependence(){ AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(\"top.wlz922.cyclic\"); CyclicGoodsService goodsService = context.getBean(CyclicGoodsService.class); CyclicOrderService orderService = context.getBean(CyclicOrderService.class); log.debug(goodsService.toString()); log.debug(orderService.toString()); } } 只是简单的打印一下两个Service类中属性的值，很明显是注入成功了。 以下是打印的内容： 19:34:42.334 [main] DEBUG top.wlz922.test.context.ApplicationContextTest 36 - top.wlz922.cyclic.CyclicGoodsServiceImpl@7fa98a66 19:34:42.335 [main] DEBUG top.wlz922.test.context.ApplicationContextTest 37 - top.wlz922.cyclic.CyclicOrderServiceImpl@15ff3e9e 前面的文章中已经分析过，spring中获取bean实例的方法是getBean()。在容器启动的时候，会调用这些方法，实例化单例bean实例。 直接来到doGetBean()，看以下代码： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { protected \u003cT\u003e T doGetBean(final String name, @Nullable final Class\u003cT\u003e requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { //转换beanName，这里传入进来的beanName可能是以\u0026开头的，这里会截掉\u0026 final String beanName = transformedBeanName(name); Object bean; /* TODO 这里多级缓存用于解决循环依赖问题。 注：循环依赖只能是属性见的依赖，不能是构造函数中参数的循环依赖。 从缓存（一级二级三级缓存依次获取，获取到就返回）中获取单例实例，如果获取到并且是无参构造函数，则将bean变量的值赋值。 */ // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null \u0026\u0026 args == null) { // 省略无关代码 // 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 // 否则将bean强转为FactoryBean类型，并调用getObject()方法返回。 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } // 省略无关代码... return (T) bean; } } 先跳过无关代码，看关键点。从上面代码中可以看出，在doGetBean()中先调用了getSingleton()，如果这个值不为空就调用getObjectForBeanInstance()，经过一定的处理（先不要关心具体处理了什么），返回这个bean实例。 可以先分析，从接收变量的变量名sharedInstance就可以看出来，这是一个bean实例。关键点就在getSingleton()方法，这里可能会获取到一个bean实例。 下面是 getSingleton() 源码： public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry { /** 一级缓存 里面存储的是bean实例，在bean实例化完成、依赖注入、代理生成等流程全部完成之后，会存储到这个容器中 */ /** Cache of singleton objects: bean name to bean instance. */ private final Map\u003cString, Object\u003e singletonObjects = new ConcurrentHashMap\u003c\u003e(256); /** * 三级缓存，在单例bean刚刚创建完成时，会将其封装成一个ObjectFactory对象，存储到这个容器中。键值是beanName。 * 从源码中可以看到，实际上是提供了一些通过BeanPostProcessor进行的扩展操作。这里不会执行，只是把这个扩展操作流程封装起来。 * 实际上，这里封装的一个函数式接口，在这里可以通过BeanPostProcessor进行一些扩展操作，其节点是bean实例化之后， * 在真正getBean时，会触发调用。 */ /** Cache of singleton factories: bean name to ObjectFactory. */ private final Map\u003cString, ObjectFactory\u003c?\u003e\u003e singletonFactories = new HashMap\u003c\u003e(16); /** * 二级缓存 从三级缓存获取后，会将bean实例存储到二级缓存，并从三级缓存中移除。这里封装了一个函数式接口的匿名实例， * 依赖注入过程中通过getBean方法获取这个实例时，可以对其进行一些指定操作，比如说aop代理对象生成，就可能在这里触发。 */ /** Cache of early singleton objects: bean name to bean instance. */ private final Map\u003cString, Object\u003e earlySingletonObjects = new HashMap\u003c\u003e(16); protected Object getSingleton(String beanName, boolean allowEarlyReference) { /** * 从一级缓存中取，如果有值，则返回。否则依次查找二级、三级缓存，如果最终从三级缓存中拿到值， * 则将bean对象升级到二级缓存，并把原值从三级缓存中移除。 */ Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null \u0026\u0026 isSingletonCurrentlyInCreation(beanName)) { synchronized (this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null \u0026\u0026 allowEarlyReference) { ObjectFactory\u003c?\u003e singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.ge","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:2:1","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"2.2 源码中要注意的细节 注意\r\r构造函数中的依赖注入不可以循环依赖，多例依赖注入也不可以循环依赖。 构造函数不允许循环依赖：很容易明白，如果想要创建一个对象，比如调用它的构造函数，即使反射调用也是如此。如果A构造函数依赖B，B构造函数中依赖A，那么构造函数就无法调用完成，对象也就无从创建。永远也拿不到提前暴露的对象引用。 多例情况：不允许循环依赖，由于是多例，每次getBean都会创建新的实例，假如代码中定义了有循环依赖的属性，如果被允许，就会陷入死循环。 \r\r 多例情况，如果有循环依赖，会抛出异常，源码如下： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { protected \u003cT\u003e T doGetBean(final String name, @Nullable final Class\u003cT\u003e requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { // Fail if we're already creating this bean instance: // We're assumably within a circular reference. // 多例不支持循环引用。多例时，如果返回指定的原型bean是否正在创建中，则抛出异常。 if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } } } 构造函数中如果有循环依赖，源码ConstructorResolver类中有这段代码，抛出异常： try { // 省略无关代码，如果这里有构造函数中的循环依赖，则抛出异常 }catch (BeansException ex) { throw new UnsatisfiedDependencyException( mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex); } ","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:2:2","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"2.3 流程梳理 例如有A、B两个类进行实例化，分别将对方的实例注入到自身成员中，代码如下（前文中类似案例）： @Service public class A { @Autowired private B b; } @Service public class B { @Autowired private A a; } 分析上面代码的执行流程： A 类无参构造函数实例化后， 设置三级缓存。 A 类 populateBean 进行依赖注入， 这里触发了属性 B 的 getBean 操作。 B 类无参构造函数实例化后，设置三级缓存。 B 类 populateBean 进行依赖注入，这里触发了属性 A 的 getBean 操作 A 类之前正在实例化， singletonsCurrentlyInCreation 集合中有已经有这个 A 实例了，三级缓存里面也有了，所以这时候是从三级缓存中拿到的提前暴露的 A 实例，该实例还没有进行属性 B 的依赖注入，属性 B 为空。 B 类拿到了 A 的提前暴露实例注入到属性 A 中了。 B 类实例化已经完成，B 类的实例化是由 A 类实例化中属性 B 的依赖注入触发的 getBean 操作进行的，现在 B 已经实例化，所以 A 类中属性 B 就可以完成依赖注入了，这时候 A 类 B 属性已经有值了。 B 类 A 属性指向的就是 A 类实例堆空间，所以这时候 B 类 A 属性也会有值了。 ","date":"2020-11-27","objectID":"/posts/spring/06-cyclic-dependence/:2:3","tags":["spring源码"],"title":"06 循环依赖的实现原理","uri":"/posts/spring/06-cyclic-dependence/"},{"categories":["spring"],"content":"详细解读spring中bean的实例化流程，由于篇幅原因，循环依赖、一些流程节点的详细解析在后续文章中讨论。","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:0:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"1 常见的ApplicationContext实现类： spring容器都是从构造一个ApplicationContext对象开始的，以下是spring中常见的ApplicationContext实现。 容器：AbstractApplicationContext 抽象父类，核心(模板)方法 refresh()。 ClassPathXmlApplicationContext - XML方式启动。 AnnotationConfigWebApplicationContext - 注解方式启动，对局部代码进行测试时比较好用。 AnnotationConfigServletWebServerApplicationContext - SpringBoot启动默认使用的上下文类。 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:1:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"2 核心方法refresh() 。 在spring容器启动时，会调用到核心方法refrsh()。这个方法定义了spring容器初始化核心流程。包含创建beanFactory、XML解析、注解支持、后置处理器注册执行、BeanPostProcessor注册、Bean实例化等节点。 以下是spring中refresh()源码： public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext { @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. // 不太重要，预刷新，做一些准备工作。记录了启动时间戳，标记为活动，非关闭状态。 prepareRefresh(); /** * TODO 重点：解析xml配置文件，创建beanFactory，包装BeanDefinition */ // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 注册一些对事件、监听器等的支持 prepareBeanFactory(beanFactory); // 钩子方法，BeanFactory创建后，对BeanFactory的自定义操作。 // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // TODO 重点：这里调用了postProcessBeanDefinitionRegistry(registry);springboot中很多激活自动配置的注解都是通过这里导入的。 // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // TODO 重点：从beanFactory中获取所有的BeanPostProcessor，优先进行getBean操作，实例化 // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // 国际化支持 // Initialize message source for this context. initMessageSource(); // 初始化ApplicationEventMulticaster。 如果上下文中未定义，则使用SimpleApplicationEventMulticaster。 // Initialize event multicaster for this context. initApplicationEventMulticaster(); // 钩子方法，springBoot中的嵌入式tomcat就是通过此方法实现的 // Initialize other special beans in specific context subclasses. onRefresh(); // 监听器注册 // Check for listener beans and register them. registerListeners(); // TODO 重点方法：完成容器中bean的实例化，及代理的生成等操作。 // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // 完成此上下文的刷新，调用LifecycleProcessor的onRefresh（）方法并发布 // Last step: publish corresponding event. finishRefresh(); // ... 省略无关代码 } } } ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:2:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"3 Bean实例化入口，getBean() bean实例化的入口是getBean()。对于单例Bean（实际开发中大多数都是单例），在初始化过程中，是从refresh()中，调用到finishBeanFactoryInitialization()，然后调用到preInstantiateSingletons()。 在preInstantiateSingletons()中（DefaultListableBeanFactory类中），调用到了getBean()，源码如下： public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable { @Override public void preInstantiateSingletons() throws BeansException { // 容器中所有的beanName，循环、实例化 // Iterate over a copy to allow for init methods which in turn register new bean definitions. // While this may not be part of the regular factory bootstrap, it does otherwise work fine. List\u003cString\u003e beanNames = new ArrayList\u003c\u003e(this.beanDefinitionNames); // 循环调用，进行实例化 // Trigger initialization of all non-lazy singleton beans... for (String beanName : beanNames) { RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 非抽象的、单例的、并且非懒加载的，才会在容器启动时就实例化。 if (!bd.isAbstract() \u0026\u0026 bd.isSingleton() \u0026\u0026 !bd.isLazyInit()) { if (isFactoryBean(beanName)) { Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) { final FactoryBean\u003c?\u003e factory = (FactoryBean\u003c?\u003e) bean; boolean isEagerInit; if (System.getSecurityManager() != null \u0026\u0026 factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged((PrivilegedAction\u003cBoolean\u003e) ((SmartFactoryBean\u003c?\u003e) factory)::isEagerInit, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean \u0026\u0026 ((SmartFactoryBean\u003c?\u003e) factory).isEagerInit()); } if (isEagerInit) { getBean(beanName); } } } else { getBean(beanName); } } } } } 注意\r\r从以上源码中可以看到，在已经搜集好的BeanDefinition集合中，只有非抽象的、单例的、并且非懒加载的，才会在容器启动时就实例化。\r\r ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:3:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"4 实例化主流程 暂且忽略无关代码，仅关注单例情况下，spring容器启动过程中bean的实例化。 public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { @SuppressWarnings(\"unchecked\") protected \u003cT\u003e T doGetBean(final String name, @Nullable final Class\u003cT\u003e requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { /* TODO 重要程度 5 单例实例第一次创建bean入口，这里的getSingleton方法中，调用了参数中匿名对象的getObject() 在bean创建完成后，将bean放入到一级缓存，并从二三级缓存中移除:addSingleton(beanName, singletonObject); */ // Create bean instance. if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -\u003e { try { //创建Bean实例 return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); /* TODO 重要程度 5 如果bean不是FactoryBean类型或者beanName以\u0026开头，则直接返回。 否则调用FactoryBean的getObject(),且将返回的bean替换为getObject()的返回值。 FactoryBean接口很重要，具体应用场景见FactoryBean接口注释。 */ bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } } } 其中有三个关键的方法，分别是getSingleton()、函数接口（ObjectFactory）中的createBean()、以及最后调用的getObjectForBeanInstance()。 getSingleton()中调用到了匿名函数中的getObject()，这个getObject就是外围方法中的lambda表达式中的方法，这里面调用了createBean()。 来到createBean(): public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { @Override protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { // ...省略无关代码 // 这里如果满足条件，会调用 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()和 // BeanPostProcessor.postProcessAfterInitialization()，直接返回。 // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } // ...省略无关代码 //创建Bean实例 Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isTraceEnabled()) { logger.trace(\"Finished creating instance of bean '\" + beanName + \"'\"); } return beanInstance; } } 在createBean中，doCreateBean()是真正创建Bean实例的方法。在此之前，spring预留了一个扩展点，通过实现InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()方法，可以通过BeanPostProcessor返回一个实例，这时候就不会再调用doCreateBean了。 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()的调用逻辑（源码中文注释中，详细描述了它的调用过程）： public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { @Nullable protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) { Object bean = null; // 如果满足条件，会在这里通过InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()进行实例化。 // 如果此方法最终返回的值不为空，则会调用所有BeanPostProcessor的postProcessAfterInitialization()， // 标记是否已经提前实例化了bean，然后返回。 if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) { // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() \u0026\u0026 hasInstantiationAwareBeanPostProcessors()) { Class\u003c?\u003e targetType = determineTargetType(beanName, mbd); if (targetType != null) { bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) { bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); } } } mbd.beforeInstantiationResolved = (bean != null); } return bean; } } 在doCreateBean中，经历了以下调用流程。 createBeanInstance：创建bean实例，这里真正创建了bean的实例。 applyMergedBeanDefinitionPostProcessors：这里是BeanPostProcessor的一个扩展点，添加了PostConstruct、PreDestroy、Autowired、Value、Inject注解的支持。官方注释是：将MergedBeanDefinitionPostProcessors应用于指定的bean定义，调用其{@code postProcessMergedBeanDefinition}方法。 populateBean：完成了依赖注入。其原理是通过调用InstantiationAwareBeanPostProcessor.postProcessProperties()（spring5.1版本开始）、InstantiationAwareBeanPostProcessor.postProcessPropertyValues()（spring5.1版本之前）。也是一个BeanPostProcessor扩展点。 initializeBean：初始化bean。bean的init","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:4:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"5 创建实例，createBeanInstance 在创建bean实例中，主要经历了一下流程： 判断，只有public修饰的类，才可以被创建，否则直接抛出异常。 通过BeanDefinition中的回调，来创建Bean实例。 使用FactoryMethod来创建实例，factory-method标签属性，或者@bean注解。 重新创建相同的Bean。 通过构造函数注入参数。 使用无参构造函数。（这里是重点，大多数情况下，都是使用的无参构造。） 任何一个流程有结果，就会直接创建bean的实例，并返回。 从源码中可以清晰的看出以上结论： public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) { // Make sure bean class is actually resolved at this point. Class\u003c?\u003e beanClass = resolveBeanClass(mbd, beanName); // 只有public修饰的class才可以被创建 if (beanClass != null \u0026\u0026 !Modifier.isPublic(beanClass.getModifiers()) \u0026\u0026 !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); } // 通过BeanDefinition中的回调，来创建bean实例。一般不会走到这个条件里。 Supplier\u003c?\u003e instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) { return obtainFromSupplier(instanceSupplier, beanName); } // 使用FactoryMethod创建bean实例。factory-method标签属性，或者@Bean注解标注的方法，会从这里创建实例。 if (mbd.getFactoryMethodName() != null) { return instantiateUsingFactoryMethod(beanName, mbd, args); } // 重新创建相同bean，会走到这里。 // Shortcut when re-creating the same bean... boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } if (resolved) { if (autowireNecessary) { return autowireConstructor(beanName, mbd, null, null); } else { return instantiateBean(beanName, mbd); } } // 判断是否是通过构造函数注入参数，如果是，则通过@Autowired标注的构造函数实例化。 // Candidate constructors for autowiring? Constructor\u003c?\u003e[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { return autowireConstructor(beanName, mbd, ctors, args); } // 默认构造的首选函数 // Preferred constructors for default construction? ctors = mbd.getPreferredConstructors(); if (ctors != null) { return autowireConstructor(beanName, mbd, ctors, null); } // 使用无参构造实例化bean，实际大多数bean的实例化，都是走的这个方法。 // No special handling: simply use no-arg constructor. return instantiateBean(beanName, mbd); } } 记录一下无参构造函数创建实例的过程： getInstantiationStrategy()：获取bean的实例化策略对象，默认使用的CglibSubclassingInstantiationStrategy。 instantiate(mbd, beanName, parent)：实例化bean。 instantiate -\u003e BeanUtils.instantiateClass() -\u003e ctor.newInstance()。反射调用无参构造函数，创建对象。 源码如下： public class SimpleInstantiationStrategy implements InstantiationStrategy { // 第一步 @Override public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) { // Don't override the class with CGLIB if no overrides. if (!bd.hasMethodOverrides()) { // 省略无关代码... // 获取无参构造函数 constructorToUse = clazz.getDeclaredConstructor(); bd.resolvedConstructorOrFactoryMethod = constructorToUse; // 省略无关代码... // TODO 实例化bean return BeanUtils.instantiateClass(constructorToUse); } else { // Must generate CGLIB subclass. return instantiateWithMethodInjection(bd, beanName, owner); } } } public abstract class BeanUtils { // 第二步 public static \u003cT\u003e T instantiateClass(Constructor\u003cT\u003e ctor, Object... args) throws BeanInstantiationException { Assert.notNull(ctor, \"Constructor must not be null\"); // 设置构造函数setAccessible=true // newInstance:反射调用构造函数，创建bean对象。 ReflectionUtils.makeAccessible(ctor); return (KotlinDetector.isKotlinReflectPresent() \u0026\u0026 KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ? KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args)); // 省略无关代码... } } 源码中最后一行 ctor.newInstance(args) 创建了bean实例。然后逐层向上返回。 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:5:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"6 注解支持，applyMergedBeanDefinitionPostProcessors 这里执行了MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()方法。spring会加载在之前的流程中注册的MergedBeanDefinitionPostProcessor（BeanPostProcessor的子接口），并对其进行调用。比较典型的两个类，完成了@Autowried、@Value、@Injected、@PostConstruct、@PreDestroy等注解的支持 调用入口源码如下： public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class\u003c?\u003e beanType, String beanName) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof MergedBeanDefinitionPostProcessor) { MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp; bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName); } } } } 两个比较典型的实现：AutowiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:6:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"6.1 AutowiredAnnotationBeanPostProcessor AutowiredAnnotationBeanPostProcessor中存储了需要@Autowired注入的一些信息映射。 构造函数中添加了对应注解的支持，postProcessMergedBeanDefinition()中查找带有Autowired注解的成员的属性信息信息，并将搜集结果封装缓存起来。 public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { /** * 在依赖注入之前，调用此方法搜集需要依赖注入的类的信息，并封装成InjectionMetadata对象，缓存到当前BeanPostProcessor实例中。 * * @param beanDefinition the merged bean definition for the bean * @param beanType the actual type of the managed bean instance * @param beanName the name of the bean */ @Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class\u003c?\u003e beanType, String beanName) { // 查找带有Autowired注解的成员的属性信息信息。 InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); } } 此类完成了对@AutoWried、@Value、@Injected注解的支持。 执行buildAutowiringMetadata方法，完成的注解支持，之后会把结果缓存到injectionMetadataCache变量中。 构建元数据的过程： 循环目标Class的所有字段，查找@Autowired注解。如果查找到，将注解属性封装成AutowiredFieldElement，并封装到一个list中。 循环目标Class的所有方法，查找@Autowired注解，如果找到，将注解属性封装成AutowiredMethodElement，并封装到一个list中。 将以上两个步骤得到的结果，封装为InjectionMetadata，返回。即InjectionMetadata中包含了需要@Autowired的字段和方法。 public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { // 无参构造函数中添加了对应注解的支持 public AutowiredAnnotationBeanPostProcessor() { // 初始化autowiredAnnotationTypes，这里添加了Autowired Value Inject注解的支持 this.autowiredAnnotationTypes.add(Autowired.class); this.autowiredAnnotationTypes.add(Value.class); try { this.autowiredAnnotationTypes.add((Class\u003c? extends Annotation\u003e) ClassUtils.forName(\"javax.inject.Inject\", AutowiredAnnotationBeanPostProcessor.class.getClassLoader())); logger.trace(\"JSR-330 'javax.inject.Inject' annotation found and supported for autowiring\"); } catch (ClassNotFoundException ex) { // JSR-330 API not available：simply skip. } } private InjectionMetadata buildAutowiringMetadata(final Class\u003c?\u003e clazz) { List\u003cInjectionMetadata.InjectedElement\u003e elements = new ArrayList\u003c\u003e(); Class\u003c?\u003e targetClass = clazz; do { final List\u003cInjectionMetadata.InjectedElement\u003e currElements = new ArrayList\u003c\u003e(); // 循环所有的字段，并以此字段为参数，执行回调。 ReflectionUtils.doWithLocalFields(targetClass, field -\u003e { // 查找当前带有autowiredAnnotationTypes中支持的注解的字段。 AnnotationAttributes ann = findAutowiredAnnotation(field); if (ann != null) { if (Modifier.isStatic(field.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\"Autowired annotation is not supported on static fields: \" + field); } return; } boolean required = determineRequiredStatus(ann); currElements.add(new AutowiredFieldElement(field, required)); } }); // 循环所有的方法，并以此方法为参数，执行回调。 ReflectionUtils.doWithLocalMethods(targetClass, method -\u003e { Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) { return; } // 查找当前带有autowiredAnnotationTypes中支持的注解的方法。 AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod); if (ann != null \u0026\u0026 method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) { if (Modifier.isStatic(method.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\"Autowired annotation is not supported on static methods: \" + method); } return; } if (method.getParameterCount() == 0) { if (logger.isInfoEnabled()) { logger.info(\"Autowired annotation should only be used on methods with parameters: \" + method); } } boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); currElements.add(new AutowiredMethodElement(method, required, pd)); } }); elements.addAll(0, currElements); targetClass = targetClass.getSuperclass(); } while (targetClass != null \u0026\u0026 targetClass != Object.class); return new InjectionMetadata(clazz, elements); } @Nullable private AnnotationA","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:6:1","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"6.2 CommonAnnotationBeanPostProcessor CommonAnnotationBeanPostProcessor是InitDestroyAnnotationBeanPostProcessor的子类，也是一个BeanPostProcessor。设置了@PostConstruct、@PreDestroy、@Resource注解的支持。 注意\r\r 两个比较重要的成员变量（初始化、销毁方法）是在InitDestroyAnnotationBeanPostProcessor定义的。 @PostConstruct、@PreDestroy注解支持是在CommonAnnotationBeanPostProcessor的无参构造函数中设置的。 \r\r public class InitDestroyAnnotationBeanPostProcessor implements DestructionAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor, PriorityOrdered, Serializable { @Nullable private Class\u003c? extends Annotation\u003e initAnnotationType; @Nullable private Class\u003c? extends Annotation\u003e destroyAnnotationType; } public class CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor implements InstantiationAwareBeanPostProcessor, BeanFactoryAware, Serializable { public CommonAnnotationBeanPostProcessor() { // 这里设置了PostConstruct、PreDestroy注解的支持。 setOrder(Ordered.LOWEST_PRECEDENCE); setInitAnnotationType(PostConstruct.class); setDestroyAnnotationType(PreDestroy.class); ignoreResourceType(\"javax.xml.ws.WebServiceContext\"); } } 搜集支持的元素并封装的流程： 先执行父类的搜集逻辑，这里设置了@PostConstruct、@PreDestroy注解的支持。 执行本类中的搜集逻辑，这里设置了@Resource注解的支持。 public class CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor implements InstantiationAwareBeanPostProcessor, BeanFactoryAware, Serializable { @Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class\u003c?\u003e beanType, String beanName) { // 先调用父类的方法，查找支持的元素，进行封装 super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName); // 在调用本类中的方法，也是查找支持的元素，进行封装 InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); } } 在真正执行搜集注解逻辑之前，有一个锁的使用方式。父类和子类此方法中都有体现。先不加锁获取，如果为空，再加锁，尝试获取，如果加锁下获取还是空，则执行搜集逻辑，搜集完之后会放入缓存。缓存的map是非线程安全的。 如果我们存储一组数据，这组数据只需要存储一次，后面全部都是get操作，那么就可以使用这种非线程安全的集合（非线程安全的集合的get操作性能远高于线程安全集合）。在存储的时候，以先重试，再加锁的方式进行处理。更多关于线程安全的问题，在并发编程的知识模块里记录。 这里列举一个父类中的方法： public class InitDestroyAnnotationBeanPostProcessor implements DestructionAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor, PriorityOrdered, Serializable { private LifecycleMetadata findLifecycleMetadata(Class\u003c?\u003e clazz) { if (this.lifecycleMetadataCache == null) { // Happens after deserialization, during destruction... return buildLifecycleMetadata(clazz); } // Quick check on the concurrent map first, with minimal locking. LifecycleMetadata metadata = this.lifecycleMetadataCache.get(clazz); if (metadata == null) { synchronized (this.lifecycleMetadataCache) { metadata = this.lifecycleMetadataCache.get(clazz); if (metadata == null) { // 上面代码是缓存，这里加锁的技巧，先无锁尝试，尝试失败再加锁。 // 细节：加锁中需要再次尝试获取一次。 metadata = buildLifecycleMetadata(clazz); this.lifecycleMetadataCache.put(clazz, metadata); } return metadata; } } return metadata; } } InitDestroyAnnotationBeanPostProcessor中搜集初始化、销毁方法的逻辑：根据成员变量（赋值的逻辑前文中有）initAnnotationType、destroyAnnotationType的类型，循环判断方法中是否有对应注解，有就缓存到对应集合中。遍历完所有方法之后将最终的结果封装成LifecycleMetadata 代码如下： public class InitDestroyAnnotationBeanPostProcessor implements DestructionAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor, PriorityOrdered, Serializable { private LifecycleMetadata buildLifecycleMetadata(final Class\u003c?\u003e clazz) { List\u003cLifecycleElement\u003e initMethods = new ArrayList\u003c\u003e(); List\u003cLifecycleElement\u003e destroyMethods = new ArrayList\u003c\u003e(); Class\u003c?\u003e targetClass = clazz; do { final List\u003cLifecycleElement\u003e currInitMethods = new ArrayList\u003c\u003e(); final List\u003cLifecycleElement\u003e currDestroyMethods = new ArrayList\u003c\u003e(); // 循环遍历所有的方法，查找初始化、销毁方法，如果查找到，就封装为LifecycleMetadata返回。 ReflectionUtils.doWithLocalMethods(targetClass, method -\u003e { if (this.initAnnotationType != null \u0026\u0026 method.isAnnotationPresent(this.initAnnotationType)) { LifecycleElement element = new LifecycleElement(method); currInitMethods.add(element); if (logger.isTraceEnabled()) { logger.trace(\"Found init method on class [\" + clazz.getName() + \"]: \" + method); } } if (this.destroyAnnotationType != null \u0026\u0026 method.isAnnotationPres","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:6:2","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"7 依赖注入，populateBean populateBean的作用是完成bean属性的依赖注入。 依赖注入之前，如果BeanDefinition是合成的，有InstantiationAwareBeanPostProcessor实例存在于ioc容器，那么将会执行容器中所有InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()，如果有一个方法返回false，则直接中断并返回。依赖注入不再进行。（它的用途暂时未知，如果这里返回false导致了一些问题，那么排查起来也是比较困难的，因为它没有任何提示信息输出） 通过调用InstantiationAwareBeanPostProcessor.postProcessProperties()完成属性的依赖注入（spring5.1之前的版本调用的postProcessPropertyValues()）。 由于是遍历容器中注册的BeanPostProcessor，找出是InstantiationAwareBeanPostProcessor类型的，这里不同的注入方式会有不同的实现类。与前文中说明的搜集依赖注入有关注解的方法是一样的，实现类也是同一个。遍历过程中会一个个的调用。由于这些BeanPostProcessor中在前面流程中已经缓存了需要依赖注入的内容。这里就可以根据缓存的内容进行获取，依次设置值到对应属性中了。 这里列举几个常见的注入流程 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:7:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"7.1 AutowiredFieldElement 它是对@Autowired标注在字段上的注入支持。 在前文中postProcessMergedBeanDefinition流程节点，添加@Autowired注解支持的时候，就把对应数据放入到了缓存中，成员变量injectionMetadataCache就是对应的缓存。 首先会调用findAutowiringMetadata()方法，获取元数据，这里直接从缓存injectionMetadataCache中拿的。 public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { // 这两个成员变量中，在前面执行postProcessMergedBeanDefinition时，已经缓存了需要注入的元数据。 private final Map\u003cString, InjectionMetadata\u003e injectionMetadataCache = new ConcurrentHashMap\u003c\u003e(256); @Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) { // 找到Autowiring注解标注的属性和方法，并封装为InjectionMetadata返回。 InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); // TODO 依赖注入的具体逻辑，重点看 metadata.inject(bean, beanName, pvs); // 省略无关代码... return pvs; } } 来到inject()方法，可以看到，遍历InjectionMetadata中缓存的injectedElements，然后执行每一个InjectedElement的inject()方法，这里就是@Autowired注入的核心逻辑： public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { Collection\u003cInjectedElement\u003e checkedElements = this.checkedElements; Collection\u003cInjectedElement\u003e elementsToIterate = (checkedElements != null ? checkedElements : this.injectedElements); if (!elementsToIterate.isEmpty()) { for (InjectedElement element : elementsToIterate) { // 执行依赖注入 element.inject(target, beanName, pvs); } } } } 从前文中已经知道，@Autowired的注解搜集，把字段和方法分成了两类来进行封装，分别是：AutowiredFieldElement、AutowiredMethodElement。 先来到AutowiredFieldElement的inject()方法： private class AutowiredFieldElement extends InjectionMetadata.InjectedElement { @Override protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { // 字段的自动注入 Field field = (Field) this.member; Object value; if (this.cached) { value = resolvedCachedArgument(beanName, this.cachedFieldValue); } else { DependencyDescriptor desc = new DependencyDescriptor(field, this.required); desc.setContainingClass(bean.getClass()); Set\u003cString\u003e autowiredBeanNames = new LinkedHashSet\u003c\u003e(1); Assert.state(beanFactory != null, \"No BeanFactory available\"); TypeConverter typeConverter = beanFactory.getTypeConverter(); try { // 处理依赖项 value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); } catch (BeansException ex) { throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex); } // 省略无关代码... } // 执行字段赋值逻辑。 if (value != null) { ReflectionUtils.makeAccessible(field); field.set(bean, value); } } } 获取依赖对象的方法调用链： |-\u003e resolveDependency |-|-\u003e doResolveDependency |-|-|-\u003e findAutowireCandidates |-|-|-|-\u003e addCandidateEntry |-|-|-|-|-\u003e descriptor.resolveCandidate |-|-|-|-|-|-\u003e beanFactory.getBean 最终还是调用到了getBean()方法。也就是经过一系列的处理，最终调用getBean()方法，获取到依赖的对象实例，返回，赋值。从上面代码可以看到，最后使用反射field.set()进行字段赋值。 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:7:1","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"7.2 AutowiredMethodElement 它是对@Autowired标注在方法上的注入支持。 通过方法@Autowired注入的流程是：先获取参数列表中依赖的实例对象，最终一定是会调用到getBean()方法。然后通过反射调用对应方法。 来到AutowiredMethodElement.inject()方法 private class AutowiredMethodElement extends InjectionMetadata.InjectedElement { @Override protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { if (checkPropertySkipping(pvs)) { return; } Method method = (Method) this.member; Object[] arguments; if (this.cached) { // Shortcut for avoiding synchronization... arguments = resolveCachedArguments(beanName); } else { Class\u003c?\u003e[] paramTypes = method.getParameterTypes(); arguments = new Object[paramTypes.length]; DependencyDescriptor[] descriptors = new DependencyDescriptor[paramTypes.length]; Set\u003cString\u003e autowiredBeans = new LinkedHashSet\u003c\u003e(paramTypes.length); Assert.state(beanFactory != null, \"No BeanFactory available\"); TypeConverter typeConverter = beanFactory.getTypeConverter(); for (int i = 0; i \u003c arguments.length; i++) { MethodParameter methodParam = new MethodParameter(method, i); DependencyDescriptor currDesc = new DependencyDescriptor(methodParam, this.required); currDesc.setContainingClass(bean.getClass()); descriptors[i] = currDesc; try { // 获取参数中依赖的对象 Object arg = beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter); if (arg == null \u0026\u0026 !this.required) { arguments = null; break; } arguments[i] = arg; } catch (BeansException ex) { throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(methodParam), ex); } } // 省略无关代码... } if (arguments != null) { try { // 反射调用 ReflectionUtils.makeAccessible(method); method.invoke(bean, arguments); } catch (InvocationTargetException ex) { throw ex.getTargetException(); } } } } 获取依赖对象的方法调用链： |-\u003e resolveDependency |-|-\u003e doResolveDependency |-|-|-\u003e findAutowireCandidates |-|-|-|-\u003e addCandidateEntry |-|-|-|-|-\u003e descriptor.resolveCandidate |-|-|-|-|-|-\u003e beanFactory.getBean 仔细看一下，其实获取依赖对象本身，是和使用字段注入的获取方式一样的，调用的方法没有任何变化。不同之处在于外围方法，字段注入时只获取一个实例，方法则可能是多个实例，是一个数组，所以方法获取依赖属性时，以遍历的方式去执行以上流程的。 ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:7:2","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"7.3 ResourceElement 它是对@Resource注解标注在字段/方法上的注入支持。 与上面流程一样，来到inject()方法，这里调用到了父类InjectedElement的inject()方法： public abstract static class InjectedElement { protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs) throws Throwable { if (this.isField) { Field field = (Field) this.member; ReflectionUtils.makeAccessible(field); // 字段赋值 关键点看getResourceToInject field.set(target, getResourceToInject(target, requestingBeanName)); } else { if (checkPropertySkipping(pvs)) { return; } try { Method method = (Method) this.member; ReflectionUtils.makeAccessible(method); // 方法赋值 关键点看getResourceToInject method.invoke(target, getResourceToInject(target, requestingBeanName)); } catch (InvocationTargetException ex) { throw ex.getTargetException(); } } } @Override protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) { return (this.lazyLookup ? buildLazyResourceProxy(this, requestingBeanName) : getResource(this, requestingBeanName)); } } 获取依赖对象的方法调用链： |-\u003e getResourceToInject |-|-\u003e getResource |-|-|-\u003e autowireResource |-|-|-|-\u003e factory.getBean ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:7:3","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"8 AOP、事务支持，initializeBean 外围方法节点： postProcessBeforeInitialization() bean实例化之后，初始化方法执行之前调用。 invokeInitMethods() bean的初始化方法，@PostContructor注解的方法、或者配置文件配置的。 postProcessAfterInitialization() bean实例化之后，初始化方法执行之后调用，也是AOP的入口。事务的入口不在这，但跟它有关，事务的Advisor对象是在这里填充到AOP的执行链的。 源码如下： public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory { protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // BeanPostProcessor.postProcessBeforeInitialization() // 顾名思义，在bean实例创建完成并依赖注入后，初始化方法执行之前，会执行此方法。 // AOP的BeanPostProcessor也实现了这个方法，只是直接返回了原始对象。真正入口在后置处理。 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { // 执行初始化方法，InitializingBean实例的afterPropertiesSet，或者init-method或者@PostConstructor标注的方法 invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); } if (mbd == null || !mbd.isSynthetic()) { // BeanPostProcessor.postProcessAfterInitialization() // 顾名思义，在bean实例创建完成并依赖注入后，初始化方法执行之后，会执行此方法。 // AOP的入口，通过AspectJAwareAdvisorAutoProxyCreator生成代理对象 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean; } } 注意\r\r由于篇幅原因，这里只做initializeBean()方法的执行流程描述。关于SpringAop执行链的封装和动态代理生成以及执行原理，事务的支持、事务的七种传播属性实现原理及其表现形式。在别的文章中分析。\r\r ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:8:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":["spring"],"content":"9 临终方法注册，registerDisposableBeanIfNecessary beanFactory中有一个成员变量disposableBeans，这是一个map集合，里面就封装了bean销毁前需要调用的对象映射。键时beanName，值是DisposableBeanAdapter DisposableBeanAdapter中封装了destroyMethod以及List，没错，是一个list列表。因为可以设置多个销毁方法，且设置的方式也是有很多种，可以实现DisposableBean，或者注解方式，或者名称为close的无参数公共方法 ban的销毁前调用方法的注册，相对简单，这里贴两段代码： public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory { protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) { AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null); // BeanDefinition非多例，并且需要销毁。 if (!mbd.isPrototype() \u0026\u0026 requiresDestruction(bean, mbd)) { if (mbd.isSingleton()) { // Register a DisposableBean implementation that performs all destruction // work for the given bean: DestructionAwareBeanPostProcessors, // DisposableBean interface, custom destroy method. // 注册bean的销毁前调用的方法 registerDisposableBean(beanName, new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc)); } else { // A bean with a custom scope... Scope scope = this.scopes.get(mbd.getScope()); if (scope == null) { throw new IllegalStateException(\"No Scope registered for scope name '\" + mbd.getScope() + \"'\"); } scope.registerDestructionCallback(beanName, new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc)); } } } } public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry { public void registerDisposableBean(String beanName, DisposableBean bean) { synchronized (this.disposableBeans) { this.disposableBeans.put(beanName, bean); } } } ","date":"2020-11-26","objectID":"/posts/spring/05-spring-ioc-init/:9:0","tags":["spring源码"],"title":"05 Bean实例化整体流程","uri":"/posts/spring/05-spring-ioc-init/"},{"categories":null,"content":"留言板，留言给我","date":"2020-11-25","objectID":"/message-board/","tags":null,"title":"留言板","uri":"/message-board/"},{"categories":null,"content":"留言给我↓","date":"2020-11-25","objectID":"/message-board/:0:0","tags":null,"title":"留言板","uri":"/message-board/"},{"categories":["spring"],"content":"spring容器启动过程中，在创建BeanFactory、搜集BeanDefinition、实例化并调用BeanFactoryPostProcessor之后，会对BeanPostProcessor进行注册。","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/","tags":["spring源码"],"title":"04 BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:0:0","tags":["spring源码"],"title":"04 BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"1 BeanPostProcessor的作用 BeanPostProcessor是对SpringIOC容器中bean实例化的一些扩展，在bean实例化的关键节点进行了一些插桩。 真正实例化bean的方法是beanFactory.getBean()方法。而在bean实例化之前、实例化之后、依赖注入、初始化方法执行之前、初始化方法执行之后等节点进行一些钩子回调。BeanPostProcessor的作用就体现于此。 BeanPostProcessor接口只提供初始化方法执行前、后的节点操作。其余操作在它的子接口中定义。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:1:0","tags":["spring源码"],"title":"04 BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"2 BeanPostProcessor的体系结构 BeanPostProcessor及其关键子接口的方法定义-UML图\"\rBeanPostProcessor及其关键子接口的方法定义-UML图\r 上图详细注释了BeanPostProcessor及其子接口每个方法的作用节点，从BeanPostProcessor接口继承体系可以看出，BeanPostProcessor贯穿整个Spring容器中Bean的实例化流程。可以说，在Spring容器中，任何一个Bean的实例化，在其关键节点，都有BeanPostProcessor的存在。甚至可以说它是SpringIOC容器组成部分中最重要的一个类。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:2:0","tags":["spring源码"],"title":"04 BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"3 BeanPostProcessor的注册流程 以下是spring中BeanPostProcessor的源码： final class PostProcessorRegistrationDelegate { public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) { // 从beanDefinitionNames中获取所有BeanPostProcessor类型的beanName。 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); // 这里之所以要+1，因为在这个方法的结尾处，单独注册了一个BeanPostProcessor：ApplicationListenerDetector // Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors. int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount)); // Separate between BeanPostProcessors that implement PriorityOrdered, // Ordered, and the rest. // 实现了PriorityOrdered接口的。 List\u003cBeanPostProcessor\u003e priorityOrderedPostProcessors = new ArrayList\u003c\u003e(); // MergedBeanDefinitionPostProcessor类型的。 List\u003cBeanPostProcessor\u003e internalPostProcessors = new ArrayList\u003c\u003e(); // 实现了Ordered接口的。 List\u003cString\u003e orderedPostProcessorNames = new ArrayList\u003c\u003e(); // 没有实现排序接口的。 List\u003cString\u003e nonOrderedPostProcessorNames = new ArrayList\u003c\u003e(); // 对以上四种情况进行分别处理。 for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { orderedPostProcessorNames.add(ppName); } else { nonOrderedPostProcessorNames.add(ppName); } } // 注册BeanPostProcessors // First, register the BeanPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // 注册实现了Ordered接口的BeanPostProcessor。 // Next, register the BeanPostProcessors that implement Ordered. List\u003cBeanPostProcessor\u003e orderedPostProcessors = new ArrayList\u003c\u003e(); for (String ppName : orderedPostProcessorNames) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors); // 注册没有实现接口的BeanPostProcessor // Now, register all regular BeanPostProcessors. List\u003cBeanPostProcessor\u003e nonOrderedPostProcessors = new ArrayList\u003c\u003e(); for (String ppName : nonOrderedPostProcessorNames) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); // Finally, re-register all internal BeanPostProcessors. sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); } } 从上面代码可以看出，BeanPostProcessor的注册流程和BeanFactoryPostProcessor的注册流程类似。获取到BeanFactory中存储的BeanPostProcessor类型的beanName，然后对实现了不同排序接口的类、及没有实现排序接口的类分别进行getBean()操作、排序和注册。 spring会在不同的流程节点执行BeanPostProcessor及其子接口对应的方法。具体的实现类在后面的spring容器bean的实例化相关文章描述。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:3:0","tags":["spring源码"],"title":"04 BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"spring ioc容器初始化时，首先创建BeanFactory对象，搜集BeanDefinition，在完成之后，会优先先实例化BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor，并调用postProcessBeanDefinitionRegistry()、postProcessBeanFactory()方法","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/","tags":["spring源码"],"title":"03 BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 ","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:0:0","tags":["spring源码"],"title":"03 BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"1 BeanFactoryPostProcessor BeanFactoryPostProcessor中只有一个方法postProcessBeanFactory，实现了这个接口的类，会优先于其他常规的类实例化，并调用postProcessBeanFactory方法。 @FunctionalInterface public interface BeanFactoryPostProcessor { void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; } ","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:1:0","tags":["spring源码"],"title":"03 BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"2 BeanDefinitionRegistryPostProcessor BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子接口，同样的，它会优先与其他常规的类，提前实例化、加入到IOC容器，并会调用postProcessBeanDefinitionRegistry()方法，再调用postProcessBeanFactory()方法。 public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor { void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException; } ","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:2:0","tags":["spring源码"],"title":"03 BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"3 调用逻辑 首先搜集从BeanFactory中后去所有BeanDefinitionRegistryPostProcessor类型的beanName。 筛选出实现了PriorityOrdered接口的（筛选过程中会调用getBean()方法），并对其进行排序，然后进行遍历调用postProcessBeanDefinitionRegistry()。 筛选出实现了Ordered接口的，同上，进行getBean()，并排序，然后进行遍历调用postProcessBeanDefinitionRegistry()。 对没有实现PriorityOrdered接口且没有实现Ordered接口的BeanDefinitionRegistryPostProcessor进行排序、调用postProcessBeanDefinitionRegistry()。 上面的每一步调用postProcessBeanDefinitionRegistry()之前，会将其实力缓存到一个名为registryProcessors的List集合中，在以上步骤执行完，会调用BeanDefinitionRegistryPostProcessor.postProcessBeanFactory()方法 对没有实现BeanDefinitionRegistryPostProcessor但实现了BeanFactoryPostProcessor的类进行搜集。 分别筛选出实现了PriorityOrdered接口、Ordered接口、没有实现接口的类，对其进行排序、getBean()操作，调用postProcessBeanFactory()方法。 从源码中，我们可以很清晰的看到执行流程。源码逻辑如下： final class PostProcessorRegistrationDelegate { public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List\u003cBeanFactoryPostProcessor\u003e beanFactoryPostProcessors) { // 这里存储了已经调用过的BeanFactoryPostProcessor。 // BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子接口。 // 先调用BeanDefinitionRegistryPostProcessor的方法，然后是BeanFactoryPostProcessor // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set\u003cString\u003e processedBeans = new HashSet\u003c\u003e(); if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; // 这里面装的是实现了BeanFactoryPostProcessor接口的。 List\u003cBeanFactoryPostProcessor\u003e regularPostProcessors = new ArrayList\u003c\u003e(); // 这里面装的是实现了BeanDefinitionRegistryPostProcessor接口的。 List\u003cBeanDefinitionRegistryPostProcessor\u003e registryProcessors = new ArrayList\u003c\u003e(); // 对参数中传入的beanFactoryPostProcessors优先执行BeanDefinitionRegistryPostProcessor的方法，然后添加到registryProcessors中。 for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) { if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) { BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); } else { regularPostProcessors.add(postProcessor); } } // 记录当前注册的BeanDefinitionRegistryPostProcessor // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. List\u003cBeanDefinitionRegistryPostProcessor\u003e currentRegistryProcessors = new ArrayList\u003c\u003e(); // 从beanFactory中的beanDefinitionNames中获取所有的beanName。将实现了PriorityOrdered接口部分，放到处理过的bean容器中。 // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { // 这里进行了getBean操作。类的实例化就是通过此方法进行。 currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } // 对上面搜集到的BeanDefinitionRegistryPostProcessor进行排序、执行BeanDefinitionRegistryPostProcessor的方法 sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // 搜集实现了Ordered接口的BeanDefinitionRegistryPostProcessor，执行同上的逻辑。 // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName) \u0026\u0026 beanFactory.isTypeMatch(ppName, Ordered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } }// 排序、执行postProcessBeanDefinitionRegistry()方法 sortPostProcessors(current","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:3:0","tags":["spring源码"],"title":"03 BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"记录spring标签解析中，对标签属性解析的几个典型BeanDefinitionParser实现。","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 本文是对 Spring程序入口和XML解析 的知识点扩展，详细解析其中提到的BeanDefinitionParser的作用，以及一些典型的XML方式解析的实现类。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:0:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"1 BeanDefinitionParser接口的定义 public interface BeanDefinitionParser { @Nullable BeanDefinition parse(Element element, ParserContext parserContext); } 可以看到，BeanDefinitionParser只有一个方法，负责BeanDefinitaion的解析。参数有节点元素、解析上下文对象。 在Spring中有很多内置的BeanDefinitionParser实现类（之所以说内置，因为它也是可以扩展的），包括XML方式解析、注解方式解析等。 注意\r\rParserContext中封装了BeanDefinitionRegistry对象，用于BeanDefinition的注册。\r\r 关于此类的实例从哪里注册、parse方法从哪里调入进来的， Spring程序入口和XML解析 中有结尾处有详细说明。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:1:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2 ComponentScanBeanDefinitionParser实现流程解析 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2.1 ComponentScanBeanDefinitionParser中的属性 ComponentScanBeanDefinitionParser是BeanDefinitionParser的一个实现，用于解析\u003ccontext:component-scan/\u003e标签的属性。 这个类中定义了一些常量，这些常量是\u003ccontext:component-scan/\u003e中所有可能用到的属性。比如最常用到的base-package属性。 前面有提到，parse方法的参数中有Element。在解析Element时，会对Element的多个属性进行识别及处理。这些常量的作用就在于此，用来区分Element的不同属性，并做特定的处理。 以下是ComponentScanBeanDefinitionParser中定义的常量： public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { private static final String BASE_PACKAGE_ATTRIBUTE = \"base-package\"; private static final String RESOURCE_PATTERN_ATTRIBUTE = \"resource-pattern\"; private static final String USE_DEFAULT_FILTERS_ATTRIBUTE = \"use-default-filters\"; private static final String ANNOTATION_CONFIG_ATTRIBUTE = \"annotation-config\"; private static final String NAME_GENERATOR_ATTRIBUTE = \"name-generator\"; private static final String SCOPE_RESOLVER_ATTRIBUTE = \"scope-resolver\"; private static final String SCOPED_PROXY_ATTRIBUTE = \"scoped-proxy\"; private static final String EXCLUDE_FILTER_ELEMENT = \"exclude-filter\"; private static final String INCLUDE_FILTER_ELEMENT = \"include-filter\"; private static final String FILTER_TYPE_ATTRIBUTE = \"type\"; private static final String FILTER_EXPRESSION_ATTRIBUTE = \"expression\"; } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:1","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2.2 主流程方法parse() 步骤： 获取到标签中base-package属性的值，这个值是必须的。（否则会抛出异常，异常信息At least one base package must be specified）。 创建扫描器：ClassPathBeanDefinitionScanner（mybatis中的扫描器就是继承了它） 调用核心方法doScan（这里解析并注册了BeanDefinition） 注册组件registerComponents（ClassPathBeanDefinitionScanner中，最终是一个空方法，可以不看，BeanDefinition的注册在doScan中做了） public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { public BeanDefinition parse(Element element, ParserContext parserContext) { // 获取base-package属性 String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage); String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // Actually scan for bean definitions and register them. ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); // TODO 重点：这里执行了具体的解析逻辑。 Set\u003cBeanDefinitionHolder\u003e beanDefinitions = scanner.doScan(basePackages); registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:2","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2.3 configureScanner() 从以下源码可以看到，首先设置是否使用默认过滤器，然后创建扫描器ComponentScanBeanDefinitionParser，之后对其他属性进行一些设置。（关注源码中关键点就好，不然会越陷越深） public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { // 解析配置的属性，use-default-filters如果未定义，默认为true boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); } // 创建扫描器，其实mybatis中的扫描原理就来自于此，mybatis中的ClassPathMapperScanner继承了ClassPathBeanDefinitionScanner // Delegate bean definition registration to scanner class. ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters); // 下面的代码是对标签中其他属性的一些设置，其实就是把标签及其属性以java类的描述形式体现。 scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) { scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); } try { parseBeanNameGenerator(element, scanner); } catch (Exception ex) { parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause()); } try { parseScope(element, scanner); } catch (Exception ex) { parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause()); } parseTypeFilters(element, scanner, parserContext); return scanner; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:3","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2.4 核心方法doScan() 扫描出所有满足条件的类，并封装成BeanDefinition 循环扫描到的BeanDefinition集合，依次执行操作。 解析@Scope注解 对不同类型的BeanDefinition做不同处理，@Lazy、@DependOn等注解信息封装就是在这里设置的。 校验是否是需要实例化的BeanDefinition，如果为true，则将BeanDefinition包装成BeanDefinitionHolder（这个类里封装了实例名称、别名信息） 源码如下： public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { protected Set\u003cBeanDefinitionHolder\u003e doScan(String... basePackages) { Assert.notEmpty(basePackages, \"At least one base package must be specified\"); // 用来装所有扫描到的类的BeanDefinition对象。 Set\u003cBeanDefinitionHolder\u003e beanDefinitions = new LinkedHashSet\u003c\u003e(); for (String basePackage : basePackages) { // TODO 重点看：查找候选组件，封装成BeanDefinition。 Set\u003cBeanDefinition\u003e candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) { // 获取到ScopeMetadata，如果类中有@Scope注解，则会将值封装到这个实例中。然后设置到BeanDefinition中。 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); // 对不同类型的BeanDefinition做不同的处理。 if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } // 对不同类型的BeanDefinition做不同的处理，@Lazy、@DependOn等注解信息封装就是在这里设置的。 if (candidate instanceof AnnotatedBeanDefinition) { // 一些注解信息的封装 AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } // 校验是否是需要实例化的BeanDefinition，如果为true，则将BeanDefinition包装成BeanDefinitionHolder（这个类里封装了实例名称、别名信息） if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 注册BeanDefinition registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:4","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"2.5 findCandidateComponents原理解析 最终会执行到scanCandidateComponents()方法。从下面源码中可以看到，实际上就是根据\u003ccontext:component-scan/\u003e标签配置的base-package来扫描对应路径下的文件输入流，读取类文件信息。进而拿到Class对象，封装成BeanDefinition对象。然后向上返回，直到注册到BeanDefinitionRegistry中。 public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { private Set\u003cBeanDefinition\u003e scanCandidateComponents(String basePackage) { Set\u003cBeanDefinition\u003e candidates = new LinkedHashSet\u003c\u003e(); try { //根据路径扫描 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; // 获取指定包下匹配到的所有的资源对象。里面封装了InputStream，用来读取类文件。 Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(\"Scanning \" + resource); } if (resource.isReadable()) { try { // 封装成ScannedGenericBeanDefinition，这里封装了包下所有的类信息 MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); if (isCandidateComponent(metadataReader)) { // 创建BeanDefinition对象，将 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); // 判断是否是候选组件，如果是，就添加BeanDefinition对象 if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(\"Identified candidate component class: \" + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(\"Ignored because not a concrete top-level class: \" + resource); } } } else { if (traceEnabled) { logger.trace(\"Ignored because not matching any filter: \" + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( \"Failed to read candidate component class: \" + resource, ex); } } else { if (traceEnabled) { logger.trace(\"Ignored because not readable: \" + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); } return candidates; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:5","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"3 AspectJAutoProxyBeanDefinitionParser AspectJAutoProxyBeanDefinitionParser是对aop标签的aop:aspectj-autoproxy/的支持 源码： class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser { @Override @Nullable public BeanDefinition parse(Element element, ParserContext parserContext) { // 对aspectj-autoproxy属性的支持 AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 添加IncludePatterns extendBeanDefinition(element, parserContext); return null; } } 会走到这里： public abstract class AopConfigUtils { @Nullable public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary( BeanDefinitionRegistry registry, @Nullable Object source) { // 注入此类 AnnotationAwareAspectJAutoProxyCreator，本质还是一个BeanPostProcessor, // 实现了BeanPostProcessor的子接口：SmartInstantiationAwareBeanPostProcessor return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source); } } AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法中，注册了AnnotationAwareAspectJAutoProxyCreator的支持，这个类会在AOP知识点中详细阐述。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:3:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"4 AnnotationConfigBeanDefinitionParser 在其源码 parse() 中有这么一段代码。 public class AnnotationConfigBeanDefinitionParser implements BeanDefinitionParser { public BeanDefinition parse(Element element, ParserContext parserContext) { Object source = parserContext.extractSource(element); // TODO 重点看下，逻辑相对简单，注册一些内置注解解析支持 Set\u003cBeanDefinitionHolder\u003e processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source); // 省略... return null; } } 进入 registerAnnotationConfigProcessors()： public abstract class AnnotationConfigUtils { public static Set\u003cBeanDefinitionHolder\u003e registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, @Nullable Object source) { // ApplicationContext是实现了BeanDefinitionRegistry的，这里将ApplicationContext进行强转。 DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry); // 省略... Set\u003cBeanDefinitionHolder\u003e beanDefs = new LinkedHashSet\u003c\u003e(8); // ConfigurationClassPostProcessor注册，支持注解@Configuration if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) { // 这里注入了一个BeanFactoryPostProcessor RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); } // AutowiredAnnotationBeanPostProcessor注册，支持@Autowired if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) { RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); } // 省略... return beanDefs; } } 可以看到，这里注册了 ConfigurationClassPostProcessor 和 AutowiredAnnotationBeanPostProcessor。 这些都是内置的 BeanDefinitionPostProcessor 实现类，对应注解都是常用的，有必要看一下。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:4:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"5 总结 spring对XML的解析，就是通过NameSpaceHandler中注册的BeanDefinitionParser进行处理的。通过SPI的方式，很容易对标签解析功能进行扩展。 技巧\r\r其他的解析类，方法都是一样的。 首先根据标签名称找到NamespaceUri，根据SPI加载方式，到对应模块META-INF/spring.handlers文件中查找对应的NamespaceHandler实现类； 然后在实现类中的init方法中，找到标签属性对应的BeanDefinitionParser实现类； 最后，进入实现类的parse方法，读源码即可。结合断点调试，很容易读懂。 \r\r 万事开头难，spring源码也一样。刚开始确实挺难理解的，理清了脉络后，再读起来就相对简单很多。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:5:0","tags":["spring源码"],"title":"02 Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"Spring源码的程序入口，和XML解析的源码流程。","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"spring源码系列文章，示例代码的中文注释，均是 copy 自 https://gitee.com/wlizhi/spring-framework 。 链接中源码是作者从 github 下载，并以自身理解对核心流程及主要节点做了详细的中文注释。 用 jack大佬 的话来概括，为什么要学习Spring源码？ 提高自己的写代码能力 从全局考虑如何使代码变得灵活可扩展 Spring重新定义了Java Spring源码是有一定难度的 如果想成为真正的高手，Spring源码必须攻克，不是危言耸听的 Spring源码读懂，其他很多基于Spring的框架源码很容易理解。相反，以Spring为基础的框架、组件，不懂Spring压根没法读其源码。 学习源码的方式：主抓脉络，后看细节。（熟练使用的前提下再看源码） 特别感谢：Spring源码中的调用链路、纵深都是比较长的，我个人读了很久。许多源码难点的理解得益于 jack大佬 的讲解，感谢大佬的授业解惑。 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:0:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"1 Spring的历史 2002年10月,Rod Johnson发布《Expert One-on-One J2EE设计和开发》一书 2004年3月，Spring1.0发布 2006年10 月，Spring2.0发布 2009年12月，Spring3.0发布 2013年12月，发布Spring4.0 2017年9月，Spring5.0发布 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:1:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"2 读源码前的准备 JDK1.8版本 spring 5.1.3.RELEASE版本 补一下Lambda表达式的知识 安装配置gradle ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:2:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"3 Spring源码下载 git clone --branch v5.1.3.RELEASE https://gitee.com/wanglizhi00/spring-framework （此链接的Spring源码，核心流程、要注意的点我都做了中文注释，非常详细。如果你的网络足够好，也可以到 github 下载 原版spring源码 ） gradle下载，gradle要JDK8的版本 到下载的spring源码路径执行gradle命令，gradlew :spring-oxm:compileTestJava 用idea打开spring源码工程。（在idea中安装插件kotlin，重启idea，跟IDEA版本有关较新版本不用安装） 把编译好的源码导入到工程中 spring工程如何搭建这里不做介绍，如何将down下来的源码导入到自己的spring工程依赖库， 我的Gitee-Spring源码注释 中有详细的介绍 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:3:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"4 入口方法 容器：AbstractApplicationContext 抽象父类，核心方法 refresh()。 ClassPathXmlApplicationContext XML方式启动。 AnnotationConfigWebApplicationContext 注解方式启动，对局部代码进行测试时比较好用。 AnnotationConfigServletWebServerApplicationContext SpringBoot启动默认使用的上下文类。 我们知道，spring容器的启动是通过构造ApplicationContext的一个实例开始的。以ClassPathXmlApplicationContext为例。 ClassPathXmlApplicationContext UML图ClassPathXmlApplicationContext UML图 \"\rClassPathXmlApplicationContext UML图\r ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:4:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"5 Xml解析流程概览 首先进入spring容器启动的核心方法：refresh() ，创建BeanFactory对象 obtainFreshBeanFactory() 创建XmlBeanDefinitionReader对象 通过Reader对象加载配置文件 根据加载的配置文件把配置文件封装成document对象 创建BeanDefinitionDocumentReader对象，DocumentReader负责对document对象解析 parseDefaultElement(ele, delegate);负责常规标签解析 delegate.parseCustomElement(ele);负责自定义标签解析 最终解析的标签封装成BeanDefinition并缓存到容器中 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:5:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"6 创建XmlBeanDefinitionReader对象 public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext { @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // Create a new XmlBeanDefinitionReader for the given BeanFactory. // 创建BeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); // TODO 关键点：加载BeanDefinition loadBeanDefinitions(beanDefinitionReader); } } 在loadBeanDefinitions方法的第一行，创建了XmlBeanDefinitionReader对象。这个类的主要作用是读取BeanDefinition，并将XML文档的读取委托给BeanDefinitionDocumentReader。 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:6:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"7 创建BeanDefinitionDocumentReader对象 来到loadBeanDefinitions(beanDefinitionReader);这里将要读取的xml路径传递进来，循环xml路径，依次进行解析。 注：看注释中的关键点 public abstract class AbstractBeanDefinitionReader implements BeanDefinitionReader, EnvironmentCapable { // 首先进入这个方法 @Override public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException { Assert.notNull(locations, \"Location array must not be null\"); int count = 0; // 一次解析配置文件，加载配置文件中定义的Bean。 for (String location : locations) { count += loadBeanDefinitions(location); } return count; } } 路径最终会被封装为IinputSource对象，使用委托模式，交给BeanDefinitionDocumentReader处理 public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader { // 第一步：入口 protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 解析xml配置文件，获取到Document对象 Document doc = doLoadDocument(inputSource, resource); // 解析、注册BeanDefinition int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) { logger.debug(\"Loaded \" + count + \" bean definitions from \" + resource); } return count; //此处分别捕获了很多种异常，省略了。 } catch (Exception ex) { throw ex; } } // 第二步 创建BeanDefinitionDocumentReader，委托给BeanDefinitionDocumentReader进行解析工作。 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // 委托模式，将Document的解析及BeanDefinition的注册交给BeanDefinitionDocumentReader // 这里使用的DefaultBeanDefinitionDocumentReader进行解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // TODO 关键点：解析xml、注册BeanDefinition documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore; } } ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:7:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"8 标签解析入口 在解析标签之前、和之后，分别有一个钩子方法。这两个钩子方法分别是 解析xml并注册BeanDefinition 之前和之后的扩展方法，ClassPathXmlApplicationContext中，这两个方法体都是空的。 public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader { // 第一步 protected void doRegisterBeanDefinitions(Element root) { // Any nested \u003cbeans\u003e elements will cause recursion in this method. In // order to propagate and preserve \u003cbeans\u003e default-* attributes correctly, // keep track of the current (parent) delegate, which may be null. Create // the new (child) delegate with a reference to the parent for fallback purposes, // then ultimately reset this.delegate back to its original (parent) reference. // this behavior emulates a stack of delegates without actually necessitating one. BeanDefinitionParserDelegate parent = this.delegate; // BeanDefinitionParserDelegate中封装了预定义的很多标签属性 this.delegate = createDelegate(getReaderContext(), root, parent); // 根标签解析 NameSpace：http://www.springframework.org/schema/beans if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); // We cannot use Profiles.of(...) since profile expressions are not supported // in XML config. See SPR-12458 for details. if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isDebugEnabled()) { logger.debug(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); } return; } } } // 钩子方法，解析xml注册BeanDefinition之前调用，可以不看 preProcessXml(root); // TODO 解析xml，注册BeanDefinition parseBeanDefinitions(root, this.delegate); // 钩子方法，解析xml注册BeanDefinition之后调用，可以不看 postProcessXml(root); this.delegate = parent; } // 第二步 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { // Spring根标签，NameSpace：http://www.springframework.org/schema/beans // 这里循环document中的元素，进行解析默认标签及自定义标签 String tagName = root.getTagName(); if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i \u003c nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { logger.debug(\"delegate.isDefaultNamespace(root):true,解析默认标签 \" + tagName); // TODO 关键点：解析默认标签 parseDefaultElement(ele, delegate); } else { logger.debug(\"delegate.isDefaultNamespace(root):true,解析自定义标签 \" + tagName); // TODO 关键点：解析自定义标签 delegate.parseCustomElement(ele); } } } } else { logger.debug(\"delegate.isDefaultNamespace(root):false,解析自定义标签 \" + tagName); // TODO 关键点：解析自定义标签 delegate.parseCustomElement(root); } } } ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:8:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"9 解析默认标签 根据xml节点的名称，对比代码中定义的标签名称。跳转到对应的解析方法 以bean标签为例，最终走到BeanDefinitionParserDelegate.parseBeanDefinitionElement()方法 public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader { // 第一步 进入标签解析方法 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { // import标签解析 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } // alias标签解析 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } // TODO 重点看：bean标签解析 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); } // beans标签解析 else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // recurse doRegisterBeanDefinitions(ele); } } // 第二步 进入bean标签解析方法 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // TODO 重点：获取到BeanDefinitionHolder，内部封装了BeanDefinition BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // 如果必要，装饰BeanDefinition，这里用到了装饰模式 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } } 解析和封装BeanDefinition，这里解析了bean标签中的所有属性，将这些属性值封装成BeanDefinition对象。最终会被注册到BeanDefinitionRegistry中。 BeanDefinitionRegistry作为spring容器中BeanFactory的全局成员变量。也就是说，最终得到的BeanDefinition贯穿整个spring容器的生命周期，它是对spring容器中所有将要实例化的bean信息的描述。 public class BeanDefinitionParserDelegate { @Nullable public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); // bean标签中的class属性 String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } // bean标签中的parent属性 String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { // TODO 重点：创建BeanDefinition，设置parent、beanClass、beanClassName属性。 // bean标签的bean均定义为：GenericBeanDefinition AbstractBeanDefinition bd = createBeanDefinition(className, parent); // TODO 重点：解析element并设置BeanDefinition中的属性值 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 解析meta标签、lookupOverride子标签、replaceMethod子标签 parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析构造函数参数、property参数、qualifier参数 parseConstructorArgElements(ele, bd); parsePropertyElements(ele, bd); parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(\"Bean class [\" + className + \"] not found\", ele, ex); } catch (NoClassDefFoundError err) { error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err); } catch (Throwable ex) { error(\"Unexpected failure during bean definition parsing\", ele, ex); } finally { this.parseState.pop(); } return null; } } ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:9:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"10 解析自定义标签 SPI方式获取加载所有的namespaceUri（SPI这里不进行讨论），通过当前标签定义的namespaceUri，获取到初始化后（init()）的处理类。然后调用处理类的parse方法，在此方法中，完成了标签属性的解析和BeanDefinition注册 在resolve方法中，调用了NamespaceHandler的init方法，init方法中注册了标签属性的处理类。 这些处理类都是BeanDefinitionParser的实现，在BeanDefinitionParser中，仅有一个parse方法，用来解析特定的标签属性。 public class BeanDefinitionParserDelegate { @Nullable public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) { // SPI方式获取namespaceUri String namespaceUri = getNamespaceURI(ele); if (namespaceUri == null) { return null; } // 获取NamespaceHandler，这里面调用了NamespaceHandler的init方法 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) { error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele); return null; } return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); } } NamespaceHandler，是根据对应模块中的META-INF/spring.handlers中定义的映射关系进行获取的（SPI方式获取）。映射关系NamespaceUri=NamespaceHandler 以下是spring-context中定义的处理映射（spring-context/META-INF/spring.handlers） http\\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler http\\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler http\\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler http\\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler http\\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler resolve方法获取了处理类对象，每个处理类实例化之后都会放入缓存handlerMappings，下次获取直接从缓存中获取。handlerMappings的键时NamespaceUri，值初始是对应处理类的ClassName，实例化之后会替换为该类的实例对象。 public class DefaultNamespaceHandlerResolver implements NamespaceHandlerResolver { @Override @Nullable public NamespaceHandler resolve(String namespaceUri) { // 从缓存中获取，如果存在，直接返回，如果不存在则创建 Map\u003cString, Object\u003e handlerMappings = getHandlerMappings(); Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) { return null; } else if (handlerOrClassName instanceof NamespaceHandler) { return (NamespaceHandler) handlerOrClassName; } else { String className = (String) handlerOrClassName; try { // 加载Class Class\u003c?\u003e handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException(\"Class [\" + className + \"] for namespace [\" + namespaceUri + \"] does not implement the [\" + NamespaceHandler.class.getName() + \"] interface\"); } // TODO 重点：实例化NamespaceHandler，调用init方法，放入缓存。这里是一个扩展点，所有的自定义标签都要提供对应的NamespaceHandler // spring.handler文件中定义了很多内置的NamespaceHandler，通过SPI的方式加载、实例化 NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); namespaceHandler.init(); handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; } catch (ClassNotFoundException ex) { throw new FatalBeanException(\"Could not find NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"]\", ex); } catch (LinkageError err) { throw new FatalBeanException(\"Unresolvable class definition for NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"]\", err); } } } } 每个自定义标签都有自己的NamespaceHandler实现。 NamespaceHandler实现类\"\rNamespaceHandler实现类\r 以context标签为例，注册不同标签属性对应的处理类。 public class ContextNamespaceHandler extends NamespaceHandlerSupport { @Override public void init() { // 注册各种标签属性的解析类 registerBeanDefinitionParser(\"property-placeholder\", new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(\"property-override\", new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(\"annotation-config\", new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(\"load-time-weaver\", new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionPa","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:10:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["spring"],"content":"11 总结 Spring解析XML，绕了这么大一圈。其目的就是把XML中配置的各种标签按照标签本身定义的解析方式进行处理，将处理的结果封装成BeanDefinition对象，并注入到BeanFactory的成员变量BeanDefinitionRegistry中。 这是Spring容器以XML方式初始化的第一步。其实无论是XML解析方式，还是注解方式，基本思想都是一样的。Spring容器在创建任何实例前，都会先搜集这个将要创建实例的一些必要信息，然后对这些信息根据一些扩展接口中提供的方法（模板设计模式），进行处理。 这些处理有一些是Spring内置的，可能也有使用者自定义的。具体的处理方式，在后面的章节体现。 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-main-xml-parse/:11:0","tags":["spring源码"],"title":"01 Spring程序入口和XML解析","uri":"/posts/spring/01-spring-main-xml-parse/"},{"categories":["生活"],"content":"回忆 六年前的一个LOL视频，当初也是实锤的电竞粉额。2015年夏天也是拿这个英雄打了一个月排位，网一区一路从白银打到钻二，排行榜3000多名（据说这区当时活跃用户大概50万），之后便不怎么玩儿了。 \r","date":"2020-11-21","objectID":"/posts/life/memory-lol/:0:1","tags":["LOL"],"title":"Memory LOL","uri":"/posts/life/memory-lol/"},{"categories":["生活"],"content":"emm…那年夏天 ","date":"2020-11-21","objectID":"/posts/life/memory-lol/:0:2","tags":["LOL"],"title":"Memory LOL","uri":"/posts/life/memory-lol/"},{"categories":["折腾"],"content":"关于站内搜索，试用两天lunr后，还是决定换成algolia，algolia本身性能更高、也更加节省流量。","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"原由 博客搭建好之后，还算满意。试用过程中，偶然发现页面跳转时每次都会请求几个lunr相关支持的js文件，搜索时，又会下载index.js文件。 对lunr支持的文件，还是比较大的；index.js就是文档索引内容了，这个文件和网站内容数量成正比。目前文章只有十多篇，index.js文件就有70kb。 随着文章的发布，index.js会不断增大，且每次点击搜索框进行搜索，都会下载此文件。内容不多的情况下，速度相较于algolia更快。（网络原因，即使选择官方最近的数据中心，还是略卡） 一番思索后，决定将lunr换成algolia（虽然因网络原因，目前lunr更快），原因：并非每次加载页面都需要搜索支持，而使用lunr总是会下载搜索相关支持文件，algolia就没有这个问题。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:1","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"lunr和algolia的区别 lunr每次搜索前、都会请求对lunr支持的js文件、及将要分析的索引文档（index.json）。也就是说，搜索功能本身及将要搜索的全部网站数据索引，都是一次性发送到客户端，在客户端浏览器上运行的。这种方式太过简单粗暴。 algolia则是将索引分析任务交给第三方服务器（algolia官方的），需要分析的索引文档，提前上传到algolia服务器，搜索时，客户端仅发送搜索的关键字、身份校验的一些信息。algolia分析本地索引文件，处理完成后将结果返回给客户端。 相对lunr，algolia少了向客户端发送搜索引擎功能文件（因为搜索在服务器做了，搜索功能本身可以做的更强大）、及索引文件。仅仅是搜索关键字、和处理结果的传输，就省了很大一笔网络开销，这也是它的高效之处。 algolia比lunr多了一次网络请求。一般公司里项目做搜索，搜索引擎服务器和业务服务器是通过内网链接，网络延迟很低很低。使用algolia的唯一痛点就在这了，即使选择algolia在国内的数据中心（香港），也还是有点延迟的。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:2","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"使用algolia algolia使用还是很简单的，Algolia官网 注册账号 -\u003e 创建应用 -\u003e 创建indices -\u003e 上传索引文件。 hugo项目中，配置一些必要信息（前提主题支持algolia搜索）。分别是Algolia中创建的index名称、appId、searchKey。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:3","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"自动更新index 每次发布新内容，如果手动上传索引文件到algolia，是相当麻烦的。 Algolia Atomic 是一个不错的选择。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:4","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"前言 搭建过程有些波折，好在总算完成了。目前博客采用hugo的主题。不得不说，hugo使用起来相较于jekyll简单了许多，除了主题生态没有jekyll的丰富，别的没毛病。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:1","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"起因 上周听Jack大佬的课，翻了某位同学博客 （叶良辰学习笔记），陡然眼前一亮，原来笔记还可以这么玩儿。 其实几年前我就有意搭建个人博客，一直没落实的原因：确实有些忙，偶尔闲下来时又去学习新的知识，自己写博客系统的话，太耗时间、精力（作为一个java程序员，前端能力有限，你懂得。），会的一堆后端技术，这里毫无用武之地。时至今日这个计划已经迟滞了三年多。 很多云笔记也有分享功能，甚至一键发布博客功能。比如有道云笔记、印象笔记、蚂蚁笔记等，都有用过。看了这位同学的笔记（博客）后，回想自己用云笔记的方式，决定还是研究一下博客系统。一个存储私密文档，一个发布公开文档。 Jack大佬博客传送门 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:2","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"百度 - 货比三家 直接写静态页面得不偿失。页面+后端方式实现博客、管理等功能，太重，且前端能力有限。无论如何，最终内容还是要静态页面，除非你不想被搜索引擎扒到。 首先百度搜索静态页面生成器，很多流行的，不晓得先入手研究哪个，对比了许多帖子，决定先看看jekyll。然后在 jekyll主题网站 选择了几个主题。 一般主题网站中的主题都有demo，先看demo效果。 到github仓库，fork到自己的仓库。 根据README.md文档的介绍，将代码拉取到本地，用IDE打开。（我使用的IDEA，毕竟做后端的…） 根据使用文档（很多主题其实只有一个文件介绍，不是特别详细，需要自己摸索）修改配置。 尝试了几个主题后，大多功能都正常，个别地方有问题，本地很难调试。（依赖ruby、nodejs等环境，作为java程序员，对这玩意儿认知低的可怜） 尝试了几个主题后，感觉还凑合，将修改好的主题推送到github后，通过gitPages托管。能访问，龟速。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:3","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"选择 - Hugo 之后翻看网上的博客时，看到有人说使用的hugo，于是点进去搜了一通。选择了几个主题，挨个试。这里说下我使用的感受： jekyll优点：主题更丰富，选择性更多。 jekyll缺点：使用实在太复杂，构建速度着实慢了些。 hugo优点：使用真的简单，比jekyll简单太多了。构建速度真的快，比jekyll快很多很多倍。（目前没太多内容，构建后大概100多个静态 文件，构建需要500ms左右） hugo缺点：主题没jekyll选择性那么多，也还可以。官网上有些主题相对简陋。（注：不是简约，是简陋） 使用jekyll时，看到一个比较喜欢的主题ThemePersephone，只是搞了半天，gitpages托管的代码是可以访问了，本地环境却始终弄不好（ruby的问题，下载了最新版本不行。准备换个版本的安装包，死活下载不了，官网被墙的厉害），只好放弃。之后在HugoThemes下载主题，试用。只需要下载一个二进制文件，不需要其他任何依赖。没有对比就没有伤害，最终选择Hugo ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:4","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"搭建 两款主题 hugo-theme-hello-friend-ng 和 loveit ，最终选择loveit这款主题，原因是，文档超级详细，功能足够丰富。支持搜索引擎（两款）、评论系统、shortcode、emoji等。该有的功能基本都支持，唯一不满的是md text块的背景色、字体颜色有点丑。有空再研究给换个色。 搜索引擎支持两种： lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 暂时选择lunr，原因简单，现在的访问量来看，缺点可以忽略（好吧…两天后-决定将搜索更换为Alogial）。 评论系统略有点麻烦，支持6种评论系统（disqus、gitalk、valine、facebook、telegram comments、commento、utterances），挨个打开，打开valine官网速度较快，最终选择这个，不为别的，官网打开速度的印象分。 评论本身配置相对简单，根据提示来就行。邮件提醒功能略麻烦点，valine从v1.4.0版本后，不再支持邮件提醒功能。只能使用的第三方邮件提醒。关于这个，github上很多开源项目。我选择的 Valine-Admin ，部署到LeanCloud创建的应用中。部署后需要配置一些环境变量，主要是邮件发送的服务器、账号、授权码、自己网站url等。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:5","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"迁移 - 阿里云 图片资源使用阿里云对象存储OSS，静态页面迁移到阿里云服务器。 GitPages托管方式，访问速度有点慢，还算能接受吧。服务器有、域名有（旧的域名不太喜欢，新域名备案完成还得几天），最终决定迁移到阿里云。部署：服务器安装docker -\u003e docker安装nginx -\u003e 安装git -\u003e 将hugo生成的html文件拉取到nginx路由的目录下，部署完成。 迁移到阿里云后的感受：不卡了，emm…丝滑。嗯，也收费了。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:6","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"自动部署 使用Github的WebHooks，服务器写一个脚本即可。 好吧，用了一周左右，实在无法忍受这种龟速。整体迁移到了 gitee，gitee 中 自动部署脚本传送门 。 流程大概是这个样子：当push代码到github时，触发回调接口。在服务器上部署一个web项目（我使用的springboot），暴露一个接口供webhooks调用。接口内容是异步方式（一个单线程的线程池）执行shell脚本，完成自动部署。 更轻量的方式，手写代码，使用socket接收请求，执行脚本更加高效。http接口方式写起来比较快，后面如需功能拓展也更方便。 附一张自动部署日志的截图，速度还挺快，部署一次大概400ms左右。 自动部署日志自动部署日志 \"\r自动部署日志\r ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:7","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"域名备案 wlz922.top是我一直使用的域名，域名备案相对麻烦，思虑再三还是决定再注册一个。 新域名wlizhi.cc审核估计还得几天。 备案流程有点麻烦，周期是比较长的（到域名服务商注册 -\u003e 阿里云初审 -\u003e 通管局审核）。 首先注册域名，注册后是不能直接备案的，要等1-3天。然后申请备案，填一些必须的资料。阿里云关于备案相关资料太多，没看，直接按照流程提示填写资料。之后初审驳回一次（验证资料不规范），按要求重新上传资料，初审通过，等待管局审核。 有一点需要说明，域名备案时，解析的网站首页必须和资料填写的内容一致，页脚必须有备案号链接到 工信部域名备案管理 网站（我上个域名备案时让填的不是这个网址，搞不懂）。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:8","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"最后 看jekyll、hugo文档、选主题、读主题及主题支持各种插件文档、迁移至阿里云。历时四天，博客主题基本选定（主题选了两天多，换了五六个。强迫症，总想找个更好的）、搭建完成。没事还是要研究一下hugo，折腾已成本能。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:9","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["系统"],"content":"linux 基础概念、文件系统组成、常用命令、应用安装 - 卸载","date":"2020-11-18","objectID":"/posts/linux/linux-basics/","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"前言 对 Peter 大佬的离线笔记的转载，由于文档是离线的，没有链接。 此文可以作为桌案文档保留，一些不常用命令忘记时，可做查询使用。 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:1:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"1. 基础介绍 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"发行的linux版本 Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS linux各个版本\"\rlinux各个版本\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"系统目录结构 linux目录结构\"\rlinux目录结构\r 系统启动必须： 信息\r\r /boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。 /etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。 /lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中 \r\r 指令集合： 信息\r\r /bin：存放着最常用的程序和指令 /sbin：只有系统管理员能使用的程序和指令。 \r\r 外部文件管理： 信息\r\r /dev ：Device(设备)的缩写, 存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。 /media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。 /mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 \r\r 临时文件 信息\r\r /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。 /tmp：这个目录是用来存放一些临时文件的。 \r\r 账户： 信息\r\r /root：系统管理员的用户主目录。 /home：用户的主目录，以用户的账号命名的。 /usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序与指令。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 \r\r 运行过程中要用： 信息\r\r /var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。 /proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。 \r\r 扩展用的： 信息\r\r /opt：默认是空的，我们安装额外软件可以放在这个里面。 /srv：存放服务启动后需要提取的数据（不用服务器就是空） \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"linux基础命令 shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。 信息\r\r# shutdown -P now ### 关闭机器 # shutdown -H now ### 停止机器 # shutdown -r 09:35 ### 在 09:35am 重启机器\r\r 要取消即将进行的关机，只要输入命令： # shutdown -c halt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。 信息\r\r# halt ### 停止机器 # halt -p ### 关闭机器 # halt –reboot ### 重启机器\r\r poweroff 会发送一个 ACPI 信号来通知系统关机。 信息\r\r# poweroff ### 关闭机器 # poweroff –halt ### 停止机器 # poweroff –reboot ### 重启机器\r\r reboot 命令 reboot 通知系统重启。 信息\r\r# reboot ### 重启机器 # reboot –halt ### 停止机器 # reboot -p ### 关闭机器\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"2. linux用户/用户组 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"增加一个用户组 信息\r\rgroupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 例1： # groupadd group1 ##此命令向系统中增加了一个新组group1 例2： # groupadd -g 1003 group2 ##此命令向系统中增加了一个新组group2，同时指定新组的组标识号是1003 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"删除一个用户组 信息\r\rgroupdel 用户组 例：# groupdel group1 ##此命令从系统中删除组group1。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"修改用户组的属性 信息\r\rgroupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n 新用户组 将用户组的名字改为新名字 例1： # groupmod –g 10000 -n group3 group2 ##此命令将组group2的标识号改为10000，组名修改为group3。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"添加用户账号 信息\r\r参数说明： 选项: -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名: 指定新账号的登录名。 useradd 选项 用户名 例1： # useradd –d /usr/peter -m peter ##创建用户peter，其中-d和-m选项用来为登录名peter产生一个主目录/usr/peter。 例2： # useradd -s /bin/sh -g group1 –G group2,root peter2 ##新建用户peter2，登录Shell是 /bin/sh，属于group1，又属于group2和root。 这里可能新建组：#groupadd group1及groupadd group2 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:4","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"删除账号 信息\r\r userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 例如： # userdel -r peter2 ##删除用户peter2（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:5","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"修改账号 信息\r\rusermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： # usermod -s /bin/sh -d /home/p –g group2 peter ##将用户peter的登录Shell修改为sh，主目录改为/home/p，用户组改为group2。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:6","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"用户口令的管理 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 信息\r\rpasswd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。\r\r 如果默认用户名，则修改当前用户的口令。例如，假设当前用户是peter，则下面的命令修改该用户自己的口令： 信息\r\r$ passwd Old password:****** New password:******* Re-enter new password:*******\r\r 如果是超级用户，可以用下列形式指定任何用户的口令： 信息\r\r# passwd peter New password:******* Re-enter new password:*******\r\r 为用户指定空口令时，执行下列形式的命令：# passwd -d peter passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：# passwd -l peter ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:7","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"切换用户组 信息\r\r$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:8","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"与用户账号有关的系统文件 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等 /etc/passwd文件 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 信息\r\r例子： ＃ cat /etc/passwd root:x:0:0:Superuser:/: daemon:x:1:1:System daemons:/etc: bin:x:2:2:Owner of system commands:/bin: sys:x:3:3:Owner of system files:/usr/sys: adm:x:4:4:System accounting:/usr/adm: uucp:x:5:5:UUCP administrator:/usr/lib/uucp: auth:x:7:21:Authentication administrator:/tcb/files/auth: cron:x:9:16:Cron daemon:/usr/spool/cron: listen:x:37:4:Network daemon:/usr/net/nls: lp:x:71:18:Printer administrator:/usr/spool/lp: \r\r 每一行记录对应着一个用户（其中bin/sys/adm/uucp/lp/nobody是伪用户），每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell /etc/group文件 用户组的所有信息都存放在/etc/group文件中。 信息\r\rroot::0:root bin::2:root,bin sys::3:root,uucp adm::4:root,adm daemon::5:root,daemon lp::7:root,lp users::20:root,sam\r\r 此文件的格式类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:9","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"3. 文件与目录 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"文件基本属性 1. 文件的属性概貌 Lighthouse (image)\"\rLighthouse (image)\r 信息\r\r第一个字符：代表这个文件的类型，是目录、文件，还是一个链接等等 [ d ] 目录 [ - ] 文件 [ l ] 链接文档(link file) [ b ] 可供储存的接口设备(可随机存取装置) [ c ] 串行端口设备，例如键盘、鼠标(一次性读取装置) 接下来的字符：以三个一组分成三组，用 r、w、x 三个参数的组合表示，位置不会改变 [ r ] 代表可读(read) [ w ] 代表可写(write) [ x ] 代表可执行(execute) [ - ] 没有权限\r\r 2. 文件的属主与属组 每一个文件，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 chgrp：更改文件属组 信息\r\rchgrp [-R] 属组名 文件名 参数选项 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。\r\r chown：更改文件属主，也可以同时更改文件属组 语法： chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 进入 /root 目录（~）将install.log的拥有者改为bin这个账号： 例： chown root:root aa ##更改aa的属主与属组 chmod：更改文件9个属性 文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！ 变更权限的指令chmod的语法是这样的： 信息\r\r chmod [-R] xyz 文件或目录 选项与参数： xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下： chmod +x aa ##更改aa的属性,加x权限 chmod 777 aa ##更改aa的属性，三组权限都设置成7 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"文件与目录管理命令 使用 man [命令] 来查看各个命令的使用文档，如 ：man cp 信息\r\rls: 列出目录 —ll cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 —–scp网络复制 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"硬链接与软链接 硬连接 信息\r\r硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\r\r 软连接 信息\r\r另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 例： $touch a #创建一个测试文件a $ ln a b #创建a的一个硬连接文件b –echo 123 \u003e a ##a,b的内容同时变为123 $ ln -s a c #创建a的一个符号连接文件c $ ls -li # -i参数显示文件的inode节点信息 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"4. 安装程序rpm/yum ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:5:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"1. rpm方式 需要去下载相应的rpm格式的安装包xxxx.rpm 信息\r\rrpm [参数] rpm包 -i 安装 -U 更新（很少用） -e 卸载 -v 显示安装信息 -h 显示安装进度 例： rpm -ivh jdk-8u172-linux-x64.rpm 安装jdk8并显示安装进度和安装信息 rpm -qa|grep jdk查看jdk的安装包 rpm -e jdk1.8-1.8.0_221-fcs.x86_64 卸载jdk8 ，只适用于rpm包安装的软件\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:5:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"2. yum方式 yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。 基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 2.1 yum语法 信息\r\ryum [options] [command] [package …] options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为\"yes\"），-q（不显示安装的过程）等等。 command：要进行的操作。 package操作的对象。 例： yum search jdk 搜索jdk安装包 yum install -y java-1.8.0-openjdk.x86_64 安装openjdk，-y表示安装过程中的询问自动选y yum list installed ｜grep jdk 列出安装的jdk软件包 yum remove java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-headless.x86_64 卸载jdk\r\r 2.2 yum常用命令 示例\r\r1.列出所有可更新的软件清单命令：yum check-update 2.更新所有软件命令：yum update 3.仅安装指定的软件命令：yum install \u003cpackage_name\u003e 4.仅更新指定的软件命令：yum update \u003cpackage_name\u003e 5.列出所有可安裝的软件清单命令：yum list 6.删除软件包命令：yum remove \u003cpackage_name\u003e 7.查找软件包 命令：yum search 8.清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers\r\r 2.3 yum源 官方的yum源在国内访问效果不佳。需要改为国内比较好的阿里云或者网易的yum源 在/etc/yum..repos.d/下进行如下操作(请做好相应备份)： 示例\r\rwget http://mirrors.163.com/.help/CentOS7-Base-163.repo mv CentOS7-Base-163.repo CentOS-Base.repo 重建缓存： yum clean all yum makecache\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:5:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"3. 配置环境变量 在Linux系统下，安装应用程序后，在安装目录之外，可能仍然会出现 “command not found ”。 要解决所有地方都能使用应用程序，就涉及到环境变量path的设置问题 3.1 配置环境变量 系统环境变量文件在/etc下的profile文件，我们可以用vi profile命令来编辑该文件，将变量添加进去 一般需要将安装文件的bin目录加入path中，可在profile中加入下面一行代码，如： 示例\r\rvim /etc/profile # 末尾追加以下内容 export JAVA_HOME=/usr/java/default export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\r\r 3.2 环境变量生效 source /etc/profile ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:5:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"5. shell脚本 shell语言是一门linux系统下的工具语言，主要用于写一些linux系统下的操作命令，实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。或者直接理解为shell命令是可以执行多个linux命令的脚本。Shell 种类众多，有以下种类（一般使用的 Bash，就是 Bourne Again Shell，它是大多数Linux 系统默认的 Shell）： 示例\r\rBourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh）\r\r shell并不复杂，有编程基础的话，简单入门两三个小时就可以入门，主要是把一些重复操作的linux命令写成shell脚本来执行一下。以下列出shell常规的一些要素： ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"1. 解释器与执行shell 示例\r\r解释器 #!/bin/sh Bourne shell版本 #!/bin/bash Bourne Again Shell 版本 执行shell chomd +x ./test.sh #使脚本具有执行权限 ./test.sh #执行脚本 “./”表示当前目录下\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"2. 演示 #!/bin/bash ##声明bash脚本 ##demo ##注释 echo $PATH ##打印PATH环境变量 name=\"Peter\" ##定义变量name echo $name ##打印name值 echo \"I am ${name}'s friend\" ##字符串拼接 echo \"\" name2=\"I am ${name}'s good friend\" ##字符串拼接 echo $name2 echo \"\" names=(\"Peter\" \"james\" \"deer\") ##定义数组 echo ${names[@]} ##遍历数组 echo \"I am ${names[1]}'s friend\" ##第二个元素 echo \"I have ${#names[@]}friends\" ##数组长度 echo \"\" for var in ${names[@]}; ##循环数组 do if test $var = 'Peter' ##字符串相等 then echo \"I am Peter\" else echo \"I am ${var}'s friend\" fi done echo \"\" if [ $(ps -ef | grep -c \"ssh\") -gt 1 ]; ##查找是否有ssh服务 then echo \"ssh service open\"; fi echo \"\" echo \"sh arg: $0$1\" ##sh的传参 重定向： 1、test ‘aa’ -eq “bb” \u003e out ##命令输出到 out文件，报错信息并不会进入out 2、test ‘aa’ -eq “bb” \u003e out 2\u003e\u00261 ##将stderr合并到stdout，则报错信息进入了out ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6. 常用命令 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.1 最常用的是cd 命令 示例\r\rcd 进入用户主目录； cd ~ 进入用户主目录； cd - 返回进入此目录之前所在的目录； cd .. 返回上级目录（若当前目录为“/“，则执行完后还在“/\"；\"..“为上级目录的意思）； cd ../.. 返回上两级目录；\r\r ls，ll， wget， curl， history ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.2 新建文件夹和文件：mkdir touch 示例\r\rmkdir 创建文件夹 mkdir dirname 直接跟文件夹名，可在当前目录下创建文件夹 mkdir /opt/lamp/dirname 可跟路径 mkdir -p /opt/lam/dirname 假如lam不存在，需要用-p才可以创建该文件夹 touch 新建文件 touch dilename 可直接跟文件名在当前目录下创建新的文件 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.3 cat/less/more/tail等文件查看命令 详细\r\r-n或-number：有1开始对所有输出的行数编号； -b或–number-nonblank：和-n相似，只不过对于空白行不编号； -s或–squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行； -A：显示不可打印字符，行尾显示“$”； -e：等价于\"-vE\"选项； -t：等价于\"-vT\"选项； -e：文件内容显示完毕后，自动退出； -f：强制显示文件； -g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度； -l：搜索时忽略大小写的差异； -N：每一行行首显示行号； -s：将连续多个空行压缩成一行显示； -S：在单行显示较长的内容，而不换行显示； -x\u003c数字\u003e：将TAB字符显示为指定个数的空格字符。 -\u003c数字\u003e：指定每屏显示的行数； -d：显示“[press space to continue,‘q’ to quit.]”和“[Press ‘h’ for instructions]”； -c：不进行滚屏操作。每次刷新这个屏幕； -s：将多个空行压缩成一行显示； -u：禁止下划线； +\u003c数字\u003e：从指定数字的行开始显示。 按Space键：显示文本的下一屏内容。 按Enier键：只显示文本的下一行内容。 按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。 按H键：显示帮助屏，该屏上有相关的帮助信息。 按B键：显示上一屏内容。 按Q键：退出rnore命令。 –retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用； -c或——bytes=：输出文件尾部的N（N为整数）个字节内容； -f或；–follow：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效； -F：与选项“-follow=name”和“–retry\"连用时功能相同； -n或——line=：输出文件的尾部N（N位数字）行内容。 –pid=\u003c进程号\u003e：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令； -q或——quiet或——silent：当有多个文件参数时，不输出各个文件名； -s\u003c秒数\u003e或——sleep-interal=\u003c秒数\u003e：与“-f”选项连用，指定监视文件变化时间隔的秒数； -v或——verbose：当有多个文件参数时，总是输出各个文件名； 一般tail命令最常用的-n和-f，例： tail filename 读取filename最后10行内容 tail -f filename 实时动态读取filename最后10行内容 tail -20f filename 实时动态读取filename最后20行内容 \r\r cat和less及more指令相似，cat是一次性读取所有内容，文件内容较多时速度较慢。less与more的区别在于：less可以前后翻页查看，more只能向前翻页查看。 tail则用于实时获取log信息，从后向前读取内容 上述四种命令均可跟grep搭配使用cat/less/tail |grep mysql ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.4 查看文件大小的命令 du/df 详细\r\rdu -sh * 显示当前目录下所有文件的大小 du -sh filename 显示该文件大小 du -sh 显示当前目录所占空间大小 -s或 仅显示总计，只列出最后加总的值。 -h或 以K，M，G为单位，提高信息的可读性。 df 显示磁盘占用信息 直接df默认一k为单位 df -lh 显示本地系统的占用信息，以K，M，G为单位\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:4","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.5 大重点–文本编辑器 vi 详细\r\rvi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。 Linux中的vi编辑器叫vim，它是vi的增强版（vi Improved），与vi编辑器完全兼容，而且实现了很多增强功能。 vi编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用vi编辑器就必须熟练掌握着两种模式的切换。 默认情况下，打开vi编辑器后自动进入命令模式。从编辑模式切换到命令模式使用“esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。 vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下： Ctrl+u：向文件首翻半屏； 2 Ctrl+d：向文件尾翻半屏； 3 Ctrl+f：向文件尾翻一屏； 4 Ctrl+b：向文件首翻一屏； 5 Esc：从编辑模式切换到命令模式； 6 ZZ：命令模式下保存当前文件所做的修改后退出vi； 7 :行号：光标跳转到指定行的行首； 8 :$：光标跳转到最后一行的行首； 9 x或X：删除一个字符，x删除光标后的，而X删除光标前的； 10 D：删除从当前光标到光标所在行尾的全部字符； 11 dd：删除光标行正行内容； 12 ndd：删除当前行及其后n-1行； 13 nyy：将当前行及其下n行的内容保存到寄存器?中，其中？为一个字母，n为一个数字； 14 p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方； 15 P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方； 16 /字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示； 17 ？name：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示； 18 a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作； 19 a：在当前字符后添加文本； 20 A：在行末添加文本； 21 i：在当前字符前插入文本； 22 I：在行首插入文本； 23 o：在当前行后面插入一空行； 24 O：在当前行前面插入一空行； 25 :wq：在命令模式下，执行存盘退出操作； 26 :w：在命令模式下，执行存盘操作； 27 :w！：在命令模式下，执行强制存盘操作； 28 :q：在命令模式下，执行退出vi操作； 29 :q！：在命令模式下，执行强制退出vi操作； 30 :e文件名：在命令模式下，打开并编辑指定名称的文件； 31 :n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件； 32 :f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例； 33 :set nu：在命令模式下，用于在最左端显示行号； 34 :set nonu：在命令模式下，用于在最左端不显示行号； 35 :1,3y 复制第一行到第三行 36 :1,3d 删除第一行到第三行 37 :1,3s/str/str_new/g 替换第一行到第三行中的字符串 38 :1,3s/str/str_new 替换第一行到第三行中的字符串第一个字符 39 :1,3 g/str /d 删除第一行到第三行中含有这个字符串的行\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:5","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.6 重定向 \u003e 输出重定向 who \u003e bbb.txt 将aaa的内容写入bbb中，覆盖写入 cat bbb.txt » ccc.txt 讲aaa的内容追加写入bbb中，不覆盖原来内容 \u003e bbb.txt 将bbb清空 输入重定向 grep 05:37:43.730 \u003c web.2019-07-22.0.log 大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。 一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。 同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 重定向深入理解 详细\r\r一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：  标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。  标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。  标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command \u003e file 将 stdout 重定向到 file，command \u003c file 将stdin 重定向到 file。\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:6","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.7 查看服务 详细\r\rnetstat -nlpt|grep 80 查看该端口号是否被占用 free -m //查看LINUX内存剩余容量 ps可以查看具体的进程信息，一般与管道符连接其他命令使用，如：grep ps常用参数-ef/-aux，一般最常用还是-ef，例：ps -ef|grep mysql 查询mysql进程 top也可查看进程信息，而且是动态显示 whoami 查看当前登陆用户 who 查看多少用户在使用系统 date查看系统时间，可跟时间格式使用 cal查看日历，可跟年份，查看指定的年份 chkconfig –list #查看系统服务启动 chkconfig iptables on #开机启动该服务 chkconfig iptables off #开机不启动该服务 service iptables start #启动该服务 service iptables restart #重启启该服务 ps -ef|grep mysql|grep -v grep|awk ‘{print $2}‘ps -ef|grep mysql 是查询mysql服务的进程 |后的grep -v grep 是匹配不包含grep的行 awk是取查询结果的第几列，awk ‘{print $2}‘则是取第二列的值 grep 无参数则显示匹配的行 -c 显示匹配的行数 -v 显示不匹配的行\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:7","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.8 杀掉进程 kill命令 详细\r\rkill最常用的参数是-9，用法：kill -9 进程号 即可强制杀掉该进程 统计命令 wc 常用的参数是 -l 用法：wc -l ，例： ps -ef|grep mysql|wc -l 统计查询出的mysql进程的行数 查找命令 find/locate/whereis/which find -name 后跟文件名，可查看文件所在目录，可跟user，查看属于user的文件 find -name filename 查找filename所在目录 find -name name* 查找开头为name的文件所在目录 find -name *name 查找结尾为name的文件所在目录 find -name *name* 查找包含name字符串的文件所在目录 find -user faith 查看用户faith的文件 locate用法与find基本相似，只是locate搜索速度较快些，locate一般系统不会自带，需要安装，可用yum安装 whereis只能搜索程序名 which则是只查询path中的环境变量\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:8","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.9 压缩和解压命令 gzip/guzip zip/unzip tar 详细\r\rgzip和gunzip一般可用参数是-r，例: gzip test.txt　压缩文件 gzip -r test 压缩所有test下的子文件 gunzip test.gz 解压文件 zip和unzip可用参数较多，例： zip test 不跟参数直接使用 zip -r test 递归压缩test下所有文件 unzip test 不跟参数直接使用 unzip -n 解压时不覆盖已存在的文件 unzip -o 解压时覆盖已存在的文件 unzip -d 将文件解压到目录中去 tar使用的较为多些，用法也多，最常用的是zxcvf几个参数，例： -c 创建新文档，就是代表压缩的意思 -x 解压文档 -f 使用归档文件 -z 使用gzip解压 -v 详细输出模式 最为常用的使用方法： tar -zcvf test.tar test 将test压缩为test.tar并输出详细信息 tar -zxvf test.tar 将test.tar解压缩，并输出详细信息\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:9","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.10 定时任务 crontab 详细\r\rcrontab [-u user] 文件 crontab [-u user] {-r -e -l} 不加-u的话默认当前用户 －e：执行文字编辑器来设定时程表，内定的文字编辑器是vi。 －r：删除目前的时程表。 －l：列出目前的时程表。 crontab -e 就可以打开一个文件进行编辑 crontab文件的格式为“M H D m d cmd”，M为分钟1-59，H为小时1-24，D为天1-31，m为月1-12，d为周0-6（0为周日）。cmd代表要执行的程序，*代表每分钟都执行 * * * * * sh /opt/lampp/test.sh 表示每分钟执行一次test.sh这个脚本 */5 * * * * sh /opt/lampp/test.sh 表示每5分钟执行一次test.sh这个脚本 30 21 * * * /usr/local/apache/bin/apachectl restart 表示每晚的21:30重启apache\r\r","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:7:10","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["日志"],"content":"logback常见配置","date":"2020-11-16","objectID":"/posts/technology-other/logback-configurature/","tags":["logback"],"title":"logback配置","uri":"/posts/technology-other/logback-configurature/"},{"categories":["日志"],"content":" \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- 日志级别从低到高分为TRACE \u003c DEBUG \u003c INFO \u003c WARN \u003c ERROR \u003c FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\u003e \u003c!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --\u003e \u003c!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\u003e \u003c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\u003e \u003cconfiguration scan=\"true\" scanPeriod=\"10 seconds\"\u003e \u003ccontextName\u003elogback\u003c/contextName\u003e \u003c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --\u003e \u003cproperty name=\"log.path\" value=\"logs\"/\u003e \u003cproperty name=\"project.name\" value=\"project-name\"/\u003e \u003c!--0. 日志格式和颜色渲染 --\u003e \u003c!-- 彩色日志依赖的渲染类 --\u003e \u003cconversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\"/\u003e \u003cconversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\"/\u003e \u003cconversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\"/\u003e \u003c!-- 彩色日志格式 --\u003e \u003cproperty name=\"CONSOLE_LOG_PATTERN\" value=\"${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(%L:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\"/\u003e \u003c!--1. 输出到控制台--\u003e \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003c/filter\u003e \u003cencoder\u003e \u003cPattern\u003e${CONSOLE_LOG_PATTERN}\u003c/Pattern\u003e \u003c!-- 设置字符集 --\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!--2. 输出到文档--\u003e \u003c!-- 2.1 level为 DEBUG 日志，时间滚动输出 --\u003e \u003cappender name=\"DEBUG_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-debug.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c!-- 设置字符集 --\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 日志归档 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-debug-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录debug级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.2 level为 INFO 日志，时间滚动输出 --\u003e \u003cappender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-info.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 每天日志归档路径以及格式 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录info级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003einfo\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.3 level为 WARN 日志，时间滚动输出 --\u003e \u003cappender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-warn.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharse","date":"2020-11-16","objectID":"/posts/technology-other/logback-configurature/:0:0","tags":["logback"],"title":"logback配置","uri":"/posts/technology-other/logback-configurature/"},{"categories":null,"content":"关于我 程序员。 曾喜欢玩游戏 （🎮 LOL S5 网一钻二、16年开始基本不玩了、没时间）。 热爱技术，喜欢瞎倒腾。生命不息、折腾不止（例如这个博客）😄。 现居于上海。 邮箱：wlizhicc@163.com ","date":"2020-11-16","objectID":"/about/:0:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"技术栈 数据库：mysql、redis、mongoDB、zookeeper等。 框架：spring、mybatis、springboot、springcloud系列（eureka、hystrix、ribbon、feign、zuul、actuator）、dubbo等。 java：并发编程、JVM调优、netty。 其他：tomcat、nginx、openresty、rabbitmq、docker、docker-compose等。 ","date":"2020-11-16","objectID":"/about/:0:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"博客 最初使用 jekyll ，构建有点慢，配置略微复杂。 目前使用 hugo ，部署于 阿里云ECS ，对象存储 阿里云OSS 。 自动发布使用 Gitee-WebHooks + 自写脚本 。最初在 github，网络原因，最终迁移到 gitee。 ","date":"2020-11-16","objectID":"/about/:0:3","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"网址 https://wlizhi.cc https://wlz922.top https://wlizhi.github.io https://wlizhi.gitee.io （个人版，无自动发布，很少更新） ","date":"2020-11-16","objectID":"/about/:0:4","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"友情链接 Jack大佬 | 叶良辰 ","date":"2020-11-16","objectID":"/about/:0:5","tags":null,"title":"关于","uri":"/about/"}]