[{"categories":null,"content":"才疏学浅，一个平凡的编码者。 欢迎访问我的github ","date":"2020-11-16","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["前端"],"content":"初学 JavaScript 要掌握的知识有哪些呢？ ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:0:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"1.表达式和语句 表达式： 一个式子，它具有表达某些信息的能力。比如1+2表达式的值为 3。需要注意的地方，console.log表达式的值为函数本身，但是console.log(1)表达式的值为 undefined，只是在控制台中显示的内容为 1。 语句： 描述一段内容的句子。比如var a = 1 它们两者的区别在于： 表达式一般都有值，语句可能有也可能没有。 语句一般会改变环境，比如声明或者赋值。 但这些都不绝对，特殊情况特殊看待。 ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:1:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"2. 标识符的规则 在对变量名等标识符命名的时候并非随心所欲随便命名的，要遵守一定的约定规则。首先 JavaScript 是对大小写敏感的，a和A会被严格区分，所以有时候在函数命名上要小心避免上下文名称不同造成的意外错误。 标识符第一个字符命名规则： 不能是数字； 可以是 Unicode 字符或$、_和中文； 标识符第二个及以后的字符命名规则： 可以为任意字符； 注：标识符的命名要好认、好记通俗易懂。不要写很多个_或是使用.这种比较特殊的字符。标识符要写时好写，后面 review 时要好懂才行。 ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:2:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"3.条件判断语句 “if…else…\" 是常用条件判断语句 // 伪代码 if(表达式){ 语句1 ... }else { 语句2 ... } 在 if 的块中的语句如果只有一句，则可以省略外面的花括号，只写这条语句，但是不推荐这么做，这样会容易造成阅读时看错代码流程。在 if…else 代码块中还可以继续继续嵌套 if…else 代码块来处理复杂的条件判断逻辑。 // 伪代码 if(表达式){ if(表达式){ 语句1 ... }else{ 语句2 ... } 语句3 ... }else { 语句4 ... } 多个条件判断可以使用if...else if ... else语法 if(表达式){ 语句1 ... }else if(表达式){ 语句2 ... }else { 语句3 ... } 有时候条件判断并不多的时候没必要使用 if…else，可以使用 \u0026\u0026来简化条件判断的代码。 例如有这些需求：一个函数 a 的参数接收一个函数并在这个 a 函数体内调用传入的函数，为了确保调用时不会发生错误，我们通常可以这样写代码。 function a(fn){ fn \u0026\u0026 fn() } // fn \u0026\u0026 fn() 等同于 if(fn) fn() 另外一个短路运算符||则可以用来进行一些保底赋值操作。 a = a || 100 // 等同于 if(!a) a = 100 ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:3:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"4.循环 循环操作可以使用while或者for,while 是表达式内的值为真时则执行块内语句。for语法可以看做是 while 的一个语法糖，因为我们在使用 while 是需要在 while 外部确定循环初始值，表达式内要有循环退出条件，循环体内有执行语句。但是这些都可以简化一下，现在我们来看看使用 for 如何做循环： for (var i = 0; i \u003c 5; i++) { console.log(i) } 延伸：由于变量提升，在 for 的代码块内使用定时器函数 setTimeout()函数时，会由于 var 定义的 i 变量从而使通过定时器函数输出的值为 i 循环完后最后的值。如果需要避免这种情况的发生，在声明并定义 i 时要使用let关键字去声明变量，这样就可以将变量 i 的作用域限定在当前的 for 代码块内。 ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:4:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"5、break、continue 有时候我们并不想让循环完全执行，希望循环在执行带某个条件时可以跳出循环，此时可以使用到 break 和 continue 了。 break：跳出本层循环 continue：跳过本次循环 在有两层循环的时候，在内部的第二层循环体内使用 break 可以跳出这层循环，但是不影响外部循环的执行。 for (let i = 0; i \u003c 5; i++) { for (let j = 0; j \u003c 5; j++) { if (j \u003e 2) // 只跳出变量为 j 的这层循环 break } console.log(i) } ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:5:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"6.label 语句 用的很少，仅做了解。 { a:1 } 以上代码乍看还会以为是一个对象，但其实是一个 label，它是一个正常代码块内包含一些内容（上面的代码在 Chrome 中使用需要在a:1后面加上;，否则会被 Chrome 修改成一个对象）。有时候面试会问上面这个代码是什么，所以要了解一下。 label 语法： foo: { console.log(1); break foo; console.log('这行不会输出!') } console.log(2) 这种写法其实就是标记某个代码块，从而通过 continue、break 等影响代码执行流程。` ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:6:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["HTTP"],"content":"URL 概述 URL（Uniform Resource Locator） 指的是统一资源定位符。URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个独特的资源。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等。 ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:0:0","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"1.URL 一个 URL 一般包含这些内容： 协议：http/https/ftp/mailto 等。http:// 是协议,它表明了浏览器必须使用何种协议； 端口：用于确认访问时系统提供什么样的服务，比如 http 端口是 80，https 为 443。0-1023 是留给系统使用的，自己使用时不要随意占用这些端口，除了这些端口一般我们都可以随意使用，但是诸多软件有默认的端口占用，比如 mysql 会占用 3306 端口，所以使用端口时还要小心占用到别的软件的端口。想了解软件的端口使用情况，看TCP/UDP 常见端口； 域名：例如\"www.baidu.com\"。它表明正在请求哪个 Web 服务器，或者可以直接使用 ip 地址，但是这并不好记忆。另外，一个域名可以对应多个 ip 地址； 资源请求路径：例如/path/index.html； 请求参数：请求时携带的额外参数信息，这些参数是用 \u0026 符号分隔的键/值对列表。例如：\"?key1=value1\u0026key2=value2\"; 锚点信息：锚点表示资源中的一种“书签”，通过锚点，可以跳到其所在位置，比如文章开头的目录信息，点击后即可跳到当前页面的某个内容处，这就是利用了锚点原理。锚点在地址栏上是以'#‘后面的内容确定的，需要注意的是，锚点内容并被发送到服务器，它属于浏览器本地处理的内容。 ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:1:0","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"2.DNS DNS（Domain Name System）：域名系统。为什么要有域名系统？我们可以想象一下，如果在访问互联网资源时，都是通过记录 ip 来访问的话，这个记忆难度有多大，而且还难以书写。比如访问百度时在浏览器地址栏输入\"183.232.231.172\"，这太繁琐了。于是有了域名系统，在域名服务商那里我们可以购买一个域名，并将域名解析到服务器外网 ip 地址，这样就可以通过域名来访问自己的服务器了。而且域名是可以绑定多个 ip 地址的，这样可以实现在不同地域的人们访问域名地址时连接到最近的服务器。比如腾讯设立华东、西南、华北等服务器，这样在访问时电信服务商通过域名解析将最近的服务器资源返回，提升我们的上网体验。 使用控制台的’nslookup’命令可以知道域名对应的服务器 ip 地址。例：nslookup www.baidu.com ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:2:0","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"3.IP ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:3:0","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"IP 的作用是什么，ping 命令怎么用？ ip（Internet Protocol）：网络协议。ip 的作用相当于一个拥有详细地址的门牌号，通过这个门牌号可以找到具体的某户人家。而在网络上需要访问某个站点的某个服务器资源就需要通过 ip 去唯一标识。我们在访问某个地址时可以通过控制台的ping命令去查看是否可以和这个 ip 地址连接。如果可以则能获取到服务器返回的信息。 ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:3:1","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"4.域名 ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:4:0","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"域名是什么，分别哪几类域名？ 域名是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识。由于 IP 地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（DNS，Domain Name System）来将域名和 IP 地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 地址数串。 域名由一或多个部分组成，这些部分通常连接在一起，并由点分隔。最右边的一个标签是顶级域名。例如 zh.example.com,顶级域名为.com，一个域名的层次结构，从右侧到左侧隔一个点依次下降一层。 域名一般分为顶级域名、子域名（二级域名）、三级域名。比如.com是顶级域名，example.com是二级域名，www.example.com是三级域名。这里二级和三级域名是父子关系，但并不是说它们就一定是同一家公司的关系。example.com和www.example.com可以是同一家公司，也可以是不同公司的域名。 了解协议、端口、DNS、IP、域名的相关内容，就可以初略知道浏览器地址栏上的内容到底是怎么回事了。 ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:4:1","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["前端"],"content":"1、浏览器渲染原理 浏览器到底是怎么将一个 html 文件渲染成生动的页面的？话不多说，直接看图 以图中的过程，浏览器的渲染过程大致就是： 通过 HTML 解析将 HTML 文件解析为 DOM 树; 通过 CSS 解析将 CSS 文件解析出样式规则（CSSOM 树）； 通过合并 DOM 树和 CSSOM 树将生成渲染树； 依赖渲染树开始布局（文档流、盒模型、确定位置和尺寸计算）； 知道了哪些节点可见、它们的计算样式以及几何信息，将渲染树中的每个节点转换成屏幕上的实际像素即开始绘制。把边框、文字颜色、阴影等绘制出来。 最后将合成好的页面展示出来。 延伸： 层叠样式的由来 还是先看图： 为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式）这种行为被称作为“样式继承”，那么为了不想要继承过来的样式，那么就需要自己单独写样式来覆盖原来的样式，即层叠。而不同的浏览器提供了不同的默认样式（“User Agent 样式”），这让我们一套代码却产生了五花八门的样式，这不符合设计需求。所以又通常要编写一个全局样式（reset.css / normalize.css）来清除默认样式，让代码在不同浏览器上产生一致的效果。 “display：none\"的元素是否会被渲染？ 答案是否。 同为显示和隐藏的一个属性是\"visibility”,visibility: hidden 与 display: none 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (display: none) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。 回流和重绘 回流(reflow)： 回流或称为 layout 重排。当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染。reflow 会从这个 html 的根节点开始往下递归，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击等只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 重绘(repaint)： 改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。 每次 Reflow，Repaint 后浏览器还需要合并渲染层并输出到屏幕上。所有的这些都会是动画卡顿的原因。 Reflow 的成本比 Repaint 的成本高得多的多。一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。可以在 csstrigger 上查找某个 css 属性会触发什么事件。 reflow 与 repaint 的时机： display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。 有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。 有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。 下面看谷歌开发者网站上的一张图 如果更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。 这个最后的版本开销最小，最适合于应用生命周期中的高压力点，例如动画或滚动。 继续深入将涉及到浏览器渲染优化，这里不再做展开。想知道哪些 CSS 属性会触发上面 3 中中的哪一个，可以查看这个网站CSS 触发器。 使用不同的方式改变元素状态的最终显示过程是什么样的呢？ 使用 js 调整元素位置 =\u003e 触发上图中的 Layout+Paing+Composite 使用 CSS 调整元素背景色 =\u003e 触发上图 Paint 和 Composite 使用 transform 调整元素位置 =\u003e 触发上图 Composite 是否发现使用 transform 调整元素竟然只触发了 Composite，比 js 少了两个步骤。很明显，使用 transform 可以提高页面渲染性能，而且用它还可以制作动画，下面来看看动画该怎么做吧。 ","date":"2020-05-02","objectID":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/:1:0","tags":["css","入门"],"title":"初识渲染原理和CSS动画","uri":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/"},{"categories":["前端"],"content":"2、CSS 动画的两种做法（transition 和 animation） 说动画前先深入了解一下\"transform\"属性。一般常用来给元素改变位置（translate），旋转（rotate），缩放（scale）。如果还需要对元素设置 3d 样式的话，就要给被设置元素的父级元素或者直接给 body 设置 perspective 属性。 要给元素进行变换前，还要清楚一个知识点-坐标系。我们浏览器以及盒模型的坐标原点都为左上角 当元素发生旋转时这个坐标轴的朝向也将发生改变。注意这一点，有时候就是没考虑好坐标轴的问题造成了布局错乱。 了解了坐标系，使用\"transform:translate\"的时候就更得心应手了。 transition： 使用 transform 是将元素从上一个状态转变为 transform 后的状态，直接设置这个属性后我们在浏览器中看到的就是 transform 后的元素了，为了让元素在发生变化时有一个过渡的效果，此时就可以用上\"transition\"啦，配合上\":hover\"等伪类选择器就可以实现简单的一次性动画效果啦。了解更多关于 transition 的内容可以看MDN transition animation： transition 只能制作一次性的动画，想要制作类似这样效果的动画怎么办呢？ 使用animation配合上\"@keyframes name{}“就可以实现了。属性使用没什么技巧，就是多练。详情看MDN @keyframes 。知道了 keyframes 怎么写了，那 animation 又该写到哪里呢？和 transition 一样，将这个属性写到要被实现动画元素的本身上！ 说不如做，动手做一个跳动的心吧，源码跳动的心 ","date":"2020-05-02","objectID":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/:2:0","tags":["css","入门"],"title":"初识渲染原理和CSS动画","uri":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/"},{"categories":["前端"],"content":"transform 总结： inline 元素不支持 transform，需要先转变为 block； translate(-50%,-50%)可做绝对定位元素的居中； scale 会造成模糊或边界变粗，酌情使用； 属性组合用：transform:scale(1.5) translate(-100%,-100%) 善用搜索引擎，不明白就看 MDN； 上述内容参考 MDN 以及谷歌 web 相关文档。 googleDevelopers-渲染性能 https://developers.google.com/web/fundamentals/performance/rendering googleDevelopers-关键渲染路径 https://developers.google.com/web/fundamentals/performance/critical-rendering-path ","date":"2020-05-02","objectID":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/:2:1","tags":["css","入门"],"title":"初识渲染原理和CSS动画","uri":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/"},{"categories":["前端"],"content":"float布局 ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:1:0","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"常见问题 原理：在父盒子浮动元素的最后加上一个盒子，并给这个盒子设置属性\"clear:both\"，这样就可以实现最基础的清除浮动了。 但是这样有个缺点，就是总要去手动增加一个html元素，然后为这个元素设置css样式，太麻烦。什么方式可以避免呢？那就是使用css伪元素。对css伪元素不太了解的话，可以看这里。 使用伪元素的方式清除浮动，则只需要为浮动盒子的父盒子添加一个类样式。类样式代码如下： /* 不兼容ie低版本 */ .clearfix { content:\"\"; display:block; clear:both; } /* 兼容ie低版本 */ /* after伪元素清除法 */ .clearfix:after { content: \"\"; display: block; height: 0; clear: both; visibility: hidden; } .clearfix: { *zoom: 1; /*为i6/i7老式浏览器准备*/ } /* 双伪元素清除法 */ .clearfix:before, .clearfix:after { content: \"\"; display: table; } .clearfix:after { clear: both; } .clearfix: { *zoom: 1; /*为i6/i7老式浏览器准备*/ } 2. 图片logo与底部边框有间隙 给img标签添设置属性\"vertical-align: middle;“值可以是这个属性的其他值。 3. 边框影响了布局 将border属性改为使用outline属性。同样都可以显示边框，但outline不影响布局。 4. 块元素居中显示 在pc上布局时，有时候要对一个固定宽度的块元素设置居中显示，可以使用\"margin:0 auto;“的方式，但是这并不好，因为假如这个要居中显示的元素就需要一个上外边距，那么使用\"margin:0 auto;“会破坏布局。比较好的方式是为元素设置以下两种属性： .centerbox { margin-left:auto; margin-right:auto; } 注：在css中，非特殊情况，布局时的属性设置最好是只影响到被设置的元素本身，不要让代码影响到其他的布局结果。即改写的代码不要少，但不该写的一定不要多。 5.平均布局时会用到的小技巧 如图，遇到需要对黑盒子内橙色盒子平均布局时，因为我们需要设置\"margin-right:xxpx;“会遇到最后一个盒子被挤下去的情况。这是由于每个盒子都\"margin-right\"使得最后一个橙色盒子装不下了。此时只需在这些需要被平均布局的盒子外再嵌套一个看不见的蓝色盒子，并给它设置一个最后一个橙色盒子所需的\"margin-right\"大小值就可以实现正常布局了，即图中蓝色盒子超过部分大小。这种布局方式称为负margin。 ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:1:1","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"flex布局 ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:2:0","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"常用属性 属性 设置位置 描述 display:flex 父元素 将布局设置为flex布局 flex-direction:row(默认)/column 父元素 设置主轴方向 flex-wrap:wrap/nowrap(默认) 父元素 设置子元素是否换行 justify-content:center / space-between 父元素 子元素在主轴上的显示方式 align-items:center 父元素 设置子元素在侧轴上的显示方式 了解详细的flex，看这里 ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:2:1","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"注意的点 尽量不要把宽高写死。即不要直接设置为固定px单位的值。可以使用\"百分比”，“vw”，“vh”、或者设置\"max-width/min-width”。 平均布局时适用上述float中的技巧。 flex和margin-xxx:auto;配合会有意外效果。 ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:2:2","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"grid布局 grid布局是未来的发展趋势，它简单、强大、易懂。 学习grid布局 通过一个游戏练习使用grid ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:3:0","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":" 标签 常用属性 作用 a href \\ target 1、跳转外部页面；2、跳转内部锚点；3、跳转到邮箱或电话 img src \\ alt \\ width \\ height 发出 get 请求，展示一张图片 form action \\ method 表单。发送 get 或 post 请求，然后刷新页面 input type [ “text” , “password” , “file”，“submit”，“hidden\"等 ] \\ checked \\ value \\ disabled \\ name 让用户输入内容。通过 type 确定不同的 input 内容，通常搭配 form 使用 table - 表格。使用相对较少 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:0:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"1. a 标签 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ href ] [href]可设置以下内容的值： 网址 https://untilthecore.github.io/ http://untilthecore.github.io/ //untilthecore.github.io/ (推荐用这种，它会自动寻找 https 或者 http 协议的网址) 路径 - 绝对路径：/a/b/c （以地址栏地址为基准寻找） - 相对路径：a/b/c 、 ./a/b/c (以当前文件为基准寻找) 伪协议 - \"javascript:代码;\"：代码部分可以写代码，这样点击会产生对应代码的效果。或者什么都不写，就是单纯的\"javascript:;\"，这样可以阻止 a 标签的默认跳转行为。 ； - \"mailto:邮箱地址\"：值为这个，点击时会调用默认邮件程序，可以发送邮件到填写的邮箱地址； - \"tel:手机号\"：值为这个，如果是手机端会调用手机默认拨号程序并准备拨向填写的手机号； id 锚点。如果 a 标签的 href 属性值为某个元素的 id 值，点击时会跳到这个元素的位置。举个例子： \u003c!-- 忽略HTML骨架 --\u003e \u003c!-- 假如有一个元素p，且 id 为 aaa --\u003e \u003cp id=\"aaa\"\u003e\u003c/p\u003e \u003c!-- 假如有一个 a 标签，它的 href=\"#aaa\",且这个 a 标签离 上述 p 间隔100个p标签的距离 --\u003e \u003ca href=\"#aaa\"\u003e跳向aaa\u003c/a\u003e 注：href 可以不设置值，但是点击时会造成页面刷新，有可能有的小伙伴认为可以填写上\"#\"来避免刷新，但是使用这种方式虽然不刷新，但是如果页面很高，而且这个 a 标签在很下面，会导致页面回到顶部。为了既防止页面刷新又防止回到页面顶部，可以使用\"javascript:;\" ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:1","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ target ] \"[target]\"可以设置以下内容的值： “_blank”：打开链接到一个新的浏览器标签页上。 “self”：默认值。打开链接在当前页面上。 “_top”：打开链接到最顶级的页面，通常和 iframe 使用。不过 iframe 不怎么用了，仅做了解。 “parent”：打开链接到父级页面，通常和 iframe 使用。比如 html \u003e iframe a \u003e iframe b，iframe b 中 a 的 target 设置为 parent，那么打开链接时会在 iframe a 中打开。同上，仅做了解。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:2","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"2. img 标签 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ src ] \"[src]\"值为图片的地址，可以使网上图片的超链接，也可以是本地的图片路径。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:1","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ alt ] \"[alt]\"的值为一段关于图片的描述，在图片加载失败或者网速过慢还没有加载出来时显示给用户看的内容。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:2","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ width \\ height ] \"[width] 和 [height]\"：设置图片的宽和高。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:3","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件[ onload ] \"[onload]\"：在图片加载完成后触发的事件 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:4","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件[ onerror] \"[onerror]\"：在图片加载失败后触发的事件。应用场景：比如用户访问某个图片失败了，通过这个事件可以替换 img 的 src 为一张默认图给用户看，用来保证一些用户体验性。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:5","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"响应式 \"[max-width]\"：为了保持图片在不同设备上显示效果一致，可以在 css 中设置 img 的max-width \u003cstyle\u003e img { max-width: 100%; } \u003c/style\u003e 而为什么要使用\"max-width\"而不是\"width\"呢？最重要的概念是保证图片不被拉伸，使用\"max-width\"可以保证图片小于屏幕宽度的时候不被拉伸到和屏幕一样宽，只到自己图片大小，从而避免造成看起来非常马赛克。如果还是不太明白可以写代码来帮助理解。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:6","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"3.form 标签 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ action ] \"[action]\"：一个处理此表单信息的程序所在的 URL。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:1","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ method ] \"[method ]\"：表单的提交方式，值有： post：表单数据会包含在表单体内然后发送给服务器。 get：表单数据会附加在 action 属性的 URI 中，并以 ‘?’ 作为分隔符，然后这样得到的 URI 再发送给服务器。如果要发送用户的账号密码等个人信息，请使用 post 方式。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:2","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件 [onsubmit] 表单提交时会触发 onsubmit 事件，有时候不想要表单默认的提交行为，我们可以给表单添加 id 然后通过 js 捕获 submit 事件并在事件处理函数中 return false 来阻止默认提交行为。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:3","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"4.input 标签 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ type ] \"[input]\"的 type 属性不同值可以产生各式各样的 input 内容，比如单选框 radio 、复选框 checkbox、颜色选择面板 color 等，大多数的类型值都是比较好理解的，但是这个 \"hidden\" 是个什么意思且具体用法是什么对于初学者来说有点懵。 为什么要有一个 type 属性值是\"hidden\"呢？这是因为有时候用户查询得到的数据返回时在地址栏上，而且这次查询得到的数据还要继续用来下一次查询，这时总不可能让用户自己去复制粘贴地址栏上的参数数据吧？所以为了避免这种情况，就需要\"hidden\"上场了。我们可以在需要用来保存上一次查询结果的地方增加一个\u003cinput type=\"hidden\" value=\"\"\u003e在我们得到返回结果后通过 js 将结果设置到这个 input 的 value 上，这样在我们下一次需要的时候就可以直接通过 value 去取到这个值了。 这种操作表单的方式被称作：隐藏域 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:1","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ name ] \"[name]\"属性作用有这些： 给 radio 和 checkbox 归类； 表单提交时传给后台的表单项的名字，它与属性 \"value\"组成键值对发送到后端，\"name\"是键。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:2","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ value ] \"[value]\"属性与\"name\"属性组成键值对发送到后端，value是值。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:3","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件[ onchange ] \"[onchange]\"：input 内容发生改变时触发的事件，比如类型为 text 的 input 有输入产生、类型为 select 的 input 选中了某个选项等。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:4","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件[ onfocus] \"[onfocus]\"：input 产生焦点时触发的事件。比如有一个类型为 text 的 input，我们鼠标点击了这个 input 时产生\"onfocus\"事件。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:5","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件[ onblur ] \"[onblur ]\"：input 失去焦点时触发的事件。比如一个类型为 text 的 input，内容输入完成后鼠标点击了非这个 input 区域时产生\"onblur\"事件。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:6","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"5.table 标签 \"[table]\"内容比较简单，主要就是练习一个熟练度。table 本身用的地方不是很多，但可以用来进行一些比较特殊表格布局。 使用table注意的点： 使用 css 设置border-collapse:collapse和border-spacing: 0，这样可以清除表格默认样式，使表格更好看。 不要在标签上设置表格样式，请在 css 中设置 table 的样式，这是官方说的。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:5:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"熟能生巧 一个简单表格的练习 打不开就看这里吧： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e th, td { border: 1px solid #ccc; text-align: center; } table { width: 300px; /* 设置单元格距离和单元格边框合并 */ border-collapse: collapse; border-spacing: 0; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003e价格\u003c/th\u003e \u003cth\u003e分类\u003c/th\u003e \u003cth\u003e日期\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003cth\u003e商品1\u003c/th\u003e \u003ctd\u003e100\u003c/td\u003e \u003ctd\u003e分类1\u003c/td\u003e \u003ctd\u003e2020-4-29\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e商品2\u003c/th\u003e \u003ctd\u003e100\u003c/td\u003e \u003ctd\u003e分类2\u003c/td\u003e \u003ctd\u003e2020-4-29\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e商品3\u003c/th\u003e \u003ctd\u003e100\u003c/td\u003e \u003ctd\u003e分类3\u003c/td\u003e \u003ctd\u003e2020-4-29\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003ctfoot\u003e \u003ctr\u003e \u003cth\u003e价格总计\u003c/th\u003e \u003c!-- colspan 让这一列占 3 列的宽度 --\u003e \u003ctd colspan=\"3\"\u003e300\u003c/td\u003e \u003c/tr\u003e \u003c/tfoot\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e 学习使人充盈，分享使人进步！ 此文为 UntilTheCore 原创，转载请说明作者和出处！ ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:5:1","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"1.HTML 是怎么产生的？ Tim Berners-Lee – 万维网的创建者 探寻互联网的初始，那么就必然要了解一下李老爷子本人，这位牛人为如今精彩纷呈的互联网世界打下了坚实的地基。1989 年他开发了世上第一个浏览器和第一个服务器，由此种下了互联网世界的种子，而且他发明的 WWW、URL、HTTP 一直延续至今。 那这个东西到底是怎么产生的呢？1、因为一杯咖啡，这让我联想到了 java；2、为了可以上网冲浪； ","date":"2020-04-28","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:1:0","tags":["HTML","入门"],"title":"HTML入门笔记1","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"categories":["前端"],"content":"2.HTML 怎么快速开始 现代的编辑器配合 Emmet 语法可以快速创建一个 HTML 的骨架，虽然这节省了我们书写骨架代码的时间，但还是有必要了解一下这些内容是什么。 在 vscode 中创建一个 HTML 的文件，使用 Emmet 语法输入! + tab键即可快速生成 html 骨架。 ","date":"2020-04-28","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:2:0","tags":["HTML","入门"],"title":"HTML入门笔记1","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"categories":["前端"],"content":"3.HTML 常用的章节标签有哪些？ 章节标签 介绍 h1~h6 文章内容标题 section 相对于 article 元素更加广泛，每个区块都可以使用，比如页面里的导航菜单、文章正文、文章的评论等。 article 代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客、一篇帖子、一段用户评论 p 段落 header 头部 footer 页脚 main 主要内容。内容主体区域，放在在 header 和 footer 中间 aside 旁支内容 div 划分 ","date":"2020-04-28","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:3:0","tags":["HTML","入门"],"title":"HTML入门笔记1","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"categories":["前端"],"content":"4.HTML 常用的内容标签有哪些？ 内容标签 介绍 ol + li ordered list + list item。无序列表 ul + li unordered list + list item。有序列表 dl+ dd + dt description list + term + data。自定义列表 pre 被 pre 包裹的内容以原始内容输出。比如内容有多个空格以及换行都正常显示 hr 分隔线 br 换行 a 超链接标签 em 语气上强调 strong 表示内容重要 code 内容字体等宽。一般包裹代码块 quote 引用。行内引用 blockquote 块级引用。被包裹的内容与上一行内容有一个缩进 ","date":"2020-04-28","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:4:0","tags":["HTML","入门"],"title":"HTML入门笔记1","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"categories":["前端"],"content":"5.HTML 的全局属性有哪些？ 全局属性即所有标签都会有的属性。 全局属性 介绍 class 类。给元素取一个类名，一般配合 css 设置样式 id 全局唯一 id，一般配合 js 使用，但是由于多处使用了浏览器也不报错，所以慎用 style 内联样式 title 鼠标移到标签上会在鼠标旁显示 title 的值 hidden 控制标签的隐藏 tabindex 如果元素需要被键盘 tab 键选中，可以设置值。值 \u003c 0，表示不被 tab 选中；值 == 0，表示最后被选中；值 \u003e 0 表示按值大小顺序选中 contenteditable 使标签可被直接编辑。想要更直观看到这个属性的效果可以点击这里修改样式试试看，或者复制下面的代码运行一下。 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width\" /\u003e \u003ctitle\u003eJS Bin\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 将style放入body并设置display为block再开启元素可编辑即可在网页上编辑页面样式 --\u003e \u003cstyle style=\"display:block;\" contenteditable\u003e header { background-color: pink; } \u003c/style\u003e \u003cheader\u003e我是头部\u003c/header\u003e \u003csection contenteditable\u003e我是章节\u003c/section\u003e \u003cfooter\u003e我是页脚\u003c/footer\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-28","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:5:0","tags":["HTML","入门"],"title":"HTML入门笔记1","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"categories":["前端"],"content":"在《如何用hugo搭建个人博客中》已经介绍了简单的主题引入办法，这里就不再赘述了。 现在我们来讲讲如何配置我们下载的新主题！（内容可能不多不全，Hugo的使用还在摸索阶段） 下载主题前要先看主题的Demo，看是否是自己想要的。没有Demo示例给看那就clone下来后跑起来看看是不是中意的，但是有的clone到的主题有可能较精简，怎么办呢？往下看。 选好中意的主题了，那么就一定要看作者的配置介绍，这个配置介绍一般都是介绍如何配置config.toml，但这个介绍可能不够全，那么就要自己看clone下来的主题中这个文件夹exampleSite中的config.toml。有的主题还有full-config.toml,这个内容更全面。以我使用的主题为例，路径结构为：themes\\hello-friend-ng\\exampleSite\\config.toml 接下来我将以我使用的主题为例，介绍config.toml配置内容 [[menu.main]] identifier = \"blog\" name = \"Blogs\" url = \"/posts\" [[menu.main]] name = \"Categories\" identifier = \"categories\" url = \"/categories/\" [[menu.main]] identifier = \"tags\" name = \"Tags\" url = \"/tags/\" [[menu.main]] identifier = \"about\" name = \"About\" url = \"about/\" 有[[menu.main]]即配置导航菜单，对应的地方如图： [[params.social]] name = \"email\" url = \"mailto:untilthecore@gmail.com\" [[params.social]] name = \"github\" url = \"https://github.com/UntilTheCore\" 有[[params.social]]即配置图标链接，对应地方如图： baseurl = \"https://untilthecore.github.io/\" title = \"My Blog\" languageCode = \"zh-Hans\" theme = \"hello-friend-ng\" baseurl：配置站点基址，如果要放在github上或者自己的云服务器上，请正确配置地址，否则出了能访问主页，其他地方都是 404 title：设置标题 languageCode：设置语言 theme：设置主题 其他的小地方的配置有注释，配合本地服务器可以方面查看修改后的效果。 第一次使用时，可能会好奇我们的 .md 文件是怎么产生标签（Tags）和分类（Categories）的？这就是通过使用hugo new posts/xxxxxx.md创建博客文件时，hugo自动为我们在文件头部生成了这些内容： title: \"正确使用hugo主题的姿势\" date: 2020-04-27T22:28:15+08:00 draft: false tags: [\"Hugo\"] categories: [\"教程\"] title：文章标题； data：文章被创建的事件 draft：是否草稿内容，如果为true，将不显示在博客站点中。 tags：为这篇文章创建标签，是数组形式[\"1\",\"2\",\"3\"] categories：为这篇文章创建分类，是数组形式[\"1\",\"2\",\"3\"] 由于在文章这里设置了tags和categories,所以我们可以在导航菜单中看到标签和文章分类信息。 在.md文件中，还可以设置更多其他的内容，比如设置版权信息等。有需要的话可以自行了解，我的经验就是多下几个主题，看看这些作者是怎么配置的。如果你有更多更好的信息，欢迎来信告诉我 创建博客后如何配置主题的基础内容介绍完毕，配置好这些就可以愉快地写博客啦！如果想配置更多更强大的内容，可以多多翻看Hugo官方文档。 写博客时要注意的点： 可能在posts中使用MarkDown插入图片时好好的，但是上传到github上后图片就不显示了呢？这是由于我们写文章时是在站点生成器的环境中，而上传的代码是在public中，为了保证上传后依然能正确显示，我使用的技巧是在public文件夹中新建一个static的文件夹用来保存我们文章的图片，且每一文章有对应的文件夹去保存图片，如图： 鉴于此，我们在posts/下写文章时使用的图片地址要以public/posts/文章标题/index.html为基准来找到public\\static目录。一段示例： ../../static/正确使用hugo主题的姿势/文章图片的保存方式.jpg\r 文章有误或不足之处，欢迎指正！谢谢！ ","date":"2020-04-27","objectID":"/posts/web/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hugo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A7%BF%E5%8A%BF/:0:0","tags":["Hugo"],"title":"正确使用hugo主题的姿势","uri":"/posts/web/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hugo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A7%BF%E5%8A%BF/"},{"categories":["前端"],"content":"本文由UntilTheCore原创，转载请说明作者和出处！ ","date":"2020-04-27","objectID":"/posts/web/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hugo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A7%BF%E5%8A%BF/:0:1","tags":["Hugo"],"title":"正确使用hugo主题的姿势","uri":"/posts/web/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hugo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A7%BF%E5%8A%BF/"},{"categories":["前端"],"content":"阅读前你需要了解这些内容： git MarkDown 使用 Hugo 搭建博客的步骤非常简单。 按照官网 Quick Start 即可快速创建一个站点。此文旨在对官方文档细节补充以及部署到自己的github上。 下载Hugo 解压出对应包中的Hugo.exe到一个空目录 将 2 中存放Hugo.exe的目录添加到系统变量\"path\"中。（不会设置？点这里） 进入Hugo官网 点击 Quick Start 当下载并设置好Hugo后，就可以直接从Step 2开始操作。 # 这个 quickstart 请改成你想要的名字,最好对应你github上的名字且全小写 # 比如：untilthecore.github.io-generator # 这个命令会生成 untilthecore.github.io-generator 的文件夹 # 这个文件夹就是博客站点的生成器，为了方便知道这个文件夹是干什么的，在最后加上 generator，当然 creator 也行 hugo new site quickstart # 那么真正要输入的命令为 hugo new site untilthecore.github.io-generator 当得到站点生成器文件夹后，使用 cd 命令进入文件夹并依次执行以下命令 # 为 untilthecore.github.io-generator 初始化 git 仓库 git init # 为站点设置一个主题（这个主题可以修改） git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke # 向配置文件写入 theme = \"ananke\" 即配置 ananke 主题 echo 'theme = \"ananke\"' \u003e\u003e config.toml 完成以上步骤站点就配置好了，输入以下命令即可创建第一篇博客了 hugo new posts/my-first-post.md 通过以上步骤，站点已经创建好了，且写了一篇文章，赶紧通过这个命令启动本地服务器看看你的博客是什么样子吧。 hugo server -D 基础完成了，接下来需要对站点进行一些设置，让它看起来更像是你自己的站点。找到config.toml 文件，配置这些内容： # 配置域，如果配置到了github上，这里要改为你自己github.io的地址。 baseURL = \"https://example.org/\" # 配置语言 中文可以改为 \"zh-Hans\" languageCode = \"en-us\" # 站点标签名，浏览器标签上的内容 title = \"My New Hugo Site\" # 主题设置，有新主题，就把主题名设置到这里 theme = \"ananke\" 本地操作已经完成了，想要将站点部署到github或者自己的云服务器上，请继续往下看。 都配置好后，确保你控制台还处于博客生成器目录下(即\"untilthecore.github.io-generator\") 输入 hugo 在博客生成器目录下会产生一个'public/‘的文件夹，将这个文件夹部署到服务器上就可以了。 ","date":"2020-04-27","objectID":"/posts/web/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:1","tags":["Hugo","git","MarkDown"],"title":"使用hugo搭建个人博客","uri":"/posts/web/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["前端"],"content":"如何在github上部署自己静态博客呢？ 在github上创建一个仓库，仓库名为自己github名字的且以\".github.io“结尾。（如：untilthecore.github.io） 上面步骤 11 中的 public 文件夹还记得吗？首先在博客生成器目录中将它忽略git管理，即放入.gitignore中。没有这个文件就创建一个这样的文件，内容保存 “/public/” 即可将此文件夹忽略； 进入 public 文件夹中，初始化 git 并将这个文件夹上传到步骤1中创建的github仓库中； 在浏览器中进入你自己仓库的Settings中，找到图片这个地方看看点击能不能看到博客呢？成功了，祝贺你！没成功，看看有没有哪一步错了？ ","date":"2020-04-27","objectID":"/posts/web/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:2","tags":["Hugo","git","MarkDown"],"title":"使用hugo搭建个人博客","uri":"/posts/web/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["日志"],"content":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- 日志级别从低到高分为TRACE \u003c DEBUG \u003c INFO \u003c WARN \u003c ERROR \u003c FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\u003e \u003c!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --\u003e \u003c!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\u003e \u003c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\u003e \u003cconfiguration scan=\"true\" scanPeriod=\"10 seconds\"\u003e \u003ccontextName\u003elogback\u003c/contextName\u003e \u003c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --\u003e \u003cproperty name=\"log.path\" value=\"logs\"/\u003e \u003cproperty name=\"project.name\" value=\"gyl-api\"/\u003e \u003c!--0. 日志格式和颜色渲染 --\u003e \u003c!-- 彩色日志依赖的渲染类 --\u003e \u003cconversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\"/\u003e \u003cconversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\"/\u003e \u003cconversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\"/\u003e \u003c!-- 彩色日志格式 --\u003e \u003cproperty name=\"CONSOLE_LOG_PATTERN\" value=\"${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(%L:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\"/\u003e \u003c!--1. 输出到控制台--\u003e \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003c/filter\u003e \u003cencoder\u003e \u003cPattern\u003e${CONSOLE_LOG_PATTERN}\u003c/Pattern\u003e \u003c!-- 设置字符集 --\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!--2. 输出到文档--\u003e \u003c!-- 2.1 level为 DEBUG 日志，时间滚动输出 --\u003e \u003cappender name=\"DEBUG_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-debug.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c!-- 设置字符集 --\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 日志归档 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-debug-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录debug级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.2 level为 INFO 日志，时间滚动输出 --\u003e \u003cappender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-info.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 每天日志归档路径以及格式 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录info级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003einfo\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.3 level为 WARN 日志，时间滚动输出 --\u003e \u003cappender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-warn.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-","date":"2019-11-16","objectID":"/posts/%E6%97%A5%E5%BF%97/logback%E9%85%8D%E7%BD%AE/:0:0","tags":["logback","入门","配置"],"title":"logback配置","uri":"/posts/%E6%97%A5%E5%BF%97/logback%E9%85%8D%E7%BD%AE/"},{"categories":["文档"],"content":"语法 ````text **Markdown是一种轻量级的「标记语言」** ![markdown](https://www.mdeditor.com/images/logos/markdown.png \"markdown\") Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md” ## MdEditor是一个在线编辑Markdown文档的编辑器 *MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。* \u003e Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如~~Pandoc~~，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 MdEditor源于Pandao的JavaScript开源项目，开源地址[Editor.md](https://github.com/pandao/editor.md \"Editor.md\")，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。 ![Pandao editor.md](https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png \"Pandao editor.md\") ## MdEditor的功能列表演示 # 标题H1 ## 标题H2 ### 标题H3 #### 标题H4 ##### 标题H5 ###### 标题H5 ### 字符效果和横线等 ---- ~~删除线~~ \u003cs\u003e删除线（开启识别HTML标签时）\u003c/s\u003e *斜体字* _斜体字_ **粗体** __粗体__ ***粗斜体*** ___粗斜体___ 上标：X\u003csub\u003e2\u003c/sub\u003e，下标：O\u003csup\u003e2\u003c/sup\u003e **缩写(同HTML的abbr标签)** \u003e 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The \u003cabbr title=\"Hyper Text Markup Language\"\u003eHTML\u003c/abbr\u003e specification is maintained by the \u003cabbr title=\"World Wide Web Consortium\"\u003eW3C\u003c/abbr\u003e. ### 引用 Blockquotes \u003e 引用文本 Blockquotes 引用的行内混合 Blockquotes \u003e 引用：如果想要插入空白换行`即\u003cbr /\u003e标签`，在插入处先键入两个以上的空格然后回车即可，[普通链接](https://www.mdeditor.com/)。 ### 锚点与链接 Links [普通链接](https://www.mdeditor.com/) [普通链接带标题](https://www.mdeditor.com/ \"普通链接带标题\") 直接链接：\u003chttps://www.mdeditor.com\u003e [锚点链接][anchor-id] [anchor-id]: https://www.mdeditor.com/ [mailto:test.test@gmail.com](mailto:test.test@gmail.com) GFM a-tail link @pandao 邮箱地址自动链接 test.test@gmail.com www@vip.qq.com \u003e @pandao ### 多语言代码高亮 Codes #### 行内代码 Inline code 执行命令：`npm install marked` #### 缩进风格 即缩进四个空格，也做为实现类似 `\u003cpre\u003e` 预格式化文本 ( Preformatted Text ) 的功能。 \u003c?php echo \"Hello world!\"; ?\u003e 预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | #### JS代码 ```javascript function test() { console.log(\"Hello world!\"); } ``` #### HTML 代码 HTML codes ```html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmate charest=\"utf-8\" /\u003e \u003cmeta name=\"keywords\" content=\"Editor.md, Markdown, Editor\" /\u003e \u003ctitle\u003eHello world!\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e body{font-size:14px;color:#444;font-family: \"Microsoft Yahei\", Tahoma, \"Hiragino Sans GB\", Arial;background:#fff;} ul{list-style: none;} img{border:none;vertical-align: middle;} \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 class=\"text-xxl\"\u003eHello world!\u003c/h1\u003e \u003cp class=\"text-green\"\u003ePlain text\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ``` ### 图片 Images 图片加链接 (Image + Link)： [![](https://www.mdeditor.com/images/logos/markdown.png)](https://www.mdeditor.com/images/logos/markdown.png \"markdown\") \u003e Follow your heart. ---- ### 列表 Lists #### 无序列表（减号）Unordered Lists (-) - 列表一 - 列表二 - 列表三 #### 无序列表（星号）Unordered Lists (*) * 列表一 * 列表二 * 列表三 #### 无序列表（加号和嵌套）Unordered Lists (+) + 列表一 + 列表二 + 列表二-1 + 列表二-2 + 列表二-3 + 列表三 * 列表一 * 列表二 * 列表三 #### 有序列表 Ordered Lists (-) 1. 第一行 2. 第二行 3. 第三行 #### GFM task list - [x] GFM task list 1 - [x] GFM task list 2 - [ ] GFM task list 3 - [ ] GFM task list 3-1 - [ ] GFM task list 3-2 - [ ] GFM task list 3-3 - [ ] GFM task list 4 - [ ] GFM task list 4-1 - [ ] GFM task list 4-2 ---- ### 绘制表格 Tables | 项目 | 价格 | 数量 | | -------- | -----: | :----: | | 计算机 | $1600 | 5 | | 手机 | $12 | 12 | | 管线 | $1 | 234 | First Header | Second Header ------------- | ------------- Content Cell | Content Cell Content Cell | Content Cell | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | Function name | Description | | ------------- | ------------------------------ | | `help()` | Display the help window. | | `destroy()` | **Destroy your computer!** | | Left-Aligned | Center Aligned | Right Aligned | | :------------ |:---------------:| -----:| | col 3 is | some wordy text | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | | Item | Value | | --------- | -----:| | Computer | $1600 | | Phone |","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:0:0","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"MdEditor是一个在线编辑Markdown文档的编辑器 MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。 Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 MdEditor源于Pandao的JavaScript开源项目，开源地址Editor.md，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。 Pandao editor.mdPandao editor.md \"\rPandao editor.md\r ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:1:0","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"MdEditor的功能列表演示 标题H1 ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:2:0","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"标题H2 ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:0","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"标题H3 标题H4 标题H5 标题H5 ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:1","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"字符效果和横线等 删除线 删除线（开启识别HTML标签时）斜体字 斜体字 粗体 粗体 粗斜体 粗斜体 上标：X2，下标：O2缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTMLspecification is maintained by the W3C. ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:2","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"引用 Blockquotes 引用文本 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即\u003cbr /\u003e标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:3","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"锚点与链接 Links 普通链接 普通链接带标题 直接链接：https://www.mdeditor.com [锚点链接][anchor-id] [anchor-id]: https://www.mdeditor.com/ mailto:test.test@gmail.com GFM a-tail link @pandao 邮箱地址自动链接 test.test@gmail.com www@vip.qq.com @pandao ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:4","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"多语言代码高亮 Codes 行内代码 Inline code 执行命令：npm install marked 缩进风格 即缩进四个空格，也做为实现类似 \u003cpre\u003e 预格式化文本 ( Preformatted Text ) 的功能。 \u003c?php echo \"Hello world!\"; ?\u003e 预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | JS代码 function test() { console.log(\"Hello world!\"); } HTML 代码 HTML codes \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmate charest=\"utf-8\" /\u003e \u003cmeta name=\"keywords\" content=\"Editor.md, Markdown, Editor\" /\u003e \u003ctitle\u003eHello world!\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e body{font-size:14px;color:#444;font-family: \"Microsoft Yahei\", Tahoma, \"Hiragino Sans GB\", Arial;background:#fff;} ul{list-style: none;} img{border:none;vertical-align: middle;} \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 class=\"text-xxl\"\u003eHello world!\u003c/h1\u003e \u003cp class=\"text-green\"\u003ePlain text\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:5","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"图片 Images 图片加链接 (Image + Link)： Follow your heart. ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:6","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"列表 Lists 无序列表（减号）Unordered Lists (-) 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*) 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+) 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 Ordered Lists (-) 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:7","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 First Header Second Header Content Cell Content Cell Content Cell Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell Function name Description help() Display the help window. destroy() Destroy your computer! Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes © \u0026 ¨ ™ ¡ £ \u0026 \u003c \u003e ¥ € ® ± ¶ § ¦ ¯ « · X² Y³ ¾ ¼ × ÷ » 18ºC \" ' [========] ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:8","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"Emoji表情 :smiley: Blockquotes :star: GFM task lists \u0026 Emoji \u0026 fontAwesome icon emoji \u0026 editormd logo emoji :editormd-logo-5x: :smiley: @mentions, :smiley: #refs, links, formatting, and tagssupported :editormd-logo:; list syntax required (any unordered or ordered list supported) :editormd-logo-3x:; :smiley: this is a complete item :smiley:; []this is an incomplete item test link :fa-star: @pandao; this is an incomplete item :fa-star: :fa-gear:; :smiley: this is an incomplete item test link :fa-star: :fa-gear:; :smiley: this is :fa-star: :fa-gear: an incomplete item test link; 反斜杠 Escape *literal asterisks* [========] ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:9","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"科学公式 TeX(KaTeX) $$E=mc^2$$ 行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。 $$x \u003e y$$ $$(\\sqrt{3x-1}+(1+x)^2)$$ $$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$ 多行公式： \\displaystyle \\left( \\sum\\_{k=1}^n a\\_k b\\_k \\right)^2 \\leq \\left( \\sum\\_{k=1}^n a\\_k^2 \\right) \\left( \\sum\\_{k=1}^n b\\_k^2 \\right) \\displaystyle \\frac{1}{ \\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{ \\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} { 1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } } f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:10","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"分页符 Page break Print Test: Ctrl + P [========] ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:11","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"绘制流程图 Flowchart st=\u003estart: 用户登陆 op=\u003eoperation: 登陆操作 cond=\u003econdition: 登陆成功 Yes or No? e=\u003eend: 进入后台 st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop [========] ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:12","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"绘制序列图 Sequence Diagram Andrew-\u003eChina: Says Hello Note right of China: China thinks\\nabout it China--\u003eAndrew: How are you? Andrew-\u003e\u003eChina: I am good thanks! ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:13","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["文档"],"content":"End ","date":"2019-11-16","objectID":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/:3:14","tags":["MarkDown","入门"],"title":"md文档语法","uri":"/posts/%E6%96%87%E6%A1%A3/md%E8%AF%AD%E6%B3%95/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring-aop%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:0:0","tags":["spring","源码","spring源码"],"title":"Spring AOP实现原理","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring-aop%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["spring源码"],"content":"1.常见的实现类： 容器：AbstractApplicationContext抽象父类，核心(模板)方法 refresh()。 ClassPathXmlApplicationContext XML方式启动。 AnnotationConfigWebApplicationContext 注解方式启动，对局部代码进行测试时比较好用。 AnnotationConfigServletWebServerApplicationContext SpringBoot启动默认使用的上下文类。 ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:0:1","tags":["spring","源码","spring源码"],"title":"Spring IOC容器初始化流程","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["spring源码"],"content":"2. spring ioc容器初始化的核心方法refresh，AbstractApplicationContext.refresh() 。 外层方法骨架 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. // 不太重要，预刷新，做一些准备工作。记录了启动时间戳，标记为活动，非关闭状态。 prepareRefresh(); /** * TODO 重点：解析xml配置文件，创建beanFactory，包装BeanDefinition */ // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 注册一些对事件、监听器等的支持 prepareBeanFactory(beanFactory); try { // 钩子方法，BeanFactory创建后，对BeanFactory的自定义操作。 // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // TODO 重点：这里调用了postProcessBeanDefinitionRegistry(registry);springboot中很多激活自动配置的注解都是通过这里导入的。 // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // TODO 重点：从beanFactory中获取所有的BeanPostProcessor，优先进行getBean操作，实例化 // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // 国际化支持 // Initialize message source for this context. initMessageSource(); // 初始化ApplicationEventMulticaster。 如果上下文中未定义，则使用SimpleApplicationEventMulticaster。 // Initialize event multicaster for this context. initApplicationEventMulticaster(); // 钩子方法，springBoot中的嵌入式tomcat就是通过此方法实现的 // Initialize other special beans in specific context subclasses. onRefresh(); // 监听器注册 // Check for listener beans and register them. registerListeners(); // TODO 重点方法：完成容器中bean的实例化，及代理的生成等操作。 // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // 完成此上下文的刷新，调用LifecycleProcessor的onRefresh（）方法并发布 // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:0:2","tags":["spring","源码","spring源码"],"title":"Spring IOC容器初始化流程","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring-xml%E8%A7%A3%E6%9E%90%E5%8F%8Abeandefinition%E5%B0%81%E8%A3%85/:0:0","tags":["spring","源码","spring源码"],"title":"Spring XML解析及Beandefinition封装","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring-xml%E8%A7%A3%E6%9E%90%E5%8F%8Abeandefinition%E5%B0%81%E8%A3%85/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/springioc-getbean%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/:0:0","tags":["spring","源码","spring源码"],"title":"SpringIOC-getBean核心流程","uri":"/posts/spring%E6%BA%90%E7%A0%81/springioc-getbean%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/springmvc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:0:0","tags":["spring","源码","spring源码"],"title":"SpringMVC实现原理","uri":"/posts/spring%E6%BA%90%E7%A0%81/springmvc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:0","tags":["spring","源码","spring源码"],"title":"Spring事务实现原理\u0026事务执行流程","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-applicationlistener/:0:0","tags":["spring","源码","spring源码"],"title":"Spring扩展点-ApplicationListener","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-applicationlistener/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-beandefinitionregistrypostprocessor/:0:0","tags":["spring","源码","spring源码"],"title":"Spring扩展点-BeanDefinitionRegistryPostProcessor","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-beandefinitionregistrypostprocessor/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-beanpostprocessor/:0:0","tags":["spring","源码","spring源码"],"title":"Spring扩展点-BeanPostProcessor","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-beanpostprocessor/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-factorybean/:0:0","tags":["spring","源码","spring源码"],"title":"Spring扩展点-FactoryBean","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-factorybean/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-scope/:0:0","tags":["spring","源码","spring源码"],"title":"Spring扩展点-Scope","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-scope/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-%E5%85%B6%E4%BB%96%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3/:0:0","tags":["spring","源码","spring源码"],"title":"Spring扩展点-其他钩子方法、策略接口","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%89%A9%E5%B1%95%E7%82%B9-%E5%85%B6%E4%BB%96%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3/"},{"categories":["spring源码"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:0:0","tags":["spring","源码","spring源码"],"title":"Spring注解实现原理","uri":"/posts/spring%E6%BA%90%E7%A0%81/spring%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["test"],"content":"Hello World Hello Kitty Hello Kitty ","date":"2019-11-16","objectID":"/posts/test/:0:0","tags":["test"],"title":"test","uri":"/posts/test/"},{"categories":["Linux"],"content":"清理Docker占用的磁盘空间 摘要：用了Docker，好处挺多的，但是有一个不大不小的问题，它会一不小心占用太多磁盘，这就意味着我们必须及时清理。 作为一个有信仰的技术公司，我们Fundebug的后台采用了酷炫的全Docker化架构，所有服务，包括数据库都运行在Docker里面。这样做当然不是为了炫技，看得清楚的好处还是不少的： 所有服务器的配置都非常简单，只安装了Docker，这样新增服务器的时候要简单很多。 可以非常方便地在服务器之间移动各种服务，下载Docker镜像就可以运行，不需要手动配置运行环境。 开发/测试环境与生产环境严格一致，不用担心由于环境问题导致部署失败。 至少，上线这一年多来，Docker一直非常稳定，没有出什么问题。但是，它有一个不大不小的问题，会比较消耗磁盘空间。 如果Docker一不小心把磁盘空间全占满了，你的服务也就算玩完了，因此所有Docker用户都需要对此保持警惕。当然，大家也不要紧张，这个问题还是挺好解决的。 1. docker system命令 在谁用光了磁盘？Docker System命令详解中，我们详细介绍了docker system命令,它可以用于管理磁盘空间。 docker system df命令，类似于Linux上的df命令，用于查看Docker的磁盘使用情况: 可知，Docker镜像占用了7.2GB磁盘，Docker容器占用了104.8MB磁盘，Docker数据卷占用了1.4GB磁盘。 docker system prune命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)。docker system prune -a命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的Docker镜像都删掉了…所以使用之前一定要想清楚吶。 执行docker system prune -a命令之后，Docker占用的磁盘空间减少了很多： 2. 手动清理Docker镜像/容器/数据卷 对于旧版的Docker(版本1.13之前)，是没有docker system命令的，因此需要进行手动清理。这里给出几个常用的命 删除所有关闭的容器 docker ps -a | grep Exit | cut -d ' ' -f 1 | xargs docker rm 删除所有dangling镜像(即无tag的镜像)： docker rmi $(docker images | grep \"^\u003cnone\u003e\" | awk \"{print $3}\") 删除所有dangling数据卷(即无用的volume)： docker volume rm $(docker volume ls -qf dangling=true) 3. 限制容器的日志大小 有一次，当我使用1与2提到的方法清理磁盘之后，发现并没有什么作用，于是，我进行了一系列分析。 在Ubuntu上，Docker的所有相关文件，包括镜像、容器等都保存在**/var/lib/docker/**目录中： du -hs /var/lib/docker/ 97G /var/lib/docker/ Docker竟然使用了将近100GB磁盘，这也是够了。使用du命令继续查看，可以定位到真正占用这么多磁盘的目录： 92G /var/lib/docker/containers/a376aa694b22ee497f6fc9f7d15d943de91c853284f8f105ff5ad6c7ddae7a53 由docker ps可知，nginx容器的ID恰好为a376aa694b22，与上面的目录**/var/lib/docker/containers/a376aa694b22**的前缀一致： docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a376aa694b22 192.168.59.224:5000/nginx:1.12.1 \"nginx -g 'daemon off\" 9 weeks ago Up 10 minutes nginx 因此，nginx容器竟然占用了92GB的磁盘。进一步分析可知，真正占用磁盘空间的是nginx的日志文件。那么这就不难理解了。我们Fundebug每天的数据请求为百万级别，那么日志数据自然非常大。 使用truncate命令，可以将nginx容器的日志文件“清零”： truncate -s 0 /var/lib/docker/containers/a376aa694b22ee497f6fc9f7d15d943de91c853284f8f105ff5ad6c7ddae7a53/*-json.log 当然，这个命令只是临时有作用，日志文件迟早又会涨回来。要从根本上解决问题，需要限制nginx容器的日志文件大小。这个可以通过配置日志的max-size来实现，下面是nginx容器的docker-compose配置文件： nginx: image: nginx:1.12.1 restart: always logging: driver: \"json-file\" options: max-size: \"5g\" 重启nginx容器之后，其日志文件的大小就被限制在5GB，再也不用担心了~ 4. 重启Docker 还有一次，当我清理了镜像、容器以及数据卷之后，发现磁盘空间并没有减少。根据Docker disk usage提到过的建议，我重启了Docker，发现磁盘使用率从83%降到了19%。根据高手指点，这应该是与内核3.13相关的BUG，导致Docker无法清理一些无用目录： it’s quite likely that for some reason when those container shutdown, docker couldn’t remove the directory because the shm device was busy. This tends to happen often on 3.13 kernel. You may want to update it to the 4.4 version supported on trusty 14.04.5 LTS. The reason it disappeared after a restart, is that daemon probably tried and succeeded to clean up left over data from stopped containers. 我查看了一下内核版本，发现真的是3.13: uname -r 3.13.0-86-generic 如果你的内核版本也是3.13，而且清理磁盘没能成功，不妨重启一下Docker。当然，这个晚上操作比较靠谱。 参考 谁用光了磁盘？Docker System命令详解 INTRODUCING DOCKER 1.13 Docker文档：docker system Docker文档：json-file Docker disk usage ","date":"2019-05-10","objectID":"/posts/linux/docker-clean/:0:0","tags":["Synology","docker"],"title":"清理 Docker 占用的磁盘空间","uri":"/posts/linux/docker-clean/"},{"categories":["Linux"],"content":"1. 安装 acme.sh 安装很简单, 一个命令: curl https://get.acme.sh | sh 普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步: 把 acme.sh 安装到你的 home 目录下: ~/.acme.sh/\r并创建 一个 bash 的 alias, 方便你的使用: alias acme.sh=~/.acme.sh/acme.sh 自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书. 更高级的安装选项请参考: https://github.com/Neilpang/acme.sh/wiki/How-to-install 安装过程不会污染已有的系统任何功能和文件, 所有的修改都限制在安装目录中: ~/.acme.sh/ ","date":"2019-01-15","objectID":"/posts/linux/acme/:1:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"},{"categories":["Linux"],"content":"2. 生成证书 acme.sh 实现了 acme 协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证. 1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了. acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/ 只需要指定域名, 并指定域名所在的网站根目录. acme.sh 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用. 如果你用的 apache服务器, acme.sh 还可以智能的从 apache的配置中自动完成验证, 你不需要指定网站根目录: acme.sh --issue -d mydomain.com --apache 如果你用的 nginx服务器, 或者反代, acme.sh 还可以智能的从 nginx的配置中自动完成验证, 你不需要指定网站根目录: acme.sh --issue -d mydomain.com --nginx 注意, 无论是 apache 还是 nginx 模式, acme.sh在完成验证之后, 会恢复到之前的状态, 都不会私自更改你本身的配置. 好处是你不用担心配置被搞坏, 也有一个缺点, 你需要自己配置 ssl 的配置, 否则只能成功生成证书, 你的网站还是无法访问https. 但是为了安全, 你还是自己手动改配置吧. 如果你还没有运行任何 web 服务, 80 端口是空闲的, 那么 acme.sh 还能假装自己是一个webserver, 临时听在80 端口, 完成验证: acme.sh --issue -d mydomain.com --standalone 更高级的用法请参考: https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert 2. 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权. 这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证. 坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。 acme.sh --issue --dns -d mydomain.com 然后, acme.sh 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可. 等待解析完成之后, 重新生成证书: acme.sh --renew -d mydomain.com 注意第二次这里用的是 --renew dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证. acme.sh 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成. 以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的. 然后: export DP_Id=\"1234\" export DP_Key=\"sADDsdasdgdsf\" acme.sh --issue --dns dns_dp -d aa.com -d www.aa.com 证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了. 直接生成就好了: acme.sh --issue -d mydomain2.com --dns dns_dp 更详细的 api 用法: https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md First you need to login to your Aliyun account to get your API key. https://ak-console.aliyun.com/#/accesskey export Ali_Key=\"sdfsdfsdfljlbjkljlkjsdfoiwje\" export Ali_Secret=\"jlsdflanljkljlfdsaklkjflsa\" Ok, let’s issue a cert now: acme.sh --issue --dns dns_ali -d example.com -d www.example.com The Ali_Key and Ali_Secret will be saved in ~/.acme.sh/account.conf and will be reused when needed. ","date":"2019-01-15","objectID":"/posts/linux/acme/:2:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"},{"categories":["Linux"],"content":"3. copy/安装 证书 前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方. 注意, 默认生成的证书都放在安装目录下: ~/.acme.sh/, 请不要直接使用此目录下的文件, 例如: 不要直接让 nginx/apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化. 正确的使用方法是使用 --installcert 命令,并指定目标位置, 然后证书文件会被copy到相应的位置, 例如: acme.sh --installcert -d \u003cdomain\u003e.com \\ --key-file /etc/nginx/ssl/\u003cdomain\u003e.key \\ --fullchain-file /etc/nginx/ssl/fullchain.cer \\ --reloadcmd \"service nginx force-reload\" (一个小提醒, 这里用的是 service nginx force-reload, 不是 service nginx reload, 据测试, reload 并不会重新加载证书, 所以用的 force-reload) Nginx 的配置 ssl_certificate 使用 /etc/nginx/ssl/fullchain.cer ，而非 /etc/nginx/ssl/\u003cdomain\u003e.cer ，否则 SSL Labs 的测试会报 Chain issues Incomplete 错误。 --installcert命令可以携带很多参数, 来指定目标文件. 并且可以指定 reloadcmd, 当证书更新以后, reloadcmd会被自动调用,让服务器生效. 详细参数请参考: https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc 值得注意的是, 这里指定的所有参数都会被自动记录下来, 并在将来证书自动更新以后, 被再次自动调用. ","date":"2019-01-15","objectID":"/posts/linux/acme/:3:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"},{"categories":["Linux"],"content":"4. 更新证书 目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心. ","date":"2019-01-15","objectID":"/posts/linux/acme/:4:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"},{"categories":["Linux"],"content":"5. 更新 acme.sh 目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步. 升级 acme.sh 到最新版 : acme.sh --upgrade 如果你不想手动升级, 可以开启自动升级: acme.sh --upgrade --auto-upgrade 之后, acme.sh 就会自动保持更新了. 你也可以随时关闭自动更新: acme.sh --upgrade --auto-upgrade 0 ","date":"2019-01-15","objectID":"/posts/linux/acme/:5:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"},{"categories":["Linux"],"content":"6. 出错怎么办： 如果出错, 请添加 debug log： acme.sh --issue ..... --debug 或者： acme.sh --issue ..... --debug 2 请参考： https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh 最后, 本文并非完全的使用说明, 还有很多高级的功能, 更高级的用法请参看其他 wiki 页面. https://github.com/Neilpang/acme.sh/wiki ","date":"2019-01-15","objectID":"/posts/linux/acme/:6:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"}]