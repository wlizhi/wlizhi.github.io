[{"categories":["linux"],"content":"1. 基础介绍 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:1:0","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"发行的linux版本 Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS linux各个版本\"\rlinux各个版本\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:1:1","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"系统目录结构 linux目录结构\"\rlinux目录结构\r 系统启动必须： 技巧\r\r /boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。 /etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。 /lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中 \r\r 指令集合： 技巧\r\r /bin：存放着最常用的程序和指令 /sbin：只有系统管理员能使用的程序和指令。 \r\r 外部文件管理： 技巧\r\r /dev ：Device(设备)的缩写, 存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。 /media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。 /mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 \r\r 临时文件 技巧\r\r /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。 /tmp：这个目录是用来存放一些临时文件的。 \r\r 账户： 技巧\r\r /root：系统管理员的用户主目录。 /home：用户的主目录，以用户的账号命名的。 /usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序与指令。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 \r\r 运行过程中要用： 技巧\r\r /var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。 /proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。 \r\r 扩展用的： 技巧\r\r /opt：默认是空的，我们安装额外软件可以放在这个里面。 /srv：存放服务启动后需要提取的数据（不用服务器就是空） \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:1:2","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"linux基础命令 shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。 技巧\r\r# shutdown -P now ### 关闭机器 # shutdown -H now ### 停止机器 # shutdown -r 09:35 ### 在 09:35am 重启机器\r\r 要取消即将进行的关机，只要输入命令： # shutdown -c halt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。 技巧\r\r# halt ### 停止机器 # halt -p ### 关闭机器 # halt –reboot ### 重启机器\r\r poweroff 会发送一个 ACPI 信号来通知系统关机。 技巧\r\r# poweroff ### 关闭机器 # poweroff –halt ### 停止机器 # poweroff –reboot ### 重启机器\r\r reboot 命令 reboot 通知系统重启。 技巧\r\r# reboot ### 重启机器 # reboot –halt ### 停止机器 # reboot -p ### 关闭机器\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:1:3","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"2. linux用户/用户组 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:2:0","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"增加一个用户组 技巧\r\rgroupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 例1： # groupadd group1 ##此命令向系统中增加了一个新组group1 例2： # groupadd -g 1003 group2 ##此命令向系统中增加了一个新组group2，同时指定新组的组标识号是1003 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:2:1","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"删除一个用户组 技巧\r\rgroupdel 用户组 例：# groupdel group1 ##此命令从系统中删除组group1。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:2:2","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"修改用户组的属性 技巧\r\rgroupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n 新用户组 将用户组的名字改为新名字 例1： # groupmod –g 10000 -n group3 group2 ##此命令将组group2的标识号改为10000，组名修改为group3。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:2:3","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"添加用户账号 技巧\r\r参数说明： 选项: -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名: 指定新账号的登录名。 useradd 选项 用户名 例1： # useradd –d /usr/peter -m peter ##创建用户peter，其中-d和-m选项用来为登录名peter产生一个主目录/usr/peter。 例2： # useradd -s /bin/sh -g group1 –G group2,root peter2 ##新建用户peter2，登录Shell是 /bin/sh，属于group1，又属于group2和root。 这里可能新建组：#groupadd group1及groupadd group2 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:2:4","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"删除账号 技巧\r\r userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 例如： # userdel -r peter2 ##删除用户peter2（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:2:5","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"修改账号 技巧\r\rusermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： # usermod -s /bin/sh -d /home/p –g group2 peter ##将用户peter的登录Shell修改为sh，主目录改为/home/p，用户组改为group2。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:2:6","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"用户口令的管理 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 技巧\r\rpasswd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。\r\r 如果默认用户名，则修改当前用户的口令。例如，假设当前用户是peter，则下面的命令修改该用户自己的口令： 技巧\r\r$ passwd Old password:****** New password:******* Re-enter new password:*******\r\r 如果是超级用户，可以用下列形式指定任何用户的口令： 技巧\r\r# passwd peter New password:******* Re-enter new password:*******\r\r 为用户指定空口令时，执行下列形式的命令：# passwd -d peter passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：# passwd -l peter ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:2:7","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"切换用户组 技巧\r\r$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:2:8","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"与用户账号有关的系统文件 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等 /etc/passwd文件 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 技巧\r\r例子： ＃ cat /etc/passwd root: x:0:0:Superuser:/: daemon: x:1:1:System daemons:/etc: bin: x:2:2:Owner of system commands:/bin: sys: x:3:3:Owner of system files:/usr/sys: adm: x:4:4:System accounting:/usr/adm: uucp: x:5:5:UUCP administrator:/usr/lib/uucp: auth: x:7:21:Authentication administrator:/tcb/files/auth: cron: x:9:16:Cron daemon:/usr/spool/cron: listen: x:37:4:Network daemon:/usr/net/nls: lp: x:71:18:Printer administrator:/usr/spool/lp: \r\r 每一行记录对应着一个用户（其中bin/sys/adm/uucp/lp/nobody是伪用户），每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell /etc/group文件 用户组的所有信息都存放在/etc/group文件中。 技巧\r\rroot::0:root bin::2:root,bin sys::3:root,uucp adm::4:root,adm daemon::5:root,daemon lp::7:root,lp users::20:root,sam\r\r 此文件的格式类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:2:9","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"3. 文件与目录 ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:3:0","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"文件基本属性 1. 文件的属性概貌 Lighthouse (image)\"\rLighthouse (image)\r 技巧\r\r第一个字符：代表这个文件的类型，是目录、文件，还是一个链接等等 [ d ] 目录 [ - ] 文件 [ l ] 链接文档(link file) [ b ] 可供储存的接口设备(可随机存取装置) [ c ] 串行端口设备，例如键盘、鼠标(一次性读取装置) 接下来的字符：以三个一组分成三组，用 r、w、x 三个参数的组合表示，位置不会改变 [ r ] 代表可读(read) [ w ] 代表可写(write) [ x ] 代表可执行(execute) [ - ] 没有权限\r\r 2. 文件的属主与属组 每一个文件，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 chgrp：更改文件属组 技巧\r\rchgrp [-R] 属组名 文件名 参数选项 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。\r\r chown：更改文件属主，也可以同时更改文件属组 语法： chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 进入 /root 目录（~）将install.log的拥有者改为bin这个账号： 例： chown root:root aa ##更改aa的属主与属组 chmod：更改文件9个属性 文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！ 变更权限的指令chmod的语法是这样的： 技巧\r\r chmod [-R] xyz 文件或目录 选项与参数： xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下： chmod +x aa ##更改aa的属性,加x权限 chmod 777 aa ##更改aa的属性，三组权限都设置成7 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:3:1","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"文件与目录管理命令 使用 man [命令] 来查看各个命令的使用文档，如 ：man cp 技巧\r\rls: 列出目录 —ll cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 —–scp网络复制 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:3:2","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"硬链接与软链接 硬连接 技巧\r\r硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\r\r 软连接 技巧\r\r另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 例： $touch a #创建一个测试文件a $ ln a b #创建a的一个硬连接文件b –echo 123 \u003e a ##a,b的内容同时变为123 $ ln -s a c #创建a的一个符号连接文件c $ ls -li # -i参数显示文件的inode节点信息 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:3:3","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"4. 安装程序rpm/yum ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:4:0","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"1. rpm方式 需要去下载相应的rpm格式的安装包xxxx.rpm 技巧\r\rrpm [参数] rpm包 -i 安装 -U 更新（很少用） -e 卸载 -v 显示安装信息 -h 显示安装进度 例： rpm -ivh jdk-8u172-linux-x64.rpm 安装jdk8并显示安装进度和安装信息 rpm -qa|grep jdk查看jdk的安装包 rpm -e jdk1.8-1.8.0_221-fcs.x86_64 卸载jdk8 ，只适用于rpm包安装的软件\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:4:1","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"2. yum方式 yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。 基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 2.1 yum语法 技巧\r\ryum [options] [command] [package …] options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为\"yes\"），-q（不显示安装的过程）等等。 command：要进行的操作。 package操作的对象。 例： yum search jdk 搜索jdk安装包 yum install -y java-1.8.0-openjdk.x86_64 安装openjdk，-y表示安装过程中的询问自动选y yum list installed ｜grep jdk 列出安装的jdk软件包 yum remove java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-headless.x86_64 卸载jdk\r\r 2.2 yum常用命令 示例\r\r1.列出所有可更新的软件清单命令：yum check-update 2.更新所有软件命令：yum update 3.仅安装指定的软件命令：yum install \u003cpackage_name\u003e 4.仅更新指定的软件命令：yum update \u003cpackage_name\u003e 5.列出所有可安裝的软件清单命令：yum list 6.删除软件包命令：yum remove \u003cpackage_name\u003e 7.查找软件包 命令：yum search 8.清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers\r\r 2.3 yum源 官方的yum源在国内访问效果不佳。需要改为国内比较好的阿里云或者网易的yum源 在/etc/yum..repos.d/下进行如下操作(请做好相应备份)： 示例\r\rwget http://mirrors.163.com/.help/CentOS7-Base-163.repo mv CentOS7-Base-163.repo CentOS-Base.repo 重建缓存： yum clean all yum makecache\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:4:2","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"3. 配置环境变量 在Linux系统下，安装应用程序后，在安装目录之外，可能仍然会出现 “command not found ”。 要解决所有地方都能使用应用程序，就涉及到环境变量path的设置问题 3.1 配置环境变量 系统环境变量文件在/etc下的profile文件，我们可以用vi profile命令来编辑该文件，将变量添加进去 一般需要将安装文件的bin目录加入path中，可在profile中加入下面一行代码，如： 示例\r\rvim /etc/profile # 末尾追加以下内容 export JAVA_HOME=/usr/java/default export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\r\r 3.2 环境变量生效 source /etc/profile ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:4:3","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"5. shell脚本 shell语言是一门linux系统下的工具语言，主要用于写一些linux系统下的操作命令，实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。或者直接理解为shell命令是可以执行多个linux命令的脚本。Shell 种类众多，有以下种类（一般使用的 Bash，就是 Bourne Again Shell，它是大多数Linux 系统默认的 Shell）： 示例\r\rBourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh）\r\r shell并不复杂，有编程基础的话，简单入门两三个小时就可以入门，主要是把一些重复操作的linux命令写成shell脚本来执行一下。以下列出shell常规的一些要素： ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:5:0","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"1. 解释器与执行shell 示例\r\r解释器 #!/bin/sh Bourne shell版本 #!/bin/bash Bourne Again Shell 版本 执行shell chomd +x ./test.sh #使脚本具有执行权限 ./test.sh #执行脚本 “./”表示当前目录下\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:5:1","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"2. 演示 #!/bin/bash ##声明bash脚本 ##demo ##注释 echo $PATH ##打印PATH环境变量 name=\"Peter\" ##定义变量name echo $name ##打印name值 echo \"I am ${name}'s friend\" ##字符串拼接 echo \"\" name2=\"I am ${name}'s good friend\" ##字符串拼接 echo $name2 echo \"\" names=(\"Peter\" \"james\" \"deer\") ##定义数组 echo ${names[@]} ##遍历数组 echo \"I am ${names[1]}'s friend\" ##第二个元素 echo \"I have ${#names[@]}friends\" ##数组长度 echo \"\" for var in ${names[@]}; ##循环数组 do if test $var = 'Peter' ##字符串相等 then echo \"I am Peter\" else echo \"I am ${var}'s friend\" fi done echo \"\" if [ $(ps -ef | grep -c \"ssh\") -gt 1 ]; ##查找是否有ssh服务 then echo \"ssh service open\"; fi echo \"\" echo \"sh arg: $0$1\" ##sh的传参 重定向： 1、test ‘aa’ -eq “bb” \u003e out ##命令输出到 out文件，报错信息并不会进入out 2、test ‘aa’ -eq “bb” \u003e out 2\u003e\u00261 ##将stderr合并到stdout，则报错信息进入了out ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:5:2","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6. 常用命令 ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:0","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6.1 最常用的是cd 命令 示例\r\rcd 进入用户主目录； cd ~ 进入用户主目录； cd - 返回进入此目录之前所在的目录； cd .. 返回上级目录（若当前目录为“/“，则执行完后还在“/\"；\"..“为上级目录的意思）； cd ../.. 返回上两级目录；\r\r ls，ll， wget， curl， history ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:1","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6.2 新建文件夹和文件：mkdir touch 示例\r\rmkdir 创建文件夹 mkdir dirname 直接跟文件夹名，可在当前目录下创建文件夹 mkdir /opt/lamp/dirname 可跟路径 mkdir -p /opt/lam/dirname 假如lam不存在，需要用-p才可以创建该文件夹 touch 新建文件 touch dilename 可直接跟文件名在当前目录下创建新的文件 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:2","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6.3 cat/less/more/tail等文件查看命令 详细\r\r-n或-number：有1开始对所有输出的行数编号； -b或–number-nonblank：和-n相似，只不过对于空白行不编号； -s或–squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行； -A：显示不可打印字符，行尾显示“$”； -e：等价于\"-vE\"选项； -t：等价于\"-vT\"选项； -e：文件内容显示完毕后，自动退出； -f：强制显示文件； -g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度； -l：搜索时忽略大小写的差异； -N：每一行行首显示行号； -s：将连续多个空行压缩成一行显示； -S：在单行显示较长的内容，而不换行显示； -x\u003c数字\u003e：将TAB字符显示为指定个数的空格字符。 -\u003c数字\u003e：指定每屏显示的行数； -d：显示“[press space to continue,‘q’ to quit.]”和“[Press ‘h’ for instructions]”； -c：不进行滚屏操作。每次刷新这个屏幕； -s：将多个空行压缩成一行显示； -u：禁止下划线； +\u003c数字\u003e：从指定数字的行开始显示。 按Space键：显示文本的下一屏内容。 按Enier键：只显示文本的下一行内容。 按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。 按H键：显示帮助屏，该屏上有相关的帮助信息。 按B键：显示上一屏内容。 按Q键：退出rnore命令。 –retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用； -c或——bytes=：输出文件尾部的N（N为整数）个字节内容； -f或；–follow：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效； -F：与选项“-follow=name”和“–retry\"连用时功能相同； -n或——line=：输出文件的尾部N（N位数字）行内容。 –pid=\u003c进程号\u003e：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令； -q或——quiet或——silent：当有多个文件参数时，不输出各个文件名； -s\u003c秒数\u003e或——sleep-interal=\u003c秒数\u003e：与“-f”选项连用，指定监视文件变化时间隔的秒数； -v或——verbose：当有多个文件参数时，总是输出各个文件名； 一般tail命令最常用的-n和-f，例： tail filename 读取filename最后10行内容 tail -f filename 实时动态读取filename最后10行内容 tail -20f filename 实时动态读取filename最后20行内容 \r\r cat和less及more指令相似，cat是一次性读取所有内容，文件内容较多时速度较慢。less与more的区别在于：less可以前后翻页查看，more只能向前翻页查看。 tail则用于实时获取log信息，从后向前读取内容 上述四种命令均可跟grep搭配使用cat/less/tail |grep mysql ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:3","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6.4 查看文件大小的命令 du/df 详细\r\rdu -sh * 显示当前目录下所有文件的大小 du -sh filename 显示该文件大小 du -sh 显示当前目录所占空间大小 -s或 仅显示总计，只列出最后加总的值。 -h或 以K，M，G为单位，提高信息的可读性。 df 显示磁盘占用信息 直接df默认一k为单位 df -lh 显示本地系统的占用信息，以K，M，G为单位\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:4","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6.5 大重点–文本编辑器 vi 详细\r\rvi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。 Linux中的vi编辑器叫vim，它是vi的增强版（vi Improved），与vi编辑器完全兼容，而且实现了很多增强功能。 vi编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用vi编辑器就必须熟练掌握着两种模式的切换。 默认情况下，打开vi编辑器后自动进入命令模式。从编辑模式切换到命令模式使用“esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。 vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下： Ctrl+u：向文件首翻半屏； 2 Ctrl+d：向文件尾翻半屏； 3 Ctrl+f：向文件尾翻一屏； 4 Ctrl+b：向文件首翻一屏； 5 Esc：从编辑模式切换到命令模式； 6 ZZ：命令模式下保存当前文件所做的修改后退出vi； 7 :行号：光标跳转到指定行的行首； 8 :$：光标跳转到最后一行的行首； 9 x或X：删除一个字符，x删除光标后的，而X删除光标前的； 10 D：删除从当前光标到光标所在行尾的全部字符； 11 dd：删除光标行正行内容； 12 ndd：删除当前行及其后n-1行； 13 nyy：将当前行及其下n行的内容保存到寄存器?中，其中？为一个字母，n为一个数字； 14 p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方； 15 P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方； 16 /字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示； 17 ？name：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示； 18 a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作； 19 a：在当前字符后添加文本； 20 A：在行末添加文本； 21 i：在当前字符前插入文本； 22 I：在行首插入文本； 23 o：在当前行后面插入一空行； 24 O：在当前行前面插入一空行； 25 :wq：在命令模式下，执行存盘退出操作； 26 :w：在命令模式下，执行存盘操作； 27 :w！：在命令模式下，执行强制存盘操作； 28 :q：在命令模式下，执行退出vi操作； 29 :q！：在命令模式下，执行强制退出vi操作； 30 :e文件名：在命令模式下，打开并编辑指定名称的文件； 31 :n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件； 32 :f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例； 33 :set nu：在命令模式下，用于在最左端显示行号； 34 :set nonu：在命令模式下，用于在最左端不显示行号； 35 :1,3y 复制第一行到第三行 36 :1,3d 删除第一行到第三行 37 :1,3s/str/str_new/g 替换第一行到第三行中的字符串 38 :1,3s/str/str_new 替换第一行到第三行中的字符串第一个字符 39 :1,3 g/str /d 删除第一行到第三行中含有这个字符串的行\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:5","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6.6 重定向 \u003e 输出重定向 who \u003e bbb.txt 将aaa的内容写入bbb中，覆盖写入 cat bbb.txt » ccc.txt 讲aaa的内容追加写入bbb中，不覆盖原来内容 \u003e bbb.txt 将bbb清空 输入重定向 grep 05:37:43.730 \u003c web.2019-07-22.0.log 大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。 一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。 同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 重定向深入理解 详细\r\r一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：  标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。  标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。  标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command \u003e file 将 stdout 重定向到 file，command \u003c file 将stdin 重定向到 file。\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:6","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6.7 查看服务 详细\r\rnetstat -nlpt|grep 80 查看该端口号是否被占用 free -m //查看LINUX内存剩余容量 ps可以查看具体的进程信息，一般与管道符连接其他命令使用，如：grep ps常用参数-ef/-aux，一般最常用还是-ef，例：ps -ef|grep mysql 查询mysql进程 top也可查看进程信息，而且是动态显示 whoami 查看当前登陆用户 who 查看多少用户在使用系统 date查看系统时间，可跟时间格式使用 cal查看日历，可跟年份，查看指定的年份 chkconfig –list #查看系统服务启动 chkconfig iptables on #开机启动该服务 chkconfig iptables off #开机不启动该服务 service iptables start #启动该服务 service iptables restart #重启启该服务 ps -ef|grep mysql|grep -v grep|awk ‘{print $2}‘ps -ef|grep mysql 是查询mysql服务的进程 |后的grep -v grep 是匹配不包含grep的行 awk是取查询结果的第几列，awk ‘{print $2}‘则是取第二列的值 grep 无参数则显示匹配的行 -c 显示匹配的行数 -v 显示不匹配的行\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:7","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6.8 杀掉进程 kill命令 详细\r\rkill最常用的参数是-9，用法：kill -9 进程号 即可强制杀掉该进程 统计命令 wc 常用的参数是 -l 用法：wc -l ，例： ps -ef|grep mysql|wc -l 统计查询出的mysql进程的行数 查找命令 find/locate/whereis/which find -name 后跟文件名，可查看文件所在目录，可跟user，查看属于user的文件 find -name filename 查找filename所在目录 find -name name* 查找开头为name的文件所在目录 find -name *name 查找结尾为name的文件所在目录 find -name *name* 查找包含name字符串的文件所在目录 find -user faith 查看用户faith的文件 locate用法与find基本相似，只是locate搜索速度较快些，locate一般系统不会自带，需要安装，可用yum安装 whereis只能搜索程序名 which则是只查询path中的环境变量\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:8","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6.9 压缩和解压命令 gzip/guzip zip/unzip tar 详细\r\rgzip和gunzip一般可用参数是-r，例: gzip test.txt　压缩文件 gzip -r test 压缩所有test下的子文件 gunzip test.gz 解压文件 zip和unzip可用参数较多，例： zip test 不跟参数直接使用 zip -r test 递归压缩test下所有文件 unzip test 不跟参数直接使用 unzip -n 解压时不覆盖已存在的文件 unzip -o 解压时覆盖已存在的文件 unzip -d 将文件解压到目录中去 tar使用的较为多些，用法也多，最常用的是zxcvf几个参数，例： -c 创建新文档，就是代表压缩的意思 -x 解压文档 -f 使用归档文件 -z 使用gzip解压 -v 详细输出模式 最为常用的使用方法： tar -zcvf test.tar test 将test压缩为test.tar并输出详细信息 tar -zxvf test.tar 将test.tar解压缩，并输出详细信息\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:9","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["linux"],"content":"6.10 定时任务 crontab 详细\r\rcrontab [-u user] 文件 crontab [-u user] {-r -e -l} 不加-u的话默认当前用户 －e：执行文字编辑器来设定时程表，内定的文字编辑器是vi。 －r：删除目前的时程表。 －l：列出目前的时程表。 crontab -e 就可以打开一个文件进行编辑 crontab文件的格式为“M H D m d cmd”，M为分钟1-59，H为小时1-24，D为天1-31，m为月1-12，d为周0-6（0为周日）。cmd代表要执行的程序，*代表每分钟都执行 * * * * * sh /opt/lampp/test.sh 表示每分钟执行一次test.sh这个脚本 */5 * * * * sh /opt/lampp/test.sh 表示每5分钟执行一次test.sh这个脚本 30 21 * * * /usr/local/apache/bin/apachectl restart 表示每晚的21:30重启apache\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/:6:10","tags":["linux","操作系统"],"title":"Linux基本常识","uri":"/posts/linux/linux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/"},{"categories":["文档"],"content":"常用的 ","date":"2020-11-18","objectID":"/posts/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/:1:0","tags":["工具","文档"],"title":"实用工具","uri":"/posts/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"categories":["文档"],"content":"密码管理器 keepass 1 Password Unikey / 密码保 —\u003e 没用过 LastPass —\u003e 没用过 ","date":"2020-11-18","objectID":"/posts/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/:1:1","tags":["工具","文档"],"title":"实用工具","uri":"/posts/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"categories":["文档"],"content":"谷歌浏览器插件 Video DownloadHelper 一款视频下载插件，网页上能看的视频几乎都可以捕捉下载 GitHub加速 国内Github下载很慢，用上了这个插件后，下载速度嗖嗖嗖的 谷歌访问助手 见名知意、有了它，谷歌可以访问了，虽然依旧龟速 沙拉查词-聚合词典划词翻译 多语言混合网页阅读利器 ","date":"2020-11-18","objectID":"/posts/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/:1:2","tags":["工具","文档"],"title":"实用工具","uri":"/posts/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"categories":["文档"],"content":"Redis客户端工具 Another Redis Desktop Manager 开源软件，用着还可以 Redis Desktop Manager 官方工具，新版部分功能收费 未完待续… ","date":"2020-11-18","objectID":"/posts/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/:1:3","tags":["工具","文档"],"title":"实用工具","uri":"/posts/docs/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"categories":["文档"],"content":"Markdown在线编辑器 JSON解析 程序员在线工具箱 程序员在线工具箱2 未完待续… ","date":"2020-11-18","objectID":"/posts/docs/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:0:0","tags":["工具","文档"],"title":"在线工具","uri":"/posts/docs/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["文档"],"content":"技术相关 Markdown中文网 清华大学开源软件镜像站 w3cschool github HBuilder Data Structure Visualizations visualgo OSCHINA-中国开源技术交流社区 阿里云云效Maven Maven中央仓库 SpringBoot官方文档 Nacos官网 菜鸟教程 jekyll主题 jekyll中文文档 jekyll英文文档 Hugo官网 Hugo英文文档 Hugo中文文档 图标网 阿里巴巴矢量图标库 Markdown 中文网 LeanCloud valine文档 ","date":"2020-11-18","objectID":"/posts/docs/%E5%B8%B8%E8%A7%81%E5%AE%98%E7%BD%91/:1:0","tags":["官网","文档"],"title":"常见官网","uri":"/posts/docs/%E5%B8%B8%E8%A7%81%E5%AE%98%E7%BD%91/"},{"categories":["文档"],"content":"其他 keepass ","date":"2020-11-18","objectID":"/posts/docs/%E5%B8%B8%E8%A7%81%E5%AE%98%E7%BD%91/:2:0","tags":["官网","文档"],"title":"常见官网","uri":"/posts/docs/%E5%B8%B8%E8%A7%81%E5%AE%98%E7%BD%91/"},{"categories":null,"content":"关于我 一个平凡的编码者、程序员。 极简主义。 喜欢玩游戏 （曾经 S5 LOL网一钻二、16年后基本不玩了）。 热爱技术，喜欢瞎倒腾。生命不息、折腾不止 （例如这个博客）。 现居于上海。 ","date":"2020-11-16","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于博客 始建于2020年11月14日，用过jekyll。 目前使用hugo 、 阿里云OSS 、 阿里云ECS 自动部署使用GitHub-WebHooks + 自写脚本 ⭐ 暗夜零星 ⭐ ","date":"2020-11-16","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["前端"],"content":"初学 JavaScript 要掌握的知识有哪些呢？ ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:0:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"1.表达式和语句 表达式： 一个式子，它具有表达某些信息的能力。比如1+2表达式的值为 3。需要注意的地方，console.log表达式的值为函数本身，但是console.log(1)表达式的值为 undefined，只是在控制台中显示的内容为 1。 语句： 描述一段内容的句子。比如var a = 1 它们两者的区别在于： 表达式一般都有值，语句可能有也可能没有。 语句一般会改变环境，比如声明或者赋值。 但这些都不绝对，特殊情况特殊看待。 ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:1:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"2. 标识符的规则 在对变量名等标识符命名的时候并非随心所欲随便命名的，要遵守一定的约定规则。首先 JavaScript 是对大小写敏感的，a和A会被严格区分，所以有时候在函数命名上要小心避免上下文名称不同造成的意外错误。 标识符第一个字符命名规则： 不能是数字； 可以是 Unicode 字符或$、_和中文； 标识符第二个及以后的字符命名规则： 可以为任意字符； 注：标识符的命名要好认、好记通俗易懂。不要写很多个_或是使用.这种比较特殊的字符。标识符要写时好写，后面 review 时要好懂才行。 ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:2:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"3.条件判断语句 “if…else…\" 是常用条件判断语句 // 伪代码 if(表达式){ 语句1 ... }else { 语句2 ... } 在 if 的块中的语句如果只有一句，则可以省略外面的花括号，只写这条语句，但是不推荐这么做，这样会容易造成阅读时看错代码流程。在 if…else 代码块中还可以继续继续嵌套 if…else 代码块来处理复杂的条件判断逻辑。 // 伪代码 if(表达式){ if(表达式){ 语句1 ... }else{ 语句2 ... } 语句3 ... }else { 语句4 ... } 多个条件判断可以使用if...else if ... else语法 if(表达式){ 语句1 ... }else if(表达式){ 语句2 ... }else { 语句3 ... } 有时候条件判断并不多的时候没必要使用 if…else，可以使用 \u0026\u0026来简化条件判断的代码。 例如有这些需求：一个函数 a 的参数接收一个函数并在这个 a 函数体内调用传入的函数，为了确保调用时不会发生错误，我们通常可以这样写代码。 function a(fn){ fn \u0026\u0026 fn() } // fn \u0026\u0026 fn() 等同于 if(fn) fn() 另外一个短路运算符||则可以用来进行一些保底赋值操作。 a = a || 100 // 等同于 if(!a) a = 100 ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:3:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"4.循环 循环操作可以使用while或者for,while 是表达式内的值为真时则执行块内语句。for语法可以看做是 while 的一个语法糖，因为我们在使用 while 是需要在 while 外部确定循环初始值，表达式内要有循环退出条件，循环体内有执行语句。但是这些都可以简化一下，现在我们来看看使用 for 如何做循环： for (var i = 0; i \u003c 5; i++) { console.log(i) } 延伸：由于变量提升，在 for 的代码块内使用定时器函数 setTimeout()函数时，会由于 var 定义的 i 变量从而使通过定时器函数输出的值为 i 循环完后最后的值。如果需要避免这种情况的发生，在声明并定义 i 时要使用let关键字去声明变量，这样就可以将变量 i 的作用域限定在当前的 for 代码块内。 ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:4:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"5、break、continue 有时候我们并不想让循环完全执行，希望循环在执行带某个条件时可以跳出循环，此时可以使用到 break 和 continue 了。 break：跳出本层循环 continue：跳过本次循环 在有两层循环的时候，在内部的第二层循环体内使用 break 可以跳出这层循环，但是不影响外部循环的执行。 for (let i = 0; i \u003c 5; i++) { for (let j = 0; j \u003c 5; j++) { if (j \u003e 2) // 只跳出变量为 j 的这层循环 break } console.log(i) } ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:5:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"6.label 语句 用的很少，仅做了解。 { a:1 } 以上代码乍看还会以为是一个对象，但其实是一个 label，它是一个正常代码块内包含一些内容（上面的代码在 Chrome 中使用需要在a:1后面加上;，否则会被 Chrome 修改成一个对象）。有时候面试会问上面这个代码是什么，所以要了解一下。 label 语法： foo: { console.log(1); break foo; console.log('这行不会输出!') } console.log(2) 这种写法其实就是标记某个代码块，从而通过 continue、break 等影响代码执行流程。` ","date":"2020-06-01","objectID":"/posts/web/javascript%E5%88%9D%E8%AF%86/:6:0","tags":["JavaScript","入门"],"title":"JavaScript初识","uri":"/posts/web/javascript%E5%88%9D%E8%AF%86/"},{"categories":["HTTP"],"content":"URL 概述 URL（Uniform Resource Locator） 指的是统一资源定位符。URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个独特的资源。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等。 ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:0:0","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"1.URL 一个 URL 一般包含这些内容： 协议：http/https/ftp/mailto 等。http:// 是协议,它表明了浏览器必须使用何种协议； 端口：用于确认访问时系统提供什么样的服务，比如 http 端口是 80，https 为 443。0-1023 是留给系统使用的，自己使用时不要随意占用这些端口，除了这些端口一般我们都可以随意使用，但是诸多软件有默认的端口占用，比如 mysql 会占用 3306 端口，所以使用端口时还要小心占用到别的软件的端口。想了解软件的端口使用情况，看TCP/UDP 常见端口； 域名：例如\"www.baidu.com\"。它表明正在请求哪个 Web 服务器，或者可以直接使用 ip 地址，但是这并不好记忆。另外，一个域名可以对应多个 ip 地址； 资源请求路径：例如/path/index.html； 请求参数：请求时携带的额外参数信息，这些参数是用 \u0026 符号分隔的键/值对列表。例如：\"?key1=value1\u0026key2=value2\"; 锚点信息：锚点表示资源中的一种“书签”，通过锚点，可以跳到其所在位置，比如文章开头的目录信息，点击后即可跳到当前页面的某个内容处，这就是利用了锚点原理。锚点在地址栏上是以'#‘后面的内容确定的，需要注意的是，锚点内容并被发送到服务器，它属于浏览器本地处理的内容。 ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:1:0","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"2.DNS DNS（Domain Name System）：域名系统。为什么要有域名系统？我们可以想象一下，如果在访问互联网资源时，都是通过记录 ip 来访问的话，这个记忆难度有多大，而且还难以书写。比如访问百度时在浏览器地址栏输入\"183.232.231.172\"，这太繁琐了。于是有了域名系统，在域名服务商那里我们可以购买一个域名，并将域名解析到服务器外网 ip 地址，这样就可以通过域名来访问自己的服务器了。而且域名是可以绑定多个 ip 地址的，这样可以实现在不同地域的人们访问域名地址时连接到最近的服务器。比如腾讯设立华东、西南、华北等服务器，这样在访问时电信服务商通过域名解析将最近的服务器资源返回，提升我们的上网体验。 使用控制台的’nslookup’命令可以知道域名对应的服务器 ip 地址。例：nslookup www.baidu.com ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:2:0","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"3.IP ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:3:0","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"IP 的作用是什么，ping 命令怎么用？ ip（Internet Protocol）：网络协议。ip 的作用相当于一个拥有详细地址的门牌号，通过这个门牌号可以找到具体的某户人家。而在网络上需要访问某个站点的某个服务器资源就需要通过 ip 去唯一标识。我们在访问某个地址时可以通过控制台的ping命令去查看是否可以和这个 ip 地址连接。如果可以则能获取到服务器返回的信息。 ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:3:1","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"4.域名 ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:4:0","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["HTTP"],"content":"域名是什么，分别哪几类域名？ 域名是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识。由于 IP 地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（DNS，Domain Name System）来将域名和 IP 地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 地址数串。 域名由一或多个部分组成，这些部分通常连接在一起，并由点分隔。最右边的一个标签是顶级域名。例如 zh.example.com,顶级域名为.com，一个域名的层次结构，从右侧到左侧隔一个点依次下降一层。 域名一般分为顶级域名、子域名（二级域名）、三级域名。比如.com是顶级域名，example.com是二级域名，www.example.com是三级域名。这里二级和三级域名是父子关系，但并不是说它们就一定是同一家公司的关系。example.com和www.example.com可以是同一家公司，也可以是不同公司的域名。 了解协议、端口、DNS、IP、域名的相关内容，就可以初略知道浏览器地址栏上的内容到底是怎么回事了。 ","date":"2020-05-06","objectID":"/posts/web/%E6%B5%85%E6%9E%90url/:4:1","tags":["HTTP","入门"],"title":"浅析URL","uri":"/posts/web/%E6%B5%85%E6%9E%90url/"},{"categories":["前端"],"content":"1、浏览器渲染原理 浏览器到底是怎么将一个 html 文件渲染成生动的页面的？话不多说，直接看图 以图中的过程，浏览器的渲染过程大致就是： 通过 HTML 解析将 HTML 文件解析为 DOM 树; 通过 CSS 解析将 CSS 文件解析出样式规则（CSSOM 树）； 通过合并 DOM 树和 CSSOM 树将生成渲染树； 依赖渲染树开始布局（文档流、盒模型、确定位置和尺寸计算）； 知道了哪些节点可见、它们的计算样式以及几何信息，将渲染树中的每个节点转换成屏幕上的实际像素即开始绘制。把边框、文字颜色、阴影等绘制出来。 最后将合成好的页面展示出来。 延伸： 层叠样式的由来 还是先看图： 为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式）这种行为被称作为“样式继承”，那么为了不想要继承过来的样式，那么就需要自己单独写样式来覆盖原来的样式，即层叠。而不同的浏览器提供了不同的默认样式（“User Agent 样式”），这让我们一套代码却产生了五花八门的样式，这不符合设计需求。所以又通常要编写一个全局样式（reset.css / normalize.css）来清除默认样式，让代码在不同浏览器上产生一致的效果。 “display：none\"的元素是否会被渲染？ 答案是否。 同为显示和隐藏的一个属性是\"visibility”,visibility: hidden 与 display: none 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (display: none) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。 回流和重绘 回流(reflow)： 回流或称为 layout 重排。当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染。reflow 会从这个 html 的根节点开始往下递归，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击等只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 重绘(repaint)： 改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。 每次 Reflow，Repaint 后浏览器还需要合并渲染层并输出到屏幕上。所有的这些都会是动画卡顿的原因。 Reflow 的成本比 Repaint 的成本高得多的多。一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。可以在 csstrigger 上查找某个 css 属性会触发什么事件。 reflow 与 repaint 的时机： display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。 有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。 有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。 下面看谷歌开发者网站上的一张图 如果更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。 这个最后的版本开销最小，最适合于应用生命周期中的高压力点，例如动画或滚动。 继续深入将涉及到浏览器渲染优化，这里不再做展开。想知道哪些 CSS 属性会触发上面 3 中中的哪一个，可以查看这个网站CSS 触发器。 使用不同的方式改变元素状态的最终显示过程是什么样的呢？ 使用 js 调整元素位置 =\u003e 触发上图中的 Layout+Paing+Composite 使用 CSS 调整元素背景色 =\u003e 触发上图 Paint 和 Composite 使用 transform 调整元素位置 =\u003e 触发上图 Composite 是否发现使用 transform 调整元素竟然只触发了 Composite，比 js 少了两个步骤。很明显，使用 transform 可以提高页面渲染性能，而且用它还可以制作动画，下面来看看动画该怎么做吧。 ","date":"2020-05-02","objectID":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/:1:0","tags":["css","入门"],"title":"初识渲染原理和CSS动画","uri":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/"},{"categories":["前端"],"content":"2、CSS 动画的两种做法（transition 和 animation） 说动画前先深入了解一下\"transform\"属性。一般常用来给元素改变位置（translate），旋转（rotate），缩放（scale）。如果还需要对元素设置 3d 样式的话，就要给被设置元素的父级元素或者直接给 body 设置 perspective 属性。 要给元素进行变换前，还要清楚一个知识点-坐标系。我们浏览器以及盒模型的坐标原点都为左上角 当元素发生旋转时这个坐标轴的朝向也将发生改变。注意这一点，有时候就是没考虑好坐标轴的问题造成了布局错乱。 了解了坐标系，使用\"transform:translate\"的时候就更得心应手了。 transition： 使用 transform 是将元素从上一个状态转变为 transform 后的状态，直接设置这个属性后我们在浏览器中看到的就是 transform 后的元素了，为了让元素在发生变化时有一个过渡的效果，此时就可以用上\"transition\"啦，配合上\":hover\"等伪类选择器就可以实现简单的一次性动画效果啦。了解更多关于 transition 的内容可以看MDN transition animation： transition 只能制作一次性的动画，想要制作类似这样效果的动画怎么办呢？ 使用animation配合上\"@keyframes name{}“就可以实现了。属性使用没什么技巧，就是多练。详情看MDN @keyframes 。知道了 keyframes 怎么写了，那 animation 又该写到哪里呢？和 transition 一样，将这个属性写到要被实现动画元素的本身上！ 说不如做，动手做一个跳动的心吧，源码跳动的心 ","date":"2020-05-02","objectID":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/:2:0","tags":["css","入门"],"title":"初识渲染原理和CSS动画","uri":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/"},{"categories":["前端"],"content":"transform 总结： inline 元素不支持 transform，需要先转变为 block； translate(-50%,-50%)可做绝对定位元素的居中； scale 会造成模糊或边界变粗，酌情使用； 属性组合用：transform:scale(1.5) translate(-100%,-100%) 善用搜索引擎，不明白就看 MDN； 上述内容参考 MDN 以及谷歌 web 相关文档。 googleDevelopers-渲染性能 https://developers.google.com/web/fundamentals/performance/rendering googleDevelopers-关键渲染路径 https://developers.google.com/web/fundamentals/performance/critical-rendering-path ","date":"2020-05-02","objectID":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/:2:1","tags":["css","入门"],"title":"初识渲染原理和CSS动画","uri":"/posts/web/%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%92%8Ccss%E5%8A%A8%E7%94%BB/"},{"categories":["前端"],"content":"float布局 ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:1:0","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"常见问题 原理：在父盒子浮动元素的最后加上一个盒子，并给这个盒子设置属性\"clear:both\"，这样就可以实现最基础的清除浮动了。 但是这样有个缺点，就是总要去手动增加一个html元素，然后为这个元素设置css样式，太麻烦。什么方式可以避免呢？那就是使用css伪元素。对css伪元素不太了解的话，可以看这里。 使用伪元素的方式清除浮动，则只需要为浮动盒子的父盒子添加一个类样式。类样式代码如下： /* 不兼容ie低版本 */ .clearfix { content:\"\"; display:block; clear:both; } /* 兼容ie低版本 */ /* after伪元素清除法 */ .clearfix:after { content: \"\"; display: block; height: 0; clear: both; visibility: hidden; } .clearfix: { *zoom: 1; /*为i6/i7老式浏览器准备*/ } /* 双伪元素清除法 */ .clearfix:before, .clearfix:after { content: \"\"; display: table; } .clearfix:after { clear: both; } .clearfix: { *zoom: 1; /*为i6/i7老式浏览器准备*/ } 2. 图片logo与底部边框有间隙 给img标签添设置属性\"vertical-align: middle;“值可以是这个属性的其他值。 3. 边框影响了布局 将border属性改为使用outline属性。同样都可以显示边框，但outline不影响布局。 4. 块元素居中显示 在pc上布局时，有时候要对一个固定宽度的块元素设置居中显示，可以使用\"margin:0 auto;“的方式，但是这并不好，因为假如这个要居中显示的元素就需要一个上外边距，那么使用\"margin:0 auto;“会破坏布局。比较好的方式是为元素设置以下两种属性： .centerbox { margin-left:auto; margin-right:auto; } 注：在css中，非特殊情况，布局时的属性设置最好是只影响到被设置的元素本身，不要让代码影响到其他的布局结果。即改写的代码不要少，但不该写的一定不要多。 5.平均布局时会用到的小技巧 如图，遇到需要对黑盒子内橙色盒子平均布局时，因为我们需要设置\"margin-right:xxpx;“会遇到最后一个盒子被挤下去的情况。这是由于每个盒子都\"margin-right\"使得最后一个橙色盒子装不下了。此时只需在这些需要被平均布局的盒子外再嵌套一个看不见的蓝色盒子，并给它设置一个最后一个橙色盒子所需的\"margin-right\"大小值就可以实现正常布局了，即图中蓝色盒子超过部分大小。这种布局方式称为负margin。 ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:1:1","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"flex布局 ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:2:0","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"常用属性 属性 设置位置 描述 display:flex 父元素 将布局设置为flex布局 flex-direction:row(默认)/column 父元素 设置主轴方向 flex-wrap:wrap/nowrap(默认) 父元素 设置子元素是否换行 justify-content:center / space-between 父元素 子元素在主轴上的显示方式 align-items:center 父元素 设置子元素在侧轴上的显示方式 了解详细的flex，看这里 ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:2:1","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"注意的点 尽量不要把宽高写死。即不要直接设置为固定px单位的值。可以使用\"百分比”，“vw”，“vh”、或者设置\"max-width/min-width”。 平均布局时适用上述float中的技巧。 flex和margin-xxx:auto;配合会有意外效果。 ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:2:2","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":"grid布局 grid布局是未来的发展趋势，它简单、强大、易懂。 学习grid布局 通过一个游戏练习使用grid ","date":"2020-05-01","objectID":"/posts/web/css%E5%B8%83%E5%B1%80/:3:0","tags":["css","入门"],"title":"CSS布局","uri":"/posts/web/css%E5%B8%83%E5%B1%80/"},{"categories":["前端"],"content":" 标签 常用属性 作用 a href \\ target 1、跳转外部页面；2、跳转内部锚点；3、跳转到邮箱或电话 img src \\ alt \\ width \\ height 发出 get 请求，展示一张图片 form action \\ method 表单。发送 get 或 post 请求，然后刷新页面 input type [ “text” , “password” , “file”，“submit”，“hidden\"等 ] \\ checked \\ value \\ disabled \\ name 让用户输入内容。通过 type 确定不同的 input 内容，通常搭配 form 使用 table - 表格。使用相对较少 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:0:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"1. a 标签 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ href ] [href]可设置以下内容的值： 网址 https://untilthecore.github.io/ http://untilthecore.github.io/ //untilthecore.github.io/ (推荐用这种，它会自动寻找 https 或者 http 协议的网址) 路径 - 绝对路径：/a/b/c （以地址栏地址为基准寻找） - 相对路径：a/b/c 、 ./a/b/c (以当前文件为基准寻找) 伪协议 - \"javascript:代码;\"：代码部分可以写代码，这样点击会产生对应代码的效果。或者什么都不写，就是单纯的\"javascript:;\"，这样可以阻止 a 标签的默认跳转行为。 ； - \"mailto:邮箱地址\"：值为这个，点击时会调用默认邮件程序，可以发送邮件到填写的邮箱地址； - \"tel:手机号\"：值为这个，如果是手机端会调用手机默认拨号程序并准备拨向填写的手机号； id 锚点。如果 a 标签的 href 属性值为某个元素的 id 值，点击时会跳到这个元素的位置。举个例子： \u003c!-- 忽略HTML骨架 --\u003e \u003c!-- 假如有一个元素p，且 id 为 aaa --\u003e \u003cp id=\"aaa\"\u003e\u003c/p\u003e \u003c!-- 假如有一个 a 标签，它的 href=\"#aaa\",且这个 a 标签离 上述 p 间隔100个p标签的距离 --\u003e \u003ca href=\"#aaa\"\u003e跳向aaa\u003c/a\u003e 注：href 可以不设置值，但是点击时会造成页面刷新，有可能有的小伙伴认为可以填写上\"#\"来避免刷新，但是使用这种方式虽然不刷新，但是如果页面很高，而且这个 a 标签在很下面，会导致页面回到顶部。为了既防止页面刷新又防止回到页面顶部，可以使用\"javascript:;\" ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:1","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ target ] \"[target]\"可以设置以下内容的值： “_blank”：打开链接到一个新的浏览器标签页上。 “self”：默认值。打开链接在当前页面上。 “_top”：打开链接到最顶级的页面，通常和 iframe 使用。不过 iframe 不怎么用了，仅做了解。 “parent”：打开链接到父级页面，通常和 iframe 使用。比如 html \u003e iframe a \u003e iframe b，iframe b 中 a 的 target 设置为 parent，那么打开链接时会在 iframe a 中打开。同上，仅做了解。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:2","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"2. img 标签 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ src ] \"[src]\"值为图片的地址，可以使网上图片的超链接，也可以是本地的图片路径。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:1","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ alt ] \"[alt]\"的值为一段关于图片的描述，在图片加载失败或者网速过慢还没有加载出来时显示给用户看的内容。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:2","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ width \\ height ] \"[width] 和 [height]\"：设置图片的宽和高。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:3","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件[ onload ] \"[onload]\"：在图片加载完成后触发的事件 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:4","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件[ onerror] \"[onerror]\"：在图片加载失败后触发的事件。应用场景：比如用户访问某个图片失败了，通过这个事件可以替换 img 的 src 为一张默认图给用户看，用来保证一些用户体验性。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:5","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"响应式 \"[max-width]\"：为了保持图片在不同设备上显示效果一致，可以在 css 中设置 img 的max-width \u003cstyle\u003e img { max-width: 100%; } \u003c/style\u003e 而为什么要使用\"max-width\"而不是\"width\"呢？最重要的概念是保证图片不被拉伸，使用\"max-width\"可以保证图片小于屏幕宽度的时候不被拉伸到和屏幕一样宽，只到自己图片大小，从而避免造成看起来非常马赛克。如果还是不太明白可以写代码来帮助理解。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:6","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"3.form 标签 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ action ] \"[action]\"：一个处理此表单信息的程序所在的 URL。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:1","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ method ] \"[method ]\"：表单的提交方式，值有： post：表单数据会包含在表单体内然后发送给服务器。 get：表单数据会附加在 action 属性的 URI 中，并以 ‘?’ 作为分隔符，然后这样得到的 URI 再发送给服务器。如果要发送用户的账号密码等个人信息，请使用 post 方式。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:2","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件 [onsubmit] 表单提交时会触发 onsubmit 事件，有时候不想要表单默认的提交行为，我们可以给表单添加 id 然后通过 js 捕获 submit 事件并在事件处理函数中 return false 来阻止默认提交行为。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:3","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"4.input 标签 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ type ] \"[input]\"的 type 属性不同值可以产生各式各样的 input 内容，比如单选框 radio 、复选框 checkbox、颜色选择面板 color 等，大多数的类型值都是比较好理解的，但是这个 \"hidden\" 是个什么意思且具体用法是什么对于初学者来说有点懵。 为什么要有一个 type 属性值是\"hidden\"呢？这是因为有时候用户查询得到的数据返回时在地址栏上，而且这次查询得到的数据还要继续用来下一次查询，这时总不可能让用户自己去复制粘贴地址栏上的参数数据吧？所以为了避免这种情况，就需要\"hidden\"上场了。我们可以在需要用来保存上一次查询结果的地方增加一个\u003cinput type=\"hidden\" value=\"\"\u003e在我们得到返回结果后通过 js 将结果设置到这个 input 的 value 上，这样在我们下一次需要的时候就可以直接通过 value 去取到这个值了。 这种操作表单的方式被称作：隐藏域 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:1","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ name ] \"[name]\"属性作用有这些： 给 radio 和 checkbox 归类； 表单提交时传给后台的表单项的名字，它与属性 \"value\"组成键值对发送到后端，\"name\"是键。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:2","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"属性[ value ] \"[value]\"属性与\"name\"属性组成键值对发送到后端，value是值。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:3","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件[ onchange ] \"[onchange]\"：input 内容发生改变时触发的事件，比如类型为 text 的 input 有输入产生、类型为 select 的 input 选中了某个选项等。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:4","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件[ onfocus] \"[onfocus]\"：input 产生焦点时触发的事件。比如有一个类型为 text 的 input，我们鼠标点击了这个 input 时产生\"onfocus\"事件。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:5","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"事件[ onblur ] \"[onblur ]\"：input 失去焦点时触发的事件。比如一个类型为 text 的 input，内容输入完成后鼠标点击了非这个 input 区域时产生\"onblur\"事件。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:6","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"5.table 标签 \"[table]\"内容比较简单，主要就是练习一个熟练度。table 本身用的地方不是很多，但可以用来进行一些比较特殊表格布局。 使用table注意的点： 使用 css 设置border-collapse:collapse和border-spacing: 0，这样可以清除表格默认样式，使表格更好看。 不要在标签上设置表格样式，请在 css 中设置 table 的样式，这是官方说的。 ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:5:0","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"熟能生巧 一个简单表格的练习 打不开就看这里吧： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e th, td { border: 1px solid #ccc; text-align: center; } table { width: 300px; /* 设置单元格距离和单元格边框合并 */ border-collapse: collapse; border-spacing: 0; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003e价格\u003c/th\u003e \u003cth\u003e分类\u003c/th\u003e \u003cth\u003e日期\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003cth\u003e商品1\u003c/th\u003e \u003ctd\u003e100\u003c/td\u003e \u003ctd\u003e分类1\u003c/td\u003e \u003ctd\u003e2020-4-29\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e商品2\u003c/th\u003e \u003ctd\u003e100\u003c/td\u003e \u003ctd\u003e分类2\u003c/td\u003e \u003ctd\u003e2020-4-29\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e商品3\u003c/th\u003e \u003ctd\u003e100\u003c/td\u003e \u003ctd\u003e分类3\u003c/td\u003e \u003ctd\u003e2020-4-29\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003ctfoot\u003e \u003ctr\u003e \u003cth\u003e价格总计\u003c/th\u003e \u003c!-- colspan 让这一列占 3 列的宽度 --\u003e \u003ctd colspan=\"3\"\u003e300\u003c/td\u003e \u003c/tr\u003e \u003c/tfoot\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e 学习使人充盈，分享使人进步！ 此文为 UntilTheCore 原创，转载请说明作者和出处！ ","date":"2020-04-29","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:5:1","tags":["HTML","入门"],"title":"HTML入门之HTML常用标签","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E4%B9%8Bhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"1.HTML 是怎么产生的？ Tim Berners-Lee – 万维网的创建者 探寻互联网的初始，那么就必然要了解一下李老爷子本人，这位牛人为如今精彩纷呈的互联网世界打下了坚实的地基。1989 年他开发了世上第一个浏览器和第一个服务器，由此种下了互联网世界的种子，而且他发明的 WWW、URL、HTTP 一直延续至今。 那这个东西到底是怎么产生的呢？1、因为一杯咖啡，这让我联想到了 java；2、为了可以上网冲浪； ","date":"2020-04-28","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:1:0","tags":["HTML","入门"],"title":"HTML入门笔记1","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"categories":["前端"],"content":"2.HTML 怎么快速开始 现代的编辑器配合 Emmet 语法可以快速创建一个 HTML 的骨架，虽然这节省了我们书写骨架代码的时间，但还是有必要了解一下这些内容是什么。 在 vscode 中创建一个 HTML 的文件，使用 Emmet 语法输入! + tab键即可快速生成 html 骨架。 ","date":"2020-04-28","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:2:0","tags":["HTML","入门"],"title":"HTML入门笔记1","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"categories":["前端"],"content":"3.HTML 常用的章节标签有哪些？ 章节标签 介绍 h1~h6 文章内容标题 section 相对于 article 元素更加广泛，每个区块都可以使用，比如页面里的导航菜单、文章正文、文章的评论等。 article 代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客、一篇帖子、一段用户评论 p 段落 header 头部 footer 页脚 main 主要内容。内容主体区域，放在在 header 和 footer 中间 aside 旁支内容 div 划分 ","date":"2020-04-28","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:3:0","tags":["HTML","入门"],"title":"HTML入门笔记1","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"categories":["前端"],"content":"4.HTML 常用的内容标签有哪些？ 内容标签 介绍 ol + li ordered list + list item。无序列表 ul + li unordered list + list item。有序列表 dl+ dd + dt description list + term + data。自定义列表 pre 被 pre 包裹的内容以原始内容输出。比如内容有多个空格以及换行都正常显示 hr 分隔线 br 换行 a 超链接标签 em 语气上强调 strong 表示内容重要 code 内容字体等宽。一般包裹代码块 quote 引用。行内引用 blockquote 块级引用。被包裹的内容与上一行内容有一个缩进 ","date":"2020-04-28","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:4:0","tags":["HTML","入门"],"title":"HTML入门笔记1","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"categories":["前端"],"content":"5.HTML 的全局属性有哪些？ 全局属性即所有标签都会有的属性。 全局属性 介绍 class 类。给元素取一个类名，一般配合 css 设置样式 id 全局唯一 id，一般配合 js 使用，但是由于多处使用了浏览器也不报错，所以慎用 style 内联样式 title 鼠标移到标签上会在鼠标旁显示 title 的值 hidden 控制标签的隐藏 tabindex 如果元素需要被键盘 tab 键选中，可以设置值。值 \u003c 0，表示不被 tab 选中；值 == 0，表示最后被选中；值 \u003e 0 表示按值大小顺序选中 contenteditable 使标签可被直接编辑。想要更直观看到这个属性的效果可以点击这里修改样式试试看，或者复制下面的代码运行一下。 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width\" /\u003e \u003ctitle\u003eJS Bin\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 将style放入body并设置display为block再开启元素可编辑即可在网页上编辑页面样式 --\u003e \u003cstyle style=\"display:block;\" contenteditable\u003e header { background-color: pink; } \u003c/style\u003e \u003cheader\u003e我是头部\u003c/header\u003e \u003csection contenteditable\u003e我是章节\u003c/section\u003e \u003cfooter\u003e我是页脚\u003c/footer\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-28","objectID":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:5:0","tags":["HTML","入门"],"title":"HTML入门笔记1","uri":"/posts/web/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"},{"categories":["前端"],"content":"在《如何用hugo搭建个人博客中》已经介绍了简单的主题引入办法，这里就不再赘述了。 现在我们来讲讲如何配置我们下载的新主题！（内容可能不多不全，Hugo的使用还在摸索阶段） 下载主题前要先看主题的Demo，看是否是自己想要的。没有Demo示例给看那就clone下来后跑起来看看是不是中意的，但是有的clone到的主题有可能较精简，怎么办呢？往下看。 选好中意的主题了，那么就一定要看作者的配置介绍，这个配置介绍一般都是介绍如何配置config.toml，但这个介绍可能不够全，那么就要自己看clone下来的主题中这个文件夹exampleSite中的config.toml。有的主题还有full-config.toml,这个内容更全面。以我使用的主题为例，路径结构为：themes\\hello-friend-ng\\exampleSite\\config.toml 接下来我将以我使用的主题为例，介绍config.toml配置内容 [[menu.main]] identifier = \"blog\" name = \"Blogs\" url = \"/posts\" [[menu.main]] name = \"Categories\" identifier = \"categories\" url = \"/categories/\" [[menu.main]] identifier = \"tags\" name = \"Tags\" url = \"/tags/\" [[menu.main]] identifier = \"about\" name = \"About\" url = \"about/\" 有[[menu.main]]即配置导航菜单，对应的地方如图： [[params.social]] name = \"email\" url = \"mailto:untilthecore@gmail.com\" [[params.social]] name = \"github\" url = \"https://github.com/UntilTheCore\" 有[[params.social]]即配置图标链接，对应地方如图： baseurl = \"https://untilthecore.github.io/\" title = \"My Blog\" languageCode = \"zh-Hans\" theme = \"hello-friend-ng\" baseurl：配置站点基址，如果要放在github上或者自己的云服务器上，请正确配置地址，否则出了能访问主页，其他地方都是 404 title：设置标题 languageCode：设置语言 theme：设置主题 其他的小地方的配置有注释，配合本地服务器可以方面查看修改后的效果。 第一次使用时，可能会好奇我们的 .md 文件是怎么产生标签（Tags）和分类（Categories）的？这就是通过使用hugo new posts/xxxxxx.md创建博客文件时，hugo自动为我们在文件头部生成了这些内容： title: \"正确使用hugo主题的姿势\" date: 2020-04-27T22:28:15+08:00 draft: false tags: [\"Hugo\"] categories: [\"教程\"] title：文章标题； data：文章被创建的事件 draft：是否草稿内容，如果为true，将不显示在博客站点中。 tags：为这篇文章创建标签，是数组形式[\"1\",\"2\",\"3\"] categories：为这篇文章创建分类，是数组形式[\"1\",\"2\",\"3\"] 由于在文章这里设置了tags和categories,所以我们可以在导航菜单中看到标签和文章分类信息。 在.md文件中，还可以设置更多其他的内容，比如设置版权信息等。有需要的话可以自行了解，我的经验就是多下几个主题，看看这些作者是怎么配置的。如果你有更多更好的信息，欢迎来信告诉我 创建博客后如何配置主题的基础内容介绍完毕，配置好这些就可以愉快地写博客啦！如果想配置更多更强大的内容，可以多多翻看Hugo官方文档。 写博客时要注意的点： 可能在posts中使用MarkDown插入图片时好好的，但是上传到github上后图片就不显示了呢？这是由于我们写文章时是在站点生成器的环境中，而上传的代码是在public中，为了保证上传后依然能正确显示，我使用的技巧是在public文件夹中新建一个static的文件夹用来保存我们文章的图片，且每一文章有对应的文件夹去保存图片，如图： 鉴于此，我们在posts/下写文章时使用的图片地址要以public/posts/文章标题/index.html为基准来找到public\\static目录。一段示例： ../../static/正确使用hugo主题的姿势/文章图片的保存方式.jpg\r 文章有误或不足之处，欢迎指正！谢谢！ ","date":"2020-04-27","objectID":"/posts/web/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hugo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A7%BF%E5%8A%BF/:0:0","tags":["Hugo"],"title":"正确使用hugo主题的姿势","uri":"/posts/web/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hugo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A7%BF%E5%8A%BF/"},{"categories":["前端"],"content":"本文由UntilTheCore原创，转载请说明作者和出处！ ","date":"2020-04-27","objectID":"/posts/web/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hugo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A7%BF%E5%8A%BF/:0:1","tags":["Hugo"],"title":"正确使用hugo主题的姿势","uri":"/posts/web/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8hugo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A7%BF%E5%8A%BF/"},{"categories":["前端"],"content":"阅读前你需要了解这些内容： git MarkDown 使用 Hugo 搭建博客的步骤非常简单。 按照官网 Quick Start 即可快速创建一个站点。此文旨在对官方文档细节补充以及部署到自己的github上。 下载Hugo 解压出对应包中的Hugo.exe到一个空目录 将 2 中存放Hugo.exe的目录添加到系统变量\"path\"中。（不会设置？点这里） 进入Hugo官网 点击 Quick Start 当下载并设置好Hugo后，就可以直接从Step 2开始操作。 # 这个 quickstart 请改成你想要的名字,最好对应你github上的名字且全小写 # 比如：untilthecore.github.io-generator # 这个命令会生成 untilthecore.github.io-generator 的文件夹 # 这个文件夹就是博客站点的生成器，为了方便知道这个文件夹是干什么的，在最后加上 generator，当然 creator 也行 hugo new site quickstart # 那么真正要输入的命令为 hugo new site untilthecore.github.io-generator 当得到站点生成器文件夹后，使用 cd 命令进入文件夹并依次执行以下命令 # 为 untilthecore.github.io-generator 初始化 git 仓库 git init # 为站点设置一个主题（这个主题可以修改） git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke # 向配置文件写入 theme = \"ananke\" 即配置 ananke 主题 echo 'theme = \"ananke\"' \u003e\u003e config.toml 完成以上步骤站点就配置好了，输入以下命令即可创建第一篇博客了 hugo new posts/my-first-post.md 通过以上步骤，站点已经创建好了，且写了一篇文章，赶紧通过这个命令启动本地服务器看看你的博客是什么样子吧。 hugo server -D 基础完成了，接下来需要对站点进行一些设置，让它看起来更像是你自己的站点。找到config.toml 文件，配置这些内容： # 配置域，如果配置到了github上，这里要改为你自己github.io的地址。 baseURL = \"https://example.org/\" # 配置语言 中文可以改为 \"zh-Hans\" languageCode = \"en-us\" # 站点标签名，浏览器标签上的内容 title = \"My New Hugo Site\" # 主题设置，有新主题，就把主题名设置到这里 theme = \"ananke\" 本地操作已经完成了，想要将站点部署到github或者自己的云服务器上，请继续往下看。 都配置好后，确保你控制台还处于博客生成器目录下(即\"untilthecore.github.io-generator\") 输入 hugo 在博客生成器目录下会产生一个'public/‘的文件夹，将这个文件夹部署到服务器上就可以了。 ","date":"2020-04-27","objectID":"/posts/web/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:1","tags":["Hugo","git","MarkDown"],"title":"使用hugo搭建个人博客","uri":"/posts/web/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["前端"],"content":"如何在github上部署自己静态博客呢？ 在github上创建一个仓库，仓库名为自己github名字的且以\".github.io“结尾。（如：untilthecore.github.io） 上面步骤 11 中的 public 文件夹还记得吗？首先在博客生成器目录中将它忽略git管理，即放入.gitignore中。没有这个文件就创建一个这样的文件，内容保存 “/public/” 即可将此文件夹忽略； 进入 public 文件夹中，初始化 git 并将这个文件夹上传到步骤1中创建的github仓库中； 在浏览器中进入你自己仓库的Settings中，找到图片这个地方看看点击能不能看到博客呢？成功了，祝贺你！没成功，看看有没有哪一步错了？ ","date":"2020-04-27","objectID":"/posts/web/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:2","tags":["Hugo","git","MarkDown"],"title":"使用hugo搭建个人博客","uri":"/posts/web/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["日志"],"content":"logback配置 此配置将不同几倍的日志归置到不同的文件中。 项目中使用，将对应的property属性值更改即可。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- 日志级别从低到高分为TRACE \u003c DEBUG \u003c INFO \u003c WARN \u003c ERROR \u003c FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\u003e \u003c!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --\u003e \u003c!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\u003e \u003c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\u003e \u003cconfiguration scan=\"true\" scanPeriod=\"10 seconds\"\u003e \u003ccontextName\u003elogback\u003c/contextName\u003e \u003c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --\u003e \u003cproperty name=\"log.path\" value=\"logs\"/\u003e \u003cproperty name=\"project.name\" value=\"project-name\"/\u003e \u003c!--0. 日志格式和颜色渲染 --\u003e \u003c!-- 彩色日志依赖的渲染类 --\u003e \u003cconversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\"/\u003e \u003cconversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\"/\u003e \u003cconversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\"/\u003e \u003c!-- 彩色日志格式 --\u003e \u003cproperty name=\"CONSOLE_LOG_PATTERN\" value=\"${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(%L:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\"/\u003e \u003c!--1. 输出到控制台--\u003e \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003c/filter\u003e \u003cencoder\u003e \u003cPattern\u003e${CONSOLE_LOG_PATTERN}\u003c/Pattern\u003e \u003c!-- 设置字符集 --\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!--2. 输出到文档--\u003e \u003c!-- 2.1 level为 DEBUG 日志，时间滚动输出 --\u003e \u003cappender name=\"DEBUG_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-debug.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c!-- 设置字符集 --\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 日志归档 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-debug-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录debug级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.2 level为 INFO 日志，时间滚动输出 --\u003e \u003cappender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-info.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 每天日志归档路径以及格式 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录info级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003einfo\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.3 level为 WARN 日志，时间滚动输出 --\u003e \u003cappender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-warn.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%","date":"2019-11-16","objectID":"/posts/log/logback%E9%85%8D%E7%BD%AE/:0:0","tags":["logback","入门","配置"],"title":"logback配置","uri":"/posts/log/logback%E9%85%8D%E7%BD%AE/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring-aop%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:0:0","tags":["源码","spring源码"],"title":"Spring AOP实现原理","uri":"/posts/spring/spring-aop%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["spring"],"content":"1.常见的实现类： 容器：AbstractApplicationContext抽象父类，核心(模板)方法 refresh()。 ClassPathXmlApplicationContext XML方式启动。 AnnotationConfigWebApplicationContext 注解方式启动，对局部代码进行测试时比较好用。 AnnotationConfigServletWebServerApplicationContext SpringBoot启动默认使用的上下文类。 ","date":"2019-11-16","objectID":"/posts/spring/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:0:1","tags":["源码","spring源码"],"title":"Spring IOC容器初始化流程","uri":"/posts/spring/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["spring"],"content":"2. spring ioc容器初始化的核心方法refresh，AbstractApplicationContext.refresh() 。 外层方法骨架 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. // 不太重要，预刷新，做一些准备工作。记录了启动时间戳，标记为活动，非关闭状态。 prepareRefresh(); /** * TODO 重点：解析xml配置文件，创建beanFactory，包装BeanDefinition */ // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 注册一些对事件、监听器等的支持 prepareBeanFactory(beanFactory); try { // 钩子方法，BeanFactory创建后，对BeanFactory的自定义操作。 // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // TODO 重点：这里调用了postProcessBeanDefinitionRegistry(registry);springboot中很多激活自动配置的注解都是通过这里导入的。 // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // TODO 重点：从beanFactory中获取所有的BeanPostProcessor，优先进行getBean操作，实例化 // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // 国际化支持 // Initialize message source for this context. initMessageSource(); // 初始化ApplicationEventMulticaster。 如果上下文中未定义，则使用SimpleApplicationEventMulticaster。 // Initialize event multicaster for this context. initApplicationEventMulticaster(); // 钩子方法，springBoot中的嵌入式tomcat就是通过此方法实现的 // Initialize other special beans in specific context subclasses. onRefresh(); // 监听器注册 // Check for listener beans and register them. registerListeners(); // TODO 重点方法：完成容器中bean的实例化，及代理的生成等操作。 // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // 完成此上下文的刷新，调用LifecycleProcessor的onRefresh（）方法并发布 // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } ","date":"2019-11-16","objectID":"/posts/spring/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/:0:2","tags":["源码","spring源码"],"title":"Spring IOC容器初始化流程","uri":"/posts/spring/spring-ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring-xml%E8%A7%A3%E6%9E%90%E5%8F%8Abeandefinition%E5%B0%81%E8%A3%85/:0:0","tags":["源码","spring源码"],"title":"Spring XML解析及Beandefinition封装","uri":"/posts/spring/spring-xml%E8%A7%A3%E6%9E%90%E5%8F%8Abeandefinition%E5%B0%81%E8%A3%85/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/springioc-getbean%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/:0:0","tags":["源码","spring源码"],"title":"SpringIOC-getBean核心流程","uri":"/posts/spring/springioc-getbean%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/springmvc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:0:0","tags":["源码","spring源码"],"title":"SpringMVC实现原理","uri":"/posts/spring/springmvc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:0","tags":["源码","spring源码"],"title":"Spring事务实现原理\u0026事务执行流程","uri":"/posts/spring/spring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-applicationlistener/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-ApplicationListener","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-applicationlistener/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-beandefinitionregistrypostprocessor/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-BeanDefinitionRegistryPostProcessor","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-beandefinitionregistrypostprocessor/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-beanpostprocessor/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-BeanPostProcessor","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-beanpostprocessor/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-factorybean/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-FactoryBean","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-factorybean/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-scope/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-Scope","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-scope/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-%E5%85%B6%E4%BB%96%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3/:0:0","tags":["源码","spring源码"],"title":"Spring扩展点-其他钩子方法、策略接口","uri":"/posts/spring/spring%E6%89%A9%E5%B1%95%E7%82%B9-%E5%85%B6%E4%BB%96%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3/"},{"categories":["spring"],"content":"未完待续… ","date":"2019-11-16","objectID":"/posts/spring/spring%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/:0:0","tags":["源码","spring源码"],"title":"Spring注解实现原理","uri":"/posts/spring/spring%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"categories":["linux"],"content":"清理Docker占用的磁盘空间 摘要：用了Docker，好处挺多的，但是有一个不大不小的问题，它会一不小心占用太多磁盘，这就意味着我们必须及时清理。 作为一个有信仰的技术公司，我们Fundebug的后台采用了酷炫的全Docker化架构，所有服务，包括数据库都运行在Docker里面。这样做当然不是为了炫技，看得清楚的好处还是不少的： 所有服务器的配置都非常简单，只安装了Docker，这样新增服务器的时候要简单很多。 可以非常方便地在服务器之间移动各种服务，下载Docker镜像就可以运行，不需要手动配置运行环境。 开发/测试环境与生产环境严格一致，不用担心由于环境问题导致部署失败。 至少，上线这一年多来，Docker一直非常稳定，没有出什么问题。但是，它有一个不大不小的问题，会比较消耗磁盘空间。 如果Docker一不小心把磁盘空间全占满了，你的服务也就算玩完了，因此所有Docker用户都需要对此保持警惕。当然，大家也不要紧张，这个问题还是挺好解决的。 1. docker system命令 在谁用光了磁盘？Docker System命令详解中，我们详细介绍了docker system命令,它可以用于管理磁盘空间。 docker system df命令，类似于Linux上的df命令，用于查看Docker的磁盘使用情况: 可知，Docker镜像占用了7.2GB磁盘，Docker容器占用了104.8MB磁盘，Docker数据卷占用了1.4GB磁盘。 docker system prune命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)。docker system prune -a命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的Docker镜像都删掉了…所以使用之前一定要想清楚吶。 执行docker system prune -a命令之后，Docker占用的磁盘空间减少了很多： 2. 手动清理Docker镜像/容器/数据卷 对于旧版的Docker(版本1.13之前)，是没有docker system命令的，因此需要进行手动清理。这里给出几个常用的命 删除所有关闭的容器 docker ps -a | grep Exit | cut -d ' ' -f 1 | xargs docker rm 删除所有dangling镜像(即无tag的镜像)： docker rmi $(docker images | grep \"^\u003cnone\u003e\" | awk \"{print $3}\") 删除所有dangling数据卷(即无用的volume)： docker volume rm $(docker volume ls -qf dangling=true) 3. 限制容器的日志大小 有一次，当我使用1与2提到的方法清理磁盘之后，发现并没有什么作用，于是，我进行了一系列分析。 在Ubuntu上，Docker的所有相关文件，包括镜像、容器等都保存在**/var/lib/docker/**目录中： du -hs /var/lib/docker/ 97G /var/lib/docker/ Docker竟然使用了将近100GB磁盘，这也是够了。使用du命令继续查看，可以定位到真正占用这么多磁盘的目录： 92G /var/lib/docker/containers/a376aa694b22ee497f6fc9f7d15d943de91c853284f8f105ff5ad6c7ddae7a53 由docker ps可知，nginx容器的ID恰好为a376aa694b22，与上面的目录**/var/lib/docker/containers/a376aa694b22**的前缀一致： docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a376aa694b22 192.168.59.224:5000/nginx:1.12.1 \"nginx -g 'daemon off\" 9 weeks ago Up 10 minutes nginx 因此，nginx容器竟然占用了92GB的磁盘。进一步分析可知，真正占用磁盘空间的是nginx的日志文件。那么这就不难理解了。我们Fundebug每天的数据请求为百万级别，那么日志数据自然非常大。 使用truncate命令，可以将nginx容器的日志文件“清零”： truncate -s 0 /var/lib/docker/containers/a376aa694b22ee497f6fc9f7d15d943de91c853284f8f105ff5ad6c7ddae7a53/*-json.log 当然，这个命令只是临时有作用，日志文件迟早又会涨回来。要从根本上解决问题，需要限制nginx容器的日志文件大小。这个可以通过配置日志的max-size来实现，下面是nginx容器的docker-compose配置文件： nginx: image: nginx:1.12.1 restart: always logging: driver: \"json-file\" options: max-size: \"5g\" 重启nginx容器之后，其日志文件的大小就被限制在5GB，再也不用担心了~ 4. 重启Docker 还有一次，当我清理了镜像、容器以及数据卷之后，发现磁盘空间并没有减少。根据Docker disk usage提到过的建议，我重启了Docker，发现磁盘使用率从83%降到了19%。根据高手指点，这应该是与内核3.13相关的BUG，导致Docker无法清理一些无用目录： it’s quite likely that for some reason when those container shutdown, docker couldn’t remove the directory because the shm device was busy. This tends to happen often on 3.13 kernel. You may want to update it to the 4.4 version supported on trusty 14.04.5 LTS. The reason it disappeared after a restart, is that daemon probably tried and succeeded to clean up left over data from stopped containers. 我查看了一下内核版本，发现真的是3.13: uname -r 3.13.0-86-generic 如果你的内核版本也是3.13，而且清理磁盘没能成功，不妨重启一下Docker。当然，这个晚上操作比较靠谱。 参考 谁用光了磁盘？Docker System命令详解 INTRODUCING DOCKER 1.13 Docker文档：docker system Docker文档：json-file Docker disk usage ","date":"2019-05-10","objectID":"/posts/linux/docker-clean/:0:0","tags":["Synology","docker"],"title":"清理 Docker 占用的磁盘空间","uri":"/posts/linux/docker-clean/"},{"categories":["linux"],"content":"1. 安装 acme.sh 安装很简单, 一个命令: curl https://get.acme.sh | sh 普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步: 把 acme.sh 安装到你的 home 目录下: ~/.acme.sh/\r并创建 一个 bash 的 alias, 方便你的使用: alias acme.sh=~/.acme.sh/acme.sh 自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书. 更高级的安装选项请参考: https://github.com/Neilpang/acme.sh/wiki/How-to-install 安装过程不会污染已有的系统任何功能和文件, 所有的修改都限制在安装目录中: ~/.acme.sh/ ","date":"2019-01-15","objectID":"/posts/linux/acme/:1:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"},{"categories":["linux"],"content":"2. 生成证书 acme.sh 实现了 acme 协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证. 1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了. acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/ 只需要指定域名, 并指定域名所在的网站根目录. acme.sh 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用. 如果你用的 apache服务器, acme.sh 还可以智能的从 apache的配置中自动完成验证, 你不需要指定网站根目录: acme.sh --issue -d mydomain.com --apache 如果你用的 nginx服务器, 或者反代, acme.sh 还可以智能的从 nginx的配置中自动完成验证, 你不需要指定网站根目录: acme.sh --issue -d mydomain.com --nginx 注意, 无论是 apache 还是 nginx 模式, acme.sh在完成验证之后, 会恢复到之前的状态, 都不会私自更改你本身的配置. 好处是你不用担心配置被搞坏, 也有一个缺点, 你需要自己配置 ssl 的配置, 否则只能成功生成证书, 你的网站还是无法访问https. 但是为了安全, 你还是自己手动改配置吧. 如果你还没有运行任何 web 服务, 80 端口是空闲的, 那么 acme.sh 还能假装自己是一个webserver, 临时听在80 端口, 完成验证: acme.sh --issue -d mydomain.com --standalone 更高级的用法请参考: https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert 2. 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权. 这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证. 坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。 acme.sh --issue --dns -d mydomain.com 然后, acme.sh 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可. 等待解析完成之后, 重新生成证书: acme.sh --renew -d mydomain.com 注意第二次这里用的是 --renew dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证. acme.sh 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成. 以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的. 然后: export DP_Id=\"1234\" export DP_Key=\"sADDsdasdgdsf\" acme.sh --issue --dns dns_dp -d aa.com -d www.aa.com 证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了. 直接生成就好了: acme.sh --issue -d mydomain2.com --dns dns_dp 更详细的 api 用法: https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md First you need to login to your Aliyun account to get your API key. https://ak-console.aliyun.com/#/accesskey export Ali_Key=\"sdfsdfsdfljlbjkljlkjsdfoiwje\" export Ali_Secret=\"jlsdflanljkljlfdsaklkjflsa\" Ok, let’s issue a cert now: acme.sh --issue --dns dns_ali -d example.com -d www.example.com The Ali_Key and Ali_Secret will be saved in ~/.acme.sh/account.conf and will be reused when needed. ","date":"2019-01-15","objectID":"/posts/linux/acme/:2:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"},{"categories":["linux"],"content":"3. copy/安装 证书 前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方. 注意, 默认生成的证书都放在安装目录下: ~/.acme.sh/, 请不要直接使用此目录下的文件, 例如: 不要直接让 nginx/apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化. 正确的使用方法是使用 --installcert 命令,并指定目标位置, 然后证书文件会被copy到相应的位置, 例如: acme.sh --installcert -d \u003cdomain\u003e.com \\ --key-file /etc/nginx/ssl/\u003cdomain\u003e.key \\ --fullchain-file /etc/nginx/ssl/fullchain.cer \\ --reloadcmd \"service nginx force-reload\" (一个小提醒, 这里用的是 service nginx force-reload, 不是 service nginx reload, 据测试, reload 并不会重新加载证书, 所以用的 force-reload) Nginx 的配置 ssl_certificate 使用 /etc/nginx/ssl/fullchain.cer ，而非 /etc/nginx/ssl/\u003cdomain\u003e.cer ，否则 SSL Labs 的测试会报 Chain issues Incomplete 错误。 --installcert命令可以携带很多参数, 来指定目标文件. 并且可以指定 reloadcmd, 当证书更新以后, reloadcmd会被自动调用,让服务器生效. 详细参数请参考: https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc 值得注意的是, 这里指定的所有参数都会被自动记录下来, 并在将来证书自动更新以后, 被再次自动调用. ","date":"2019-01-15","objectID":"/posts/linux/acme/:3:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"},{"categories":["linux"],"content":"4. 更新证书 目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心. ","date":"2019-01-15","objectID":"/posts/linux/acme/:4:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"},{"categories":["linux"],"content":"5. 更新 acme.sh 目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步. 升级 acme.sh 到最新版 : acme.sh --upgrade 如果你不想手动升级, 可以开启自动升级: acme.sh --upgrade --auto-upgrade 之后, acme.sh 就会自动保持更新了. 你也可以随时关闭自动更新: acme.sh --upgrade --auto-upgrade 0 ","date":"2019-01-15","objectID":"/posts/linux/acme/:5:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"},{"categories":["linux"],"content":"6. 出错怎么办： 如果出错, 请添加 debug log： acme.sh --issue ..... --debug 或者： acme.sh --issue ..... --debug 2 请参考： https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh 最后, 本文并非完全的使用说明, 还有很多高级的功能, 更高级的用法请参看其他 wiki 页面. https://github.com/Neilpang/acme.sh/wiki ","date":"2019-01-15","objectID":"/posts/linux/acme/:6:0","tags":["acme","letsencrypt","https","证书"],"title":"使用 ACME 免费申请 Let's Encrypt 证书","uri":"/posts/linux/acme/"}]