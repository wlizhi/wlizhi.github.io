[{"categories":null,"content":"留言板，留言给我","date":"2020-11-25","objectID":"/message-board/","tags":null,"title":"留言板","uri":"/message-board/"},{"categories":null,"content":"留言给我↓","date":"2020-11-25","objectID":"/message-board/:0:0","tags":null,"title":"留言板","uri":"/message-board/"},{"categories":["spring"],"content":"spring容器启动过程中，在创建BeanFactory、搜集BeanDefinition、实例化并调用BeanFactoryPostProcessor之后，会对BeanPostProcessor进行注册。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:0:0","tags":["spring源码"],"title":"[04] BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"BeanPostProcessor的作用 BeanPostProcessor是对SpringIOC容器中bean实例化的一些扩展，在bean实例化的关键节点进行了一些插桩。 真正实例化bean的方法是beanFactory.getBean()方法。而在bean实例化之前、实例化之后、依赖注入、初始化方法执行之前、初始化方法执行之后等节点进行一些钩子回调。BeanPostProcessor的作用就体现于此。 BeanPostProcessor接口只提供初始化方法执行前、后的节点操作。其余操作在它的子接口中定义。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:0:1","tags":["spring源码"],"title":"[04] BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"BeanPostProcessor的体系结构 BeanPostProcessor及其关键子接口的方法定义-UML图\"\rBeanPostProcessor及其关键子接口的方法定义-UML图\r 上图详细注释了BeanPostProcessor及其子接口每个方法的作用节点，从BeanPostProcessor接口继承体系可以看出，BeanPostProcessor贯穿整个Spring容器中Bean的实例化流程。可以说，在Spring容器中，任何一个Bean的实例化，在其关键节点，都有BeanPostProcessor的存在。甚至可以说它是SpringIOC容器组成部分中最重要的一个类。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:0:2","tags":["spring源码"],"title":"[04] BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"BeanPostProcessor的注册流程 以下是spring中BeanPostProcessor的源码： final class PostProcessorRegistrationDelegate { public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) { // 从beanDefinitionNames中获取所有BeanPostProcessor类型的beanName。 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); // 这里之所以要+1，因为在这个方法的结尾处，单独注册了一个BeanPostProcessor：ApplicationListenerDetector // Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors. int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount)); // Separate between BeanPostProcessors that implement PriorityOrdered, // Ordered, and the rest. // 实现了PriorityOrdered接口的。 List\u003cBeanPostProcessor\u003e priorityOrderedPostProcessors = new ArrayList\u003c\u003e(); // MergedBeanDefinitionPostProcessor类型的。 List\u003cBeanPostProcessor\u003e internalPostProcessors = new ArrayList\u003c\u003e(); // 实现了Ordered接口的。 List\u003cString\u003e orderedPostProcessorNames = new ArrayList\u003c\u003e(); // 没有实现排序接口的。 List\u003cString\u003e nonOrderedPostProcessorNames = new ArrayList\u003c\u003e(); // 对以上四种情况进行分别处理。 for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { orderedPostProcessorNames.add(ppName); } else { nonOrderedPostProcessorNames.add(ppName); } } // 注册BeanPostProcessors // First, register the BeanPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // 注册实现了Ordered接口的BeanPostProcessor。 // Next, register the BeanPostProcessors that implement Ordered. List\u003cBeanPostProcessor\u003e orderedPostProcessors = new ArrayList\u003c\u003e(); for (String ppName : orderedPostProcessorNames) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors); // 注册没有实现接口的BeanPostProcessor // Now, register all regular BeanPostProcessors. List\u003cBeanPostProcessor\u003e nonOrderedPostProcessors = new ArrayList\u003c\u003e(); for (String ppName : nonOrderedPostProcessorNames) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); // Finally, re-register all internal BeanPostProcessors. sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); } } 从上面代码可以看出，BeanPostProcessor的注册流程和BeanFactoryPostProcessor的注册流程类似。获取到BeanFactory中存储的BeanPostProcessor类型的beanName，然后对实现了不同排序接口的类、及没有实现排序接口的类分别进行getBean()操作、排序和注册。 ","date":"2020-11-24","objectID":"/posts/spring/04-registry-of-bean-post-processor/:0:3","tags":["spring源码"],"title":"[04] BeanPostProcessor的注册","uri":"/posts/spring/04-registry-of-bean-post-processor/"},{"categories":["spring"],"content":"spring ioc容器初始化时，首先创建BeanFactory对象，搜集BeanDefinition，在完成之后，会优先先实例化BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor，并调用postProcessBeanDefinitionRegistry()、postProcessBeanFactory()方法 ","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:0:0","tags":["spring源码"],"title":"[03] BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"BeanFactoryPostProcessor BeanFactoryPostProcessor中只有一个方法postProcessBeanFactory，实现了这个接口的类，会优先于其他常规的类实例化，并调用postProcessBeanFactory方法。 @FunctionalInterface public interface BeanFactoryPostProcessor { void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; } ","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:0:1","tags":["spring源码"],"title":"[03] BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"BeanDefinitionRegistryPostProcessor BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子接口，同样的，它会优先与其他常规的类，提前实例化、加入到IOC容器，并会调用postProcessBeanDefinitionRegistry()方法，再调用postProcessBeanFactory()方法。 public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor { void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException; } ","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:0:2","tags":["spring源码"],"title":"[03] BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"调用逻辑 首先搜集从BeanFactory中后去所有BeanDefinitionRegistryPostProcessor类型的beanName。 筛选出实现了PriorityOrdered接口的（筛选过程中会调用getBean()方法），并对其进行排序，然后进行遍历调用postProcessBeanDefinitionRegistry()。 筛选出实现了Ordered接口的，同上，进行getBean()，并排序，然后进行遍历调用postProcessBeanDefinitionRegistry()。 对没有实现PriorityOrdered接口且没有实现Ordered接口的BeanDefinitionRegistryPostProcessor进行排序、调用postProcessBeanDefinitionRegistry()。 上面的每一步调用postProcessBeanDefinitionRegistry()之前，会将其实力缓存到一个名为registryProcessors的List集合中，在以上步骤执行完，会调用BeanDefinitionRegistryPostProcessor.postProcessBeanFactory()方法 对没有实现BeanDefinitionRegistryPostProcessor但实现了BeanFactoryPostProcessor的类进行搜集。 分别筛选出实现了PriorityOrdered接口、Ordered接口、没有实现接口的类，对其进行排序、getBean()操作，调用postProcessBeanFactory()方法。 从源码中，我们可以很清晰的看到执行流程。源码逻辑如下： final class PostProcessorRegistrationDelegate { public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List\u003cBeanFactoryPostProcessor\u003e beanFactoryPostProcessors) { // 这里存储了已经调用过的BeanFactoryPostProcessor。 // BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子接口。 // 先调用BeanDefinitionRegistryPostProcessor的方法，然后是BeanFactoryPostProcessor // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set\u003cString\u003e processedBeans = new HashSet\u003c\u003e(); if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; // 这里面装的是实现了BeanFactoryPostProcessor接口的。 List\u003cBeanFactoryPostProcessor\u003e regularPostProcessors = new ArrayList\u003c\u003e(); // 这里面装的是实现了BeanDefinitionRegistryPostProcessor接口的。 List\u003cBeanDefinitionRegistryPostProcessor\u003e registryProcessors = new ArrayList\u003c\u003e(); // 对参数中传入的beanFactoryPostProcessors优先执行BeanDefinitionRegistryPostProcessor的方法，然后添加到registryProcessors中。 for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) { if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) { BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); } else { regularPostProcessors.add(postProcessor); } } // 记录当前注册的BeanDefinitionRegistryPostProcessor // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. List\u003cBeanDefinitionRegistryPostProcessor\u003e currentRegistryProcessors = new ArrayList\u003c\u003e(); // 从beanFactory中的beanDefinitionNames中获取所有的beanName。将实现了PriorityOrdered接口部分，放到处理过的bean容器中。 // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { // 这里进行了getBean操作。类的实例化就是通过此方法进行。 currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } // 对上面搜集到的BeanDefinitionRegistryPostProcessor进行排序、执行BeanDefinitionRegistryPostProcessor的方法 sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // 搜集实现了Ordered接口的BeanDefinitionRegistryPostProcessor，执行同上的逻辑。 // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName) \u0026\u0026 beanFactory.isTypeMatch(ppName, Ordered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } }// 排序、执行postProcessBeanDefinitionRegistry()方法 sortPostProcessors(currentRe","date":"2020-11-24","objectID":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/:0:3","tags":["spring源码"],"title":"[03] BeanFactoryPostProcessor的注册与执行","uri":"/posts/spring/03-bean-factory-post-processor-registry-and-execute/"},{"categories":["spring"],"content":"本章记录spring标签解析中，对标签属性解析的几个典型BeanDefinitionParser实现。","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"本篇是对 Spring程序入口和XML解析 的扩展，详细解析其中提到的BeanDefinitionParser的作用，以及一些典型的XML方式解析的实现类。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:0:0","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"[1] BeanDefinitionParser接口的定义 public interface BeanDefinitionParser { @Nullable BeanDefinition parse(Element element, ParserContext parserContext); } 可以看到，BeanDefinitionParser只有一个方法，负责BeanDefinitaion的解析。参数有节点元素、解析上下文对象。 在Spring中有很多内置的BeanDefinitionParser实现类（之所以说内置，因为它也是可以扩展的），包括XML方式解析、注解方式解析等。 注意\r\rParserContext中封装了BeanDefinitionRegistry对象，用于BeanDefinition的注册。\r\r 关于此类的实例从哪里注册、parse方法从哪里调入进来的， Spring程序入口和XML解析 中有结尾处有详细说明。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:1:0","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"[2] ComponentScanBeanDefinitionParser实现流程解析 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:0","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"（1）ComponentScanBeanDefinitionParser中的属性 ComponentScanBeanDefinitionParser是BeanDefinitionParser的一个实现，用于解析\u003ccontext:component-scan/\u003e标签的属性。 这个类中定义了一些常量，这些常量是\u003ccontext:component-scan/\u003e中所有可能用到的属性。比如最常用到的base-package属性。 前面有提到，parse方法的参数中有Element。在解析Element时，会对Element的多个属性进行识别及处理。这些常量的作用就在于此，用来区分Element的不同属性，并做特定的处理。 以下是ComponentScanBeanDefinitionParser中定义的常量： public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { private static final String BASE_PACKAGE_ATTRIBUTE = \"base-package\"; private static final String RESOURCE_PATTERN_ATTRIBUTE = \"resource-pattern\"; private static final String USE_DEFAULT_FILTERS_ATTRIBUTE = \"use-default-filters\"; private static final String ANNOTATION_CONFIG_ATTRIBUTE = \"annotation-config\"; private static final String NAME_GENERATOR_ATTRIBUTE = \"name-generator\"; private static final String SCOPE_RESOLVER_ATTRIBUTE = \"scope-resolver\"; private static final String SCOPED_PROXY_ATTRIBUTE = \"scoped-proxy\"; private static final String EXCLUDE_FILTER_ELEMENT = \"exclude-filter\"; private static final String INCLUDE_FILTER_ELEMENT = \"include-filter\"; private static final String FILTER_TYPE_ATTRIBUTE = \"type\"; private static final String FILTER_EXPRESSION_ATTRIBUTE = \"expression\"; } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:1","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"（2）主流程方法parse() 步骤： 获取到标签中base-package属性的值，这个值是必须的。（否则会抛出异常，异常信息At least one base package must be specified）。 创建扫描器：ClassPathBeanDefinitionScanner（mybatis中的扫描器就是继承了它） 调用核心方法doScan（这里解析并注册了BeanDefinition） 注册组件registerComponents（ClassPathBeanDefinitionScanner中，最终是一个空方法，可以不看，BeanDefinition的注册在doScan中做了） public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { public BeanDefinition parse(Element element, ParserContext parserContext) { // 获取base-package属性 String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage); String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // Actually scan for bean definitions and register them. ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); // TODO 重点：这里执行了具体的解析逻辑。 Set\u003cBeanDefinitionHolder\u003e beanDefinitions = scanner.doScan(basePackages); registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:2","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"（3）configureScanner方法 从以下源码可以看到，首先设置是否使用默认过滤器，然后创建扫描器ComponentScanBeanDefinitionParser，之后对其他属性进行一些设置。（关注源码中关键点就好，不然会越陷越深） public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { // 解析配置的属性，use-default-filters如果未定义，默认为true boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); } // 创建扫描器，其实mybatis中的扫描原理就来自于此，mybatis中的ClassPathMapperScanner继承了ClassPathBeanDefinitionScanner // Delegate bean definition registration to scanner class. ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters); // 下面的代码是对标签中其他属性的一些设置，其实就是把标签及其属性以java类的描述形式体现。 scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) { scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); } try { parseBeanNameGenerator(element, scanner); } catch (Exception ex) { parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause()); } try { parseScope(element, scanner); } catch (Exception ex) { parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause()); } parseTypeFilters(element, scanner, parserContext); return scanner; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:3","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"（4）核心方法doScan 扫描出所有满足条件的类，并封装成BeanDefinition 循环扫描到的BeanDefinition集合，依次执行操作。 解析@Scope注解 对不同类型的BeanDefinition做不同处理，@Lazy、@DependOn等注解信息封装就是在这里设置的。 校验是否是需要实例化的BeanDefinition，如果为true，则将BeanDefinition包装成BeanDefinitionHolder（这个类里封装了实例名称、别名信息） 源码如下： public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { protected Set\u003cBeanDefinitionHolder\u003e doScan(String... basePackages) { Assert.notEmpty(basePackages, \"At least one base package must be specified\"); // 用来装所有扫描到的类的BeanDefinition对象。 Set\u003cBeanDefinitionHolder\u003e beanDefinitions = new LinkedHashSet\u003c\u003e(); for (String basePackage : basePackages) { // TODO 重点看：查找候选组件，封装成BeanDefinition。 Set\u003cBeanDefinition\u003e candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) { // 获取到ScopeMetadata，如果类中有@Scope注解，则会将值封装到这个实例中。然后设置到BeanDefinition中。 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); // 对不同类型的BeanDefinition做不同的处理。 if (candidate instanceof AbstractBeanDefinition) { postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); } // 对不同类型的BeanDefinition做不同的处理，@Lazy、@DependOn等注解信息封装就是在这里设置的。 if (candidate instanceof AnnotatedBeanDefinition) { // 一些注解信息的封装 AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); } // 校验是否是需要实例化的BeanDefinition，如果为true，则将BeanDefinition包装成BeanDefinitionHolder（这个类里封装了实例名称、别名信息） if (checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 注册BeanDefinition registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:4","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"（5）findCandidateComponents原理解析 最终会执行到scanCandidateComponents()方法。从下面源码中可以看到，实际上就是根据\u003ccontext:component-scan/\u003e标签配置的base-package来扫描对应路径下的文件输入流，读取类文件信息。进而拿到Class对象，封装成BeanDefinition对象。然后向上返回，直到注册到BeanDefinitionRegistry中。 public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser { private Set\u003cBeanDefinition\u003e scanCandidateComponents(String basePackage) { Set\u003cBeanDefinition\u003e candidates = new LinkedHashSet\u003c\u003e(); try { //根据路径扫描 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; // 获取指定包下匹配到的所有的资源对象。里面封装了InputStream，用来读取类文件。 Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) { if (traceEnabled) { logger.trace(\"Scanning \" + resource); } if (resource.isReadable()) { try { // 封装成ScannedGenericBeanDefinition，这里封装了包下所有的类信息 MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); if (isCandidateComponent(metadataReader)) { // 创建BeanDefinition对象，将 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); // 判断是否是候选组件，如果是，就添加BeanDefinition对象 if (isCandidateComponent(sbd)) { if (debugEnabled) { logger.debug(\"Identified candidate component class: \" + resource); } candidates.add(sbd); } else { if (debugEnabled) { logger.debug(\"Ignored because not a concrete top-level class: \" + resource); } } } else { if (traceEnabled) { logger.trace(\"Ignored because not matching any filter: \" + resource); } } } catch (Throwable ex) { throw new BeanDefinitionStoreException( \"Failed to read candidate component class: \" + resource, ex); } } else { if (traceEnabled) { logger.trace(\"Ignored because not readable: \" + resource); } } } } catch (IOException ex) { throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); } return candidates; } } ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:2:5","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"[3] AspectJAutoProxyBeanDefinitionParser AspectJAutoProxyBeanDefinitionParser是对aop标签的aop:aspectj-autoproxy/的支持 源码： class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser { @Override @Nullable public BeanDefinition parse(Element element, ParserContext parserContext) { // 对aspectj-autoproxy属性的支持 AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 添加IncludePatterns extendBeanDefinition(element, parserContext); return null; } } 会走到这里： public abstract class AopConfigUtils { @Nullable public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary( BeanDefinitionRegistry registry, @Nullable Object source) { // 注入此类 AnnotationAwareAspectJAutoProxyCreator，本质还是一个BeanPostProcessor, // 实现了BeanPostProcessor的子接口：SmartInstantiationAwareBeanPostProcessor return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source); } } AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法中，注册了AnnotationAwareAspectJAutoProxyCreator的支持，这个类会在AOP知识点中详细阐述。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:3:0","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"[4] 总结 spring对XML的解析，就是通过NameSpaceHandler中注册的BeanDefinitionParser进行处理的。通过SPI的方式，很容易对标签解析功能进行扩展。 技巧\r\r其他的解析类，方法都是一样的。 首先根据标签名称找到NamespaceUri，根据SPI加载方式，到对应模块META-INF/spring.handlers文件中查找对应的NamespaceHandler实现类； 然后在实现类中的init方法中，找到标签属性对应的BeanDefinitionParser实现类； 最后，进入实现类的parse方法，读源码即可。结合断点调试，很容易读懂。 \r\r 万事开头难，spring源码也一样。刚开始确实挺难理解的，理清了脉络后，再读起来就相对简单很多。 ","date":"2020-11-23","objectID":"/posts/spring/02-spring-tag-parse-bean-definition-parser/:4:0","tags":["spring源码"],"title":"[02] Spring标签解析-BeanDefinitionParser","uri":"/posts/spring/02-spring-tag-parse-bean-definition-parser/"},{"categories":["spring"],"content":"本章记录了Spring源码的程序入口，和XML解析的源码流程。","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"前言 Spring源码Gitee传送门 （从Github中下载，对核心流程及主要节点做了详细的中文注释。建议下载、结合本系列笔记阅读源码） 用 jack大佬 的话来概括，为什么要学习Spring源码？ 提高自己的写代码能力 从全局考虑如何使代码变得灵活可扩展 Spring重新定义了Java Spring源码是有一定难度的 如果想成为真正的高手，Spring源码必须攻克，不是危言耸听的 Spring源码这块儿，进大厂是必问的环节 学习源码的方式：主抓脉络，后看细节。（熟练使用的前提下再看源码） ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:1","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"Spring的历史 2002年10月,Rod Johnson发布《Expert One-on-One J2EE设计和开发》一书 2004年3月，Spring1.0发布 2006年10 月，Spring2.0发布 2009年12月，Spring3.0发布 2013年12月，发布Spring4.0 2017年9月，Spring5.0发布 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:2","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"读源码前的准备 JDK1.8版本 spring 5.1.3.RELEASE版本 补一下Lambda表达式的知识 安装配置gradle ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:3","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"Spring源码下载 git clone --branch v5.1.3.RELEASE https://gitee.com/wanglizhi00/spring-framework （此链接的Spring源码，核心流程、要注意的点我都做了中文注释，非常详细。如果你的网络足够好，到github下载原版也可以） gradle下载，gradle要JDK8的版本 到下载的spring源码路径执行gradle命令，gradlew :spring-oxm:compileTestJava 用idea打开spring源码工程。（在idea中安装插件kotlin，重启idea，跟IDEA版本有关较新版本不用安装） 把编译好的源码导入到工程中 spring工程如何搭建这里不做介绍，如何将down下来的源码导入到自己的spring工程依赖库， 我的Gitee-Spring源码注释 中有详细的介绍 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:4","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"入口方法 容器：AbstractApplicationContext 抽象父类，核心(模板)方法 refresh()。 ClassPathXmlApplicationContext XML方式启动。 AnnotationConfigWebApplicationContext 注解方式启动，对局部代码进行测试时比较好用。 AnnotationConfigServletWebServerApplicationContext SpringBoot启动默认使用的上下文类。 我们知道，spring容器的启动是通过构造ApplicationContext的一个实例开始的。以ClassPathXmlApplicationContext为例。 ClassPathXmlApplicationContext UML图ClassPathXmlApplicationContext UML图 \"\rClassPathXmlApplicationContext UML图\r ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:5","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"Xml解析流程概览 首先进入spring容器启动的核心方法：refresh() ，创建BeanFactory对象 obtainFreshBeanFactory() 创建XmlBeanDefinitionReader对象 通过Reader对象加载配置文件 根据加载的配置文件把配置文件封装成document对象 创建BeanDefinitionDocumentReader对象，DocumentReader负责对document对象解析 parseDefaultElement(ele, delegate);负责常规标签解析 delegate.parseCustomElement(ele);负责自定义标签解析 最终解析的标签封装成BeanDefinition并缓存到容器中 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:6","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"创建XmlBeanDefinitionReader对象 public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext { @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // Create a new XmlBeanDefinitionReader for the given BeanFactory. // 创建BeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); // TODO 关键点：加载BeanDefinition loadBeanDefinitions(beanDefinitionReader); } } 在loadBeanDefinitions方法的第一行，创建了XmlBeanDefinitionReader对象。这个类的主要作用是读取BeanDefinition，并将XML文档的读取委托给BeanDefinitionDocumentReader。 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:7","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"创建BeanDefinitionDocumentReader对象 来到loadBeanDefinitions(beanDefinitionReader);这里将要读取的xml路径传递进来，循环xml路径，依次进行解析。 注：看注释中的关键点 public abstract class AbstractBeanDefinitionReader implements BeanDefinitionReader, EnvironmentCapable { // 首先进入这个方法 @Override public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException { Assert.notNull(locations, \"Location array must not be null\"); int count = 0; // 一次解析配置文件，加载配置文件中定义的Bean。 for (String location : locations) { count += loadBeanDefinitions(location); } return count; } } 路径最终会被封装为IinputSource对象，使用委托模式，交给BeanDefinitionDocumentReader处理 public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader { // 第一步：入口 protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 解析xml配置文件，获取到Document对象 Document doc = doLoadDocument(inputSource, resource); // 解析、注册BeanDefinition int count = registerBeanDefinitions(doc, resource); if (logger.isDebugEnabled()) { logger.debug(\"Loaded \" + count + \" bean definitions from \" + resource); } return count; //此处分别捕获了很多种异常，省略了。 } catch (Exception ex) { throw ex; } } // 第二步 创建BeanDefinitionDocumentReader，委托给BeanDefinitionDocumentReader进行解析工作。 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // 委托模式，将Document的解析及BeanDefinition的注册交给BeanDefinitionDocumentReader // 这里使用的DefaultBeanDefinitionDocumentReader进行解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // TODO 关键点：解析xml、注册BeanDefinition documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore; } } ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:8","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"标签解析入口 在解析标签之前、和之后，分别有一个钩子方法。这两个钩子方法分别是 解析xml并注册BeanDefinition 之前和之后的扩展方法，ClassPathXmlApplicationContext中，这两个方法体都是空的。 public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader { // 第一步 protected void doRegisterBeanDefinitions(Element root) { // Any nested \u003cbeans\u003e elements will cause recursion in this method. In // order to propagate and preserve \u003cbeans\u003e default-* attributes correctly, // keep track of the current (parent) delegate, which may be null. Create // the new (child) delegate with a reference to the parent for fallback purposes, // then ultimately reset this.delegate back to its original (parent) reference. // this behavior emulates a stack of delegates without actually necessitating one. BeanDefinitionParserDelegate parent = this.delegate; // BeanDefinitionParserDelegate中封装了预定义的很多标签属性 this.delegate = createDelegate(getReaderContext(), root, parent); // 根标签解析 NameSpace：http://www.springframework.org/schema/beans if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); // We cannot use Profiles.of(...) since profile expressions are not supported // in XML config. See SPR-12458 for details. if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isDebugEnabled()) { logger.debug(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); } return; } } } // 钩子方法，解析xml注册BeanDefinition之前调用，可以不看 preProcessXml(root); // TODO 解析xml，注册BeanDefinition parseBeanDefinitions(root, this.delegate); // 钩子方法，解析xml注册BeanDefinition之后调用，可以不看 postProcessXml(root); this.delegate = parent; } // 第二步 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { // Spring根标签，NameSpace：http://www.springframework.org/schema/beans // 这里循环document中的元素，进行解析默认标签及自定义标签 String tagName = root.getTagName(); if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i \u003c nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { logger.debug(\"delegate.isDefaultNamespace(root):true,解析默认标签 \" + tagName); // TODO 关键点：解析默认标签 parseDefaultElement(ele, delegate); } else { logger.debug(\"delegate.isDefaultNamespace(root):true,解析自定义标签 \" + tagName); // TODO 关键点：解析自定义标签 delegate.parseCustomElement(ele); } } } } else { logger.debug(\"delegate.isDefaultNamespace(root):false,解析自定义标签 \" + tagName); // TODO 关键点：解析自定义标签 delegate.parseCustomElement(root); } } } ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:9","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"解析默认标签 根据xml节点的名称，对比代码中定义的标签名称。跳转到对应的解析方法 以bean标签为例，最终走到BeanDefinitionParserDelegate.parseBeanDefinitionElement()方法 public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader { // 第一步 进入标签解析方法 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { // import标签解析 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } // alias标签解析 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } // TODO 重点看：bean标签解析 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { processBeanDefinition(ele, delegate); } // beans标签解析 else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // recurse doRegisterBeanDefinitions(ele); } } // 第二步 进入bean标签解析方法 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // TODO 重点：获取到BeanDefinitionHolder，内部封装了BeanDefinition BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // 如果必要，装饰BeanDefinition，这里用到了装饰模式 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } } 解析和封装BeanDefinition，这里解析了bean标签中的所有属性，将这些属性值封装成BeanDefinition对象。最终会被注册到BeanDefinitionRegistry中。 BeanDefinitionRegistry作为spring容器中BeanFactory的全局成员变量。也就是说，最终得到的BeanDefinition贯穿整个spring容器的生命周期，它是对spring容器中所有将要实例化的bean信息的描述。 public class BeanDefinitionParserDelegate { @Nullable public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); // bean标签中的class属性 String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } // bean标签中的parent属性 String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { // TODO 重点：创建BeanDefinition，设置parent、beanClass、beanClassName属性。 // bean标签的bean均定义为：GenericBeanDefinition AbstractBeanDefinition bd = createBeanDefinition(className, parent); // TODO 重点：解析element并设置BeanDefinition中的属性值 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 解析meta标签、lookupOverride子标签、replaceMethod子标签 parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析构造函数参数、property参数、qualifier参数 parseConstructorArgElements(ele, bd); parsePropertyElements(ele, bd); parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(\"Bean class [\" + className + \"] not found\", ele, ex); } catch (NoClassDefFoundError err) { error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err); } catch (Throwable ex) { error(\"Unexpected failure during bean definition parsing\", ele, ex); } finally { this.parseState.pop(); } return null; } } ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:10","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"解析自定义标签 SPI方式获取加载所有的namespaceUri（SPI这里不进行讨论），通过当前标签定义的namespaceUri，获取到初始化后（init()）的处理类。然后调用处理类的parse方法，在此方法中，完成了标签属性的解析和BeanDefinition注册 在resolve方法中，调用了NamespaceHandler的init方法，init方法中注册了标签属性的处理类。 这些处理类都是BeanDefinitionParser的实现，在BeanDefinitionParser中，仅有一个parse方法，用来解析特定的标签属性。 public class BeanDefinitionParserDelegate { @Nullable public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) { // SPI方式获取namespaceUri String namespaceUri = getNamespaceURI(ele); if (namespaceUri == null) { return null; } // 获取NamespaceHandler，这里面调用了NamespaceHandler的init方法 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) { error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele); return null; } return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); } } NamespaceHandler，是根据对应模块中的META-INF/spring.handlers中定义的映射关系进行获取的（SPI方式获取）。映射关系NamespaceUri=NamespaceHandler 以下是spring-context中定义的处理映射（spring-context/META-INF/spring.handlers） http\\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler http\\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler http\\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler http\\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler http\\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler resolve方法获取了处理类对象，每个处理类实例化之后都会放入缓存handlerMappings，下次获取直接从缓存中获取。handlerMappings的键时NamespaceUri，值初始是对应处理类的ClassName，实例化之后会替换为该类的实例对象。 public class DefaultNamespaceHandlerResolver implements NamespaceHandlerResolver { @Override @Nullable public NamespaceHandler resolve(String namespaceUri) { // 从缓存中获取，如果存在，直接返回，如果不存在则创建 Map\u003cString, Object\u003e handlerMappings = getHandlerMappings(); Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) { return null; } else if (handlerOrClassName instanceof NamespaceHandler) { return (NamespaceHandler) handlerOrClassName; } else { String className = (String) handlerOrClassName; try { // 加载Class Class\u003c?\u003e handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException(\"Class [\" + className + \"] for namespace [\" + namespaceUri + \"] does not implement the [\" + NamespaceHandler.class.getName() + \"] interface\"); } // TODO 重点：实例化NamespaceHandler，调用init方法，放入缓存。这里是一个扩展点，所有的自定义标签都要提供对应的NamespaceHandler // spring.handler文件中定义了很多内置的NamespaceHandler，通过SPI的方式加载、实例化 NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); namespaceHandler.init(); handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; } catch (ClassNotFoundException ex) { throw new FatalBeanException(\"Could not find NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"]\", ex); } catch (LinkageError err) { throw new FatalBeanException(\"Unresolvable class definition for NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"]\", err); } } } } 每个自定义标签都有自己的NamespaceHandler实现。 NamespaceHandler实现类\"\rNamespaceHandler实现类\r 以context标签为例，注册不同标签属性对应的处理类。 public class ContextNamespaceHandler extends NamespaceHandlerSupport { @Override public void init() { // 注册各种标签属性的解析类 registerBeanDefinitionParser(\"property-placeholder\", new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(\"property-override\", new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(\"annotation-config\", new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(\"load-time-weaver\", new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionParse","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:11","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["spring"],"content":"总结 Spring解析XML，绕了这么大一圈。其目的就是把XML中配置的各种标签按照标签本身定义的解析方式进行处理，将处理的结果封装成BeanDefinition对象，并注入到BeanFactory的成员变量BeanDefinitionRegistry中。 这是Spring容器以XML方式初始化的第一步。其实无论是XML解析方式，还是注解方式，基本思想都是一样的。Spring容器在创建任何实例前，都会先搜集这个将要创建实例的一些必要信息，然后对这些信息根据一些扩展接口中提供的方法（模板设计模式），进行处理。 这些处理有一些是Spring内置的，可能也有使用者自定义的。具体的处理方式，在后面的章节体现。 ","date":"2020-11-22","objectID":"/posts/spring/01-spring-entrance-and-xml-parse/:0:12","tags":["spring源码"],"title":"[01] Spring程序入口和XML解析","uri":"/posts/spring/01-spring-entrance-and-xml-parse/"},{"categories":["文档"],"content":"本章记录一些博客的链接，经常百度的一些内容，以链接的方式记录在这里，使用站内搜索引擎方便查找。 ","date":"2020-11-21","objectID":"/posts/docs/other-blog-link/:0:0","tags":["链接"],"title":"其他 - 转载","uri":"/posts/docs/other-blog-link/"},{"categories":["文档"],"content":"linux相关 shell脚本基础：Runoob.com linux常用命令大全 linux 查看日志的几种基本操作 Centos7：ssh免密登录设置 Centos7 minimal安装后的一些配置(解决ifconfig、vim等not found问题) 深入理解VMware虚拟机网络通信原理 ","date":"2020-11-21","objectID":"/posts/docs/other-blog-link/:0:1","tags":["链接"],"title":"其他 - 转载","uri":"/posts/docs/other-blog-link/"},{"categories":["文档"],"content":"框架 Spring事务传播行为详解 Springboot 单元测试详解 ","date":"2020-11-21","objectID":"/posts/docs/other-blog-link/:0:2","tags":["链接"],"title":"其他 - 转载","uri":"/posts/docs/other-blog-link/"},{"categories":["文档"],"content":"工具 Git命令大全 解决GitHub每次push时都提示输入用户名和密码的问题 VMWare使用文档 VMware安装Centos7超详细过程（图文） vi/vim 命令使用详解 ","date":"2020-11-21","objectID":"/posts/docs/other-blog-link/:0:3","tags":["链接"],"title":"其他 - 转载","uri":"/posts/docs/other-blog-link/"},{"categories":["折腾"],"content":"关于站内搜索，试用两天lunr后，还是决定换成algolia，algolia本身性能更高、也更加节省流量。","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"原由 博客搭建好之后，还算满意。试用过程中，偶然发现页面跳转时每次都会请求几个lunr相关支持的js文件，搜索时，又会下载index.js文件。 对lunr支持的文件，还是比较大的；index.js就是文档索引内容了，这个文件和网站内容数量成正比。目前文章只有十多篇，index.js文件就有70kb。 随着文章的发布，index.js会不断增大，且每次点击搜索框进行搜索，都会下载此文件。内容不多的情况下，速度相较于algolia更快。（网络原因，即使选择官方最近的数据中心，还是略卡） 一番思索后，决定将lunr换成algolia（虽然因网络原因，目前lunr更快），原因：并非每次加载页面都需要搜索支持，而使用lunr总是会下载搜索相关支持文件，algolia就没有这个问题。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:1","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"lunr和algolia的区别 lunr每次搜索前、都会请求对lunr支持的js文件、及将要分析的索引文档（index.json）。也就是说，搜索功能本身及将要搜索的全部网站数据索引，都是一次性发送到客户端，在客户端浏览器上运行的。这种方式太过简单粗暴。 algolia则是将索引分析任务交给第三方服务器（algolia官方的），需要分析的索引文档，提前上传到algolia服务器，搜索时，客户端仅发送搜索的关键字、身份校验的一些信息。algolia分析本地索引文件，处理完成后将结果返回给客户端。 相对lunr，algolia少了向客户端发送搜索引擎功能文件（因为搜索在服务器做了，搜索功能本身可以做的更强大）、及索引文件。仅仅是搜索关键字、和处理结果的传输，就省了很大一笔网络开销，这也是它的高效之处。 algolia比lunr多了一次网络请求。一般公司里项目做搜索，搜索引擎服务器和业务服务器是通过内网链接，网络延迟很低很低。使用algolia的唯一痛点就在这了，即使选择algolia在国内的数据中心（香港），也还是有点延迟的。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:2","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"使用algolia algolia使用还是很简单的，Algolia官网 注册账号 -\u003e 创建应用 -\u003e 创建indices -\u003e 上传索引文件。 hugo项目中，配置一些必要信息（前提主题支持algolia搜索）。分别是Algolia中创建的index名称、appId、searchKey。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:3","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["折腾"],"content":"自动更新index 每次发布新内容，如果手动上传索引文件到algolia，是相当麻烦的。 Algolia Atomic 是一个不错的选择。 ","date":"2020-11-21","objectID":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/:0:4","tags":["博客","hugo"],"title":"两天后 - 还是决定将搜索更换为algolia","uri":"/posts/experience/replace-the-search-with-algolia-at-two-days-later/"},{"categories":["生活"],"content":"回忆 六年前的一个LOL视频，当初也是实锤的电竞粉额。2015年夏天也是拿这个英雄打了一个月排位，网一区一路从白银打到钻二，排行榜3000多名（据说这区活跃用户大概50万），之后便不怎么玩儿了。 \r","date":"2020-11-21","objectID":"/posts/life/memory-lol/:0:1","tags":["LOL"],"title":"Memory LOL","uri":"/posts/life/memory-lol/"},{"categories":["生活"],"content":"emm…那年夏天 ","date":"2020-11-21","objectID":"/posts/life/memory-lol/:0:2","tags":["LOL"],"title":"Memory LOL","uri":"/posts/life/memory-lol/"},{"categories":["折腾"],"content":"前言 搭建过程有些波折，好在总算完成了。目前博客采用hugo的主题。不得不说，hugo使用起来相较于jekyll简单了许多，除了主题生态没有jekyll的丰富，别的没毛病。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:1","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"起因 上周听Jack老师的课，翻了某位同学博客 （叶良辰学习笔记），陡然眼前一亮，原来笔记还可以这么玩儿。 其实几年前我就有意搭建个人博客，一直没落实的原因：确实有些忙，偶尔闲下来时又去学习新的知识，自己写博客系统的话，太耗时间、精力（作为一个java程序员，前端能力有限，你懂得。），会的一堆后端技术，这里毫无用武之地。时至今日这个计划已经迟滞了三年多。 很多云笔记也有分享功能，甚至一键发布博客功能。比如有道云笔记、印象笔记、蚂蚁笔记等，都有用过。看了这位同学的笔记（博客）后，回想自己用云笔记的方式，决定还是研究一下博客系统。一个存储私密文档，一个发布公开文档。 Jack老师博客传送门 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:2","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"百度 - 货比三家 直接写静态页面得不偿失。页面+后端方式实现博客、管理等功能，太重，且前端能力有限。无论如何，最终内容还是要静态页面，除非你不想被搜索引擎扒到。 首先百度搜索静态页面生成器，很多流行的，不晓得先入手研究哪个，对比了许多帖子，决定先看看jekyll。然后在 jekyll主题网站 选择了几个主题。 一般主题网站中的主题都有demo，先看demo效果。 到github仓库，fork到自己的仓库。 根据README.md文档的介绍，将代码拉取到本地，用IDE打开。（我使用的IDEA，毕竟做后端的…） 根据使用文档（很多主题其实只有一个文件介绍，不是特别详细，需要自己摸索）修改配置。 尝试了几个主题后，大多功能都正常，个别地方有问题，本地很难调试。（依赖ruby、nodejs等环境，作为java程序员，对这玩意儿认知低的可怜） 尝试了几个主题后，感觉还凑合，将修改好的主题推送到github后，通过gitPages托管。能访问，龟速。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:3","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"选择 - Hugo 之后翻看网上的博客时，看到有人说使用的hugo，于是点进去搜了一通。选择了几个主题，挨个试。这里说下我使用的感受： jekyll优点：主题更丰富，选择性更多。 jekyll缺点：使用实在太复杂，构建速度着实慢了些。 hugo优点：使用真的简单，比jekyll简单太多了。构建速度真的快，比jekyll快很多很多倍。（目前没太多内容，构建后大概100多个静态 文件，构建需要500ms左右） hugo缺点：主题没jekyll选择性那么多，也还可以。官网上有些主题相对简陋。（注：不是简约，是简陋） 使用jekyll时，看到一个比较喜欢的主题ThemePersephone，只是搞了半天，gitpages托管的代码是可以访问了，本地环境却始终弄不好（ruby的问题，下载了最新版本不行。准备换个版本的安装包，死活下载不了，官网被墙的厉害），只好放弃。之后在HugoThemes下载主题，试用。只需要下载一个二进制文件，不需要其他任何依赖。没有对比就没有伤害，最终选择Hugo ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:4","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"搭建 两款主题 hugo-theme-hello-friend-ng 和 loveit ，最终选择loveit这款主题，原因是，文档超级详细，功能足够丰富。支持搜索引擎（两款）、评论系统、shortcode、emoji等。该有的功能基本都支持，唯一不满的是md text块的背景色、字体颜色有点丑。有空再研究给换个色。 搜索引擎支持两种： lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 暂时选择lunr，原因简单，现在的访问量来看，缺点可以忽略（好吧…两天后-决定将搜索更换为Alogial）。 评论系统略有点麻烦，支持6种评论系统（disqus、gitalk、valine、facebook、telegram comments、commento、utterances），挨个打开，打开valine官网速度较快，最终选择这个，不为别的，官网打开速度的印象分。 评论本身配置相对简单，根据提示来就行。邮件提醒功能略麻烦点，valine从v1.4.0版本后，不再支持邮件提醒功能。只能使用的第三方邮件提醒。关于这个，github上很多开源项目。我选择的 Valine-Admin ，部署到LeanCloud创建的应用中。部署后需要配置一些环境变量，主要是邮件发送的服务器、账号、授权码、自己网站url等。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:5","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"迁移 - 阿里云 图片资源使用阿里云对象存储OSS，静态页面迁移到阿里云服务器。 GitPages托管方式，访问速度有点慢，还算能接受吧。服务器有、域名有（旧的域名不太喜欢，新域名备案完成还得几天），最终决定迁移到阿里云。部署：服务器安装docker -\u003e docker安装nginx -\u003e 安装git -\u003e 将hugo生成的html文件拉取到nginx路由的目录下，部署完成。 迁移到阿里云后的感受：不卡了，emm…丝滑。嗯，也收费了。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:6","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"自动部署 使用Github的WebHooks，服务器写一个脚本即可。 流程大概是这个样子：当push代码到github时，触发回调接口。在服务器上部署一个web项目（我使用的springboot），暴露一个接口供webhooks调用。接口内容是异步方式（一个单线程的线程池）执行shell脚本，完成自动部署。 更轻量的方式，手写代码，使用socket接收请求，执行脚本更加高效。http接口方式写起来比较快，十多分钟完事。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:7","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"域名备案 wlz922.top是我一直使用的域名，域名备案相对麻烦，思虑再三还是决定再注册一个。 新域名wlizhi.cc审核估计还得几天。 备案流程有点麻烦，周期是比较长的（到域名服务商注册 -\u003e 阿里云初审 -\u003e 通管局审核）。 首先注册域名，注册后是不能直接备案的，要等1-3天。然后申请备案，填一些必须的资料。阿里云关于备案相关资料太多，没看，直接按照流程提示填写资料。之后初审驳回一次（验证资料不规范），按要求重新上传资料，初审通过，等待管局审核。 有一点需要说明，域名备案时，解析的网站首页必须和资料填写的内容一致，页脚必须有备案号链接到 工信部域名备案管理 网站（我上个域名备案时让填的不是这个网址，搞不懂）。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:8","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["折腾"],"content":"最后 看jekyll、hugo文档、选主题、读主题及主题支持各种插件文档、迁移至阿里云。历时四天，博客主题基本选定（主题选了两天多，换了五六个。强迫症，总想找个更好的）、搭建完成。没事还是要研究一下hugo，折腾已成本能。 ","date":"2020-11-19","objectID":"/posts/experience/my-blog-building-process/:0:9","tags":["博客","hugo"],"title":"我的博客搭建历程","uri":"/posts/experience/my-blog-building-process/"},{"categories":["系统"],"content":"linux 基础概念、文件系统组成、常用命令、应用安装 - 卸载","date":"2020-11-18","objectID":"/posts/linux/linux-basics/","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"1. 基础介绍 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:1:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"发行的linux版本 Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS linux各个版本\"\rlinux各个版本\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:1:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"系统目录结构 linux目录结构\"\rlinux目录结构\r 系统启动必须： 信息\r\r /boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。 /etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。 /lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中 \r\r 指令集合： 信息\r\r /bin：存放着最常用的程序和指令 /sbin：只有系统管理员能使用的程序和指令。 \r\r 外部文件管理： 信息\r\r /dev ：Device(设备)的缩写, 存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。 /media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。 /mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 \r\r 临时文件 信息\r\r /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。 /tmp：这个目录是用来存放一些临时文件的。 \r\r 账户： 信息\r\r /root：系统管理员的用户主目录。 /home：用户的主目录，以用户的账号命名的。 /usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序与指令。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 \r\r 运行过程中要用： 信息\r\r /var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。 /proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。 \r\r 扩展用的： 信息\r\r /opt：默认是空的，我们安装额外软件可以放在这个里面。 /srv：存放服务启动后需要提取的数据（不用服务器就是空） \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:1:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"linux基础命令 shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。 信息\r\r# shutdown -P now ### 关闭机器 # shutdown -H now ### 停止机器 # shutdown -r 09:35 ### 在 09:35am 重启机器\r\r 要取消即将进行的关机，只要输入命令： # shutdown -c halt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。 信息\r\r# halt ### 停止机器 # halt -p ### 关闭机器 # halt –reboot ### 重启机器\r\r poweroff 会发送一个 ACPI 信号来通知系统关机。 信息\r\r# poweroff ### 关闭机器 # poweroff –halt ### 停止机器 # poweroff –reboot ### 重启机器\r\r reboot 命令 reboot 通知系统重启。 信息\r\r# reboot ### 重启机器 # reboot –halt ### 停止机器 # reboot -p ### 关闭机器\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:1:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"2. linux用户/用户组 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"增加一个用户组 信息\r\rgroupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 例1： # groupadd group1 ##此命令向系统中增加了一个新组group1 例2： # groupadd -g 1003 group2 ##此命令向系统中增加了一个新组group2，同时指定新组的组标识号是1003 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"删除一个用户组 信息\r\rgroupdel 用户组 例：# groupdel group1 ##此命令从系统中删除组group1。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"修改用户组的属性 信息\r\rgroupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n 新用户组 将用户组的名字改为新名字 例1： # groupmod –g 10000 -n group3 group2 ##此命令将组group2的标识号改为10000，组名修改为group3。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"添加用户账号 信息\r\r参数说明： 选项: -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名: 指定新账号的登录名。 useradd 选项 用户名 例1： # useradd –d /usr/peter -m peter ##创建用户peter，其中-d和-m选项用来为登录名peter产生一个主目录/usr/peter。 例2： # useradd -s /bin/sh -g group1 –G group2,root peter2 ##新建用户peter2，登录Shell是 /bin/sh，属于group1，又属于group2和root。 这里可能新建组：#groupadd group1及groupadd group2 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:4","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"删除账号 信息\r\r userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 例如： # userdel -r peter2 ##删除用户peter2（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:5","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"修改账号 信息\r\rusermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： # usermod -s /bin/sh -d /home/p –g group2 peter ##将用户peter的登录Shell修改为sh，主目录改为/home/p，用户组改为group2。 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:6","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"用户口令的管理 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 信息\r\rpasswd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。\r\r 如果默认用户名，则修改当前用户的口令。例如，假设当前用户是peter，则下面的命令修改该用户自己的口令： 信息\r\r$ passwd Old password:****** New password:******* Re-enter new password:*******\r\r 如果是超级用户，可以用下列形式指定任何用户的口令： 信息\r\r# passwd peter New password:******* Re-enter new password:*******\r\r 为用户指定空口令时，执行下列形式的命令：# passwd -d peter passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：# passwd -l peter ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:7","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"切换用户组 信息\r\r$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:8","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"与用户账号有关的系统文件 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等 /etc/passwd文件 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 信息\r\r例子： ＃ cat /etc/passwd root:x:0:0:Superuser:/: daemon:x:1:1:System daemons:/etc: bin:x:2:2:Owner of system commands:/bin: sys:x:3:3:Owner of system files:/usr/sys: adm:x:4:4:System accounting:/usr/adm: uucp:x:5:5:UUCP administrator:/usr/lib/uucp: auth:x:7:21:Authentication administrator:/tcb/files/auth: cron:x:9:16:Cron daemon:/usr/spool/cron: listen:x:37:4:Network daemon:/usr/net/nls: lp:x:71:18:Printer administrator:/usr/spool/lp: \r\r 每一行记录对应着一个用户（其中bin/sys/adm/uucp/lp/nobody是伪用户），每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell /etc/group文件 用户组的所有信息都存放在/etc/group文件中。 信息\r\rroot::0:root bin::2:root,bin sys::3:root,uucp adm::4:root,adm daemon::5:root,daemon lp::7:root,lp users::20:root,sam\r\r 此文件的格式类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:2:9","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"3. 文件与目录 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"文件基本属性 1. 文件的属性概貌 Lighthouse (image)\"\rLighthouse (image)\r 信息\r\r第一个字符：代表这个文件的类型，是目录、文件，还是一个链接等等 [ d ] 目录 [ - ] 文件 [ l ] 链接文档(link file) [ b ] 可供储存的接口设备(可随机存取装置) [ c ] 串行端口设备，例如键盘、鼠标(一次性读取装置) 接下来的字符：以三个一组分成三组，用 r、w、x 三个参数的组合表示，位置不会改变 [ r ] 代表可读(read) [ w ] 代表可写(write) [ x ] 代表可执行(execute) [ - ] 没有权限\r\r 2. 文件的属主与属组 每一个文件，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 chgrp：更改文件属组 信息\r\rchgrp [-R] 属组名 文件名 参数选项 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。\r\r chown：更改文件属主，也可以同时更改文件属组 语法： chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 进入 /root 目录（~）将install.log的拥有者改为bin这个账号： 例： chown root:root aa ##更改aa的属主与属组 chmod：更改文件9个属性 文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！ 变更权限的指令chmod的语法是这样的： 信息\r\r chmod [-R] xyz 文件或目录 选项与参数： xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下： chmod +x aa ##更改aa的属性,加x权限 chmod 777 aa ##更改aa的属性，三组权限都设置成7 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"文件与目录管理命令 使用 man [命令] 来查看各个命令的使用文档，如 ：man cp 信息\r\rls: 列出目录 —ll cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 —–scp网络复制 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"硬链接与软链接 硬连接 信息\r\r硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\r\r 软连接 信息\r\r另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 例： $touch a #创建一个测试文件a $ ln a b #创建a的一个硬连接文件b –echo 123 \u003e a ##a,b的内容同时变为123 $ ln -s a c #创建a的一个符号连接文件c $ ls -li # -i参数显示文件的inode节点信息 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:3:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"4. 安装程序rpm/yum ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"1. rpm方式 需要去下载相应的rpm格式的安装包xxxx.rpm 信息\r\rrpm [参数] rpm包 -i 安装 -U 更新（很少用） -e 卸载 -v 显示安装信息 -h 显示安装进度 例： rpm -ivh jdk-8u172-linux-x64.rpm 安装jdk8并显示安装进度和安装信息 rpm -qa|grep jdk查看jdk的安装包 rpm -e jdk1.8-1.8.0_221-fcs.x86_64 卸载jdk8 ，只适用于rpm包安装的软件\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"2. yum方式 yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。 基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 2.1 yum语法 信息\r\ryum [options] [command] [package …] options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为\"yes\"），-q（不显示安装的过程）等等。 command：要进行的操作。 package操作的对象。 例： yum search jdk 搜索jdk安装包 yum install -y java-1.8.0-openjdk.x86_64 安装openjdk，-y表示安装过程中的询问自动选y yum list installed ｜grep jdk 列出安装的jdk软件包 yum remove java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-headless.x86_64 卸载jdk\r\r 2.2 yum常用命令 示例\r\r1.列出所有可更新的软件清单命令：yum check-update 2.更新所有软件命令：yum update 3.仅安装指定的软件命令：yum install \u003cpackage_name\u003e 4.仅更新指定的软件命令：yum update \u003cpackage_name\u003e 5.列出所有可安裝的软件清单命令：yum list 6.删除软件包命令：yum remove \u003cpackage_name\u003e 7.查找软件包 命令：yum search 8.清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers\r\r 2.3 yum源 官方的yum源在国内访问效果不佳。需要改为国内比较好的阿里云或者网易的yum源 在/etc/yum..repos.d/下进行如下操作(请做好相应备份)： 示例\r\rwget http://mirrors.163.com/.help/CentOS7-Base-163.repo mv CentOS7-Base-163.repo CentOS-Base.repo 重建缓存： yum clean all yum makecache\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"3. 配置环境变量 在Linux系统下，安装应用程序后，在安装目录之外，可能仍然会出现 “command not found ”。 要解决所有地方都能使用应用程序，就涉及到环境变量path的设置问题 3.1 配置环境变量 系统环境变量文件在/etc下的profile文件，我们可以用vi profile命令来编辑该文件，将变量添加进去 一般需要将安装文件的bin目录加入path中，可在profile中加入下面一行代码，如： 示例\r\rvim /etc/profile # 末尾追加以下内容 export JAVA_HOME=/usr/java/default export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\r\r 3.2 环境变量生效 source /etc/profile ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:4:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"5. shell脚本 shell语言是一门linux系统下的工具语言，主要用于写一些linux系统下的操作命令，实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。或者直接理解为shell命令是可以执行多个linux命令的脚本。Shell 种类众多，有以下种类（一般使用的 Bash，就是 Bourne Again Shell，它是大多数Linux 系统默认的 Shell）： 示例\r\rBourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh）\r\r shell并不复杂，有编程基础的话，简单入门两三个小时就可以入门，主要是把一些重复操作的linux命令写成shell脚本来执行一下。以下列出shell常规的一些要素： ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:5:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"1. 解释器与执行shell 示例\r\r解释器 #!/bin/sh Bourne shell版本 #!/bin/bash Bourne Again Shell 版本 执行shell chomd +x ./test.sh #使脚本具有执行权限 ./test.sh #执行脚本 “./”表示当前目录下\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:5:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"2. 演示 #!/bin/bash ##声明bash脚本 ##demo ##注释 echo $PATH ##打印PATH环境变量 name=\"Peter\" ##定义变量name echo $name ##打印name值 echo \"I am ${name}'s friend\" ##字符串拼接 echo \"\" name2=\"I am ${name}'s good friend\" ##字符串拼接 echo $name2 echo \"\" names=(\"Peter\" \"james\" \"deer\") ##定义数组 echo ${names[@]} ##遍历数组 echo \"I am ${names[1]}'s friend\" ##第二个元素 echo \"I have ${#names[@]}friends\" ##数组长度 echo \"\" for var in ${names[@]}; ##循环数组 do if test $var = 'Peter' ##字符串相等 then echo \"I am Peter\" else echo \"I am ${var}'s friend\" fi done echo \"\" if [ $(ps -ef | grep -c \"ssh\") -gt 1 ]; ##查找是否有ssh服务 then echo \"ssh service open\"; fi echo \"\" echo \"sh arg: $0$1\" ##sh的传参 重定向： 1、test ‘aa’ -eq “bb” \u003e out ##命令输出到 out文件，报错信息并不会进入out 2、test ‘aa’ -eq “bb” \u003e out 2\u003e\u00261 ##将stderr合并到stdout，则报错信息进入了out ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:5:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6. 常用命令 ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:0","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.1 最常用的是cd 命令 示例\r\rcd 进入用户主目录； cd ~ 进入用户主目录； cd - 返回进入此目录之前所在的目录； cd .. 返回上级目录（若当前目录为“/“，则执行完后还在“/\"；\"..“为上级目录的意思）； cd ../.. 返回上两级目录；\r\r ls，ll， wget， curl， history ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:1","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.2 新建文件夹和文件：mkdir touch 示例\r\rmkdir 创建文件夹 mkdir dirname 直接跟文件夹名，可在当前目录下创建文件夹 mkdir /opt/lamp/dirname 可跟路径 mkdir -p /opt/lam/dirname 假如lam不存在，需要用-p才可以创建该文件夹 touch 新建文件 touch dilename 可直接跟文件名在当前目录下创建新的文件 \r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:2","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.3 cat/less/more/tail等文件查看命令 详细\r\r-n或-number：有1开始对所有输出的行数编号； -b或–number-nonblank：和-n相似，只不过对于空白行不编号； -s或–squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行； -A：显示不可打印字符，行尾显示“$”； -e：等价于\"-vE\"选项； -t：等价于\"-vT\"选项； -e：文件内容显示完毕后，自动退出； -f：强制显示文件； -g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度； -l：搜索时忽略大小写的差异； -N：每一行行首显示行号； -s：将连续多个空行压缩成一行显示； -S：在单行显示较长的内容，而不换行显示； -x\u003c数字\u003e：将TAB字符显示为指定个数的空格字符。 -\u003c数字\u003e：指定每屏显示的行数； -d：显示“[press space to continue,‘q’ to quit.]”和“[Press ‘h’ for instructions]”； -c：不进行滚屏操作。每次刷新这个屏幕； -s：将多个空行压缩成一行显示； -u：禁止下划线； +\u003c数字\u003e：从指定数字的行开始显示。 按Space键：显示文本的下一屏内容。 按Enier键：只显示文本的下一行内容。 按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。 按H键：显示帮助屏，该屏上有相关的帮助信息。 按B键：显示上一屏内容。 按Q键：退出rnore命令。 –retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用； -c或——bytes=：输出文件尾部的N（N为整数）个字节内容； -f或；–follow：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效； -F：与选项“-follow=name”和“–retry\"连用时功能相同； -n或——line=：输出文件的尾部N（N位数字）行内容。 –pid=\u003c进程号\u003e：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令； -q或——quiet或——silent：当有多个文件参数时，不输出各个文件名； -s\u003c秒数\u003e或——sleep-interal=\u003c秒数\u003e：与“-f”选项连用，指定监视文件变化时间隔的秒数； -v或——verbose：当有多个文件参数时，总是输出各个文件名； 一般tail命令最常用的-n和-f，例： tail filename 读取filename最后10行内容 tail -f filename 实时动态读取filename最后10行内容 tail -20f filename 实时动态读取filename最后20行内容 \r\r cat和less及more指令相似，cat是一次性读取所有内容，文件内容较多时速度较慢。less与more的区别在于：less可以前后翻页查看，more只能向前翻页查看。 tail则用于实时获取log信息，从后向前读取内容 上述四种命令均可跟grep搭配使用cat/less/tail |grep mysql ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:3","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.4 查看文件大小的命令 du/df 详细\r\rdu -sh * 显示当前目录下所有文件的大小 du -sh filename 显示该文件大小 du -sh 显示当前目录所占空间大小 -s或 仅显示总计，只列出最后加总的值。 -h或 以K，M，G为单位，提高信息的可读性。 df 显示磁盘占用信息 直接df默认一k为单位 df -lh 显示本地系统的占用信息，以K，M，G为单位\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:4","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.5 大重点–文本编辑器 vi 详细\r\rvi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。 Linux中的vi编辑器叫vim，它是vi的增强版（vi Improved），与vi编辑器完全兼容，而且实现了很多增强功能。 vi编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用vi编辑器就必须熟练掌握着两种模式的切换。 默认情况下，打开vi编辑器后自动进入命令模式。从编辑模式切换到命令模式使用“esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。 vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下： Ctrl+u：向文件首翻半屏； 2 Ctrl+d：向文件尾翻半屏； 3 Ctrl+f：向文件尾翻一屏； 4 Ctrl+b：向文件首翻一屏； 5 Esc：从编辑模式切换到命令模式； 6 ZZ：命令模式下保存当前文件所做的修改后退出vi； 7 :行号：光标跳转到指定行的行首； 8 :$：光标跳转到最后一行的行首； 9 x或X：删除一个字符，x删除光标后的，而X删除光标前的； 10 D：删除从当前光标到光标所在行尾的全部字符； 11 dd：删除光标行正行内容； 12 ndd：删除当前行及其后n-1行； 13 nyy：将当前行及其下n行的内容保存到寄存器?中，其中？为一个字母，n为一个数字； 14 p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方； 15 P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方； 16 /字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示； 17 ？name：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示； 18 a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作； 19 a：在当前字符后添加文本； 20 A：在行末添加文本； 21 i：在当前字符前插入文本； 22 I：在行首插入文本； 23 o：在当前行后面插入一空行； 24 O：在当前行前面插入一空行； 25 :wq：在命令模式下，执行存盘退出操作； 26 :w：在命令模式下，执行存盘操作； 27 :w！：在命令模式下，执行强制存盘操作； 28 :q：在命令模式下，执行退出vi操作； 29 :q！：在命令模式下，执行强制退出vi操作； 30 :e文件名：在命令模式下，打开并编辑指定名称的文件； 31 :n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件； 32 :f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例； 33 :set nu：在命令模式下，用于在最左端显示行号； 34 :set nonu：在命令模式下，用于在最左端不显示行号； 35 :1,3y 复制第一行到第三行 36 :1,3d 删除第一行到第三行 37 :1,3s/str/str_new/g 替换第一行到第三行中的字符串 38 :1,3s/str/str_new 替换第一行到第三行中的字符串第一个字符 39 :1,3 g/str /d 删除第一行到第三行中含有这个字符串的行\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:5","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.6 重定向 \u003e 输出重定向 who \u003e bbb.txt 将aaa的内容写入bbb中，覆盖写入 cat bbb.txt » ccc.txt 讲aaa的内容追加写入bbb中，不覆盖原来内容 \u003e bbb.txt 将bbb清空 输入重定向 grep 05:37:43.730 \u003c web.2019-07-22.0.log 大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。 一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。 同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 重定向深入理解 详细\r\r一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：  标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。  标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。  标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command \u003e file 将 stdout 重定向到 file，command \u003c file 将stdin 重定向到 file。\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:6","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.7 查看服务 详细\r\rnetstat -nlpt|grep 80 查看该端口号是否被占用 free -m //查看LINUX内存剩余容量 ps可以查看具体的进程信息，一般与管道符连接其他命令使用，如：grep ps常用参数-ef/-aux，一般最常用还是-ef，例：ps -ef|grep mysql 查询mysql进程 top也可查看进程信息，而且是动态显示 whoami 查看当前登陆用户 who 查看多少用户在使用系统 date查看系统时间，可跟时间格式使用 cal查看日历，可跟年份，查看指定的年份 chkconfig –list #查看系统服务启动 chkconfig iptables on #开机启动该服务 chkconfig iptables off #开机不启动该服务 service iptables start #启动该服务 service iptables restart #重启启该服务 ps -ef|grep mysql|grep -v grep|awk ‘{print $2}‘ps -ef|grep mysql 是查询mysql服务的进程 |后的grep -v grep 是匹配不包含grep的行 awk是取查询结果的第几列，awk ‘{print $2}‘则是取第二列的值 grep 无参数则显示匹配的行 -c 显示匹配的行数 -v 显示不匹配的行\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:7","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.8 杀掉进程 kill命令 详细\r\rkill最常用的参数是-9，用法：kill -9 进程号 即可强制杀掉该进程 统计命令 wc 常用的参数是 -l 用法：wc -l ，例： ps -ef|grep mysql|wc -l 统计查询出的mysql进程的行数 查找命令 find/locate/whereis/which find -name 后跟文件名，可查看文件所在目录，可跟user，查看属于user的文件 find -name filename 查找filename所在目录 find -name name* 查找开头为name的文件所在目录 find -name *name 查找结尾为name的文件所在目录 find -name *name* 查找包含name字符串的文件所在目录 find -user faith 查看用户faith的文件 locate用法与find基本相似，只是locate搜索速度较快些，locate一般系统不会自带，需要安装，可用yum安装 whereis只能搜索程序名 which则是只查询path中的环境变量\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:8","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.9 压缩和解压命令 gzip/guzip zip/unzip tar 详细\r\rgzip和gunzip一般可用参数是-r，例: gzip test.txt　压缩文件 gzip -r test 压缩所有test下的子文件 gunzip test.gz 解压文件 zip和unzip可用参数较多，例： zip test 不跟参数直接使用 zip -r test 递归压缩test下所有文件 unzip test 不跟参数直接使用 unzip -n 解压时不覆盖已存在的文件 unzip -o 解压时覆盖已存在的文件 unzip -d 将文件解压到目录中去 tar使用的较为多些，用法也多，最常用的是zxcvf几个参数，例： -c 创建新文档，就是代表压缩的意思 -x 解压文档 -f 使用归档文件 -z 使用gzip解压 -v 详细输出模式 最为常用的使用方法： tar -zcvf test.tar test 将test压缩为test.tar并输出详细信息 tar -zxvf test.tar 将test.tar解压缩，并输出详细信息\r\r ","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:9","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["系统"],"content":"6.10 定时任务 crontab 详细\r\rcrontab [-u user] 文件 crontab [-u user] {-r -e -l} 不加-u的话默认当前用户 －e：执行文字编辑器来设定时程表，内定的文字编辑器是vi。 －r：删除目前的时程表。 －l：列出目前的时程表。 crontab -e 就可以打开一个文件进行编辑 crontab文件的格式为“M H D m d cmd”，M为分钟1-59，H为小时1-24，D为天1-31，m为月1-12，d为周0-6（0为周日）。cmd代表要执行的程序，*代表每分钟都执行 * * * * * sh /opt/lampp/test.sh 表示每分钟执行一次test.sh这个脚本 */5 * * * * sh /opt/lampp/test.sh 表示每5分钟执行一次test.sh这个脚本 30 21 * * * /usr/local/apache/bin/apachectl restart 表示每晚的21:30重启apache\r\r","date":"2020-11-18","objectID":"/posts/linux/linux-basics/:6:10","tags":["linux"],"title":"Linux基础","uri":"/posts/linux/linux-basics/"},{"categories":["文档"],"content":"比较使用的工具软件/插件。例：密码管理器、谷歌浏览器常用插件等。","date":"2020-11-18","objectID":"/posts/docs/software-tools/","tags":["工具"],"title":"工具软件","uri":"/posts/docs/software-tools/"},{"categories":["文档"],"content":"常用的 ","date":"2020-11-18","objectID":"/posts/docs/software-tools/:1:0","tags":["工具"],"title":"工具软件","uri":"/posts/docs/software-tools/"},{"categories":["文档"],"content":"密码管理器 keepass 1 Password ","date":"2020-11-18","objectID":"/posts/docs/software-tools/:1:1","tags":["工具"],"title":"工具软件","uri":"/posts/docs/software-tools/"},{"categories":["文档"],"content":"谷歌浏览器插件 Video DownloadHelper 一款视频下载插件，网页上能看的视频几乎都可以捕捉下载 GitHub加速 国内Github下载很慢，这个插件可以提升下载速度 谷歌访问助手 见名知意、有了它，谷歌可以访问了，虽然依旧龟速 沙拉查词-聚合词典划词翻译 多语言混合网页阅读利器 ","date":"2020-11-18","objectID":"/posts/docs/software-tools/:1:2","tags":["工具"],"title":"工具软件","uri":"/posts/docs/software-tools/"},{"categories":["文档"],"content":"Redis客户端工具 Another Redis Desktop Manager 开源软件，用着还可以 Redis Desktop Manager 官方工具，新版部分功能收费 ","date":"2020-11-18","objectID":"/posts/docs/software-tools/:1:3","tags":["工具"],"title":"工具软件","uri":"/posts/docs/software-tools/"},{"categories":["文档"],"content":"与开发有关的常用在线工具。如：json解析、程序员在线工具箱等","date":"2020-11-18","objectID":"/posts/docs/online-tools/","tags":["工具"],"title":"在线工具","uri":"/posts/docs/online-tools/"},{"categories":["文档"],"content":"Markdown在线编辑器 JSON解析 程序员在线工具箱 程序员在线工具箱2 ","date":"2020-11-18","objectID":"/posts/docs/online-tools/:0:0","tags":["工具"],"title":"在线工具","uri":"/posts/docs/online-tools/"},{"categories":["文档"],"content":"常见官方网址导航","date":"2020-11-18","objectID":"/posts/docs/official-website-about-technology/","tags":["网站"],"title":"常见官网","uri":"/posts/docs/official-website-about-technology/"},{"categories":["文档"],"content":"36 ","date":"2020-11-18","objectID":"/posts/docs/official-website-about-technology/:0:0","tags":["网站"],"title":"常见官网","uri":"/posts/docs/official-website-about-technology/"},{"categories":["文档"],"content":"技术相关 Markdown中文网 清华大学开源软件镜像站 w3cschool github HBuilder Data Structure Visualizations visualgo OSCHINA-中国开源技术交流社区 阿里云云效Maven Maven中央仓库 SpringBoot官方文档 Nacos官网 菜鸟教程 jekyll主题 jekyll中文文档 jekyll英文文档 Hugo官网 Hugo英文文档 Hugo中文文档 图标网 阿里巴巴矢量图标库 Markdown 中文网 LeanCloud valine文档 一套绝佳的图标字体库和CSS框架 数安时代-免费SSL证书 Gravatar - 全球公认的头像 ","date":"2020-11-18","objectID":"/posts/docs/official-website-about-technology/:1:0","tags":["网站"],"title":"常见官网","uri":"/posts/docs/official-website-about-technology/"},{"categories":["文档"],"content":"其他 keepass ","date":"2020-11-18","objectID":"/posts/docs/official-website-about-technology/:2:0","tags":["网站"],"title":"常见官网","uri":"/posts/docs/official-website-about-technology/"},{"categories":["日志"],"content":"logback常见配置","date":"2020-11-16","objectID":"/posts/technology-other/logback-configurature/","tags":["logback"],"title":"logback配置","uri":"/posts/technology-other/logback-configurature/"},{"categories":["日志"],"content":"logback配置 此配置将不同几倍的日志归置到不同的文件中。 项目中使用，将对应的property属性值更改即可。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- 日志级别从低到高分为TRACE \u003c DEBUG \u003c INFO \u003c WARN \u003c ERROR \u003c FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\u003e \u003c!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --\u003e \u003c!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\u003e \u003c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\u003e \u003cconfiguration scan=\"true\" scanPeriod=\"10 seconds\"\u003e \u003ccontextName\u003elogback\u003c/contextName\u003e \u003c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --\u003e \u003cproperty name=\"log.path\" value=\"logs\"/\u003e \u003cproperty name=\"project.name\" value=\"project-name\"/\u003e \u003c!--0. 日志格式和颜色渲染 --\u003e \u003c!-- 彩色日志依赖的渲染类 --\u003e \u003cconversionRule conversionWord=\"clr\" converterClass=\"org.springframework.boot.logging.logback.ColorConverter\"/\u003e \u003cconversionRule conversionWord=\"wex\" converterClass=\"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter\"/\u003e \u003cconversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\"/\u003e \u003c!-- 彩色日志格式 --\u003e \u003cproperty name=\"CONSOLE_LOG_PATTERN\" value=\"${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(%L:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\"/\u003e \u003c!--1. 输出到控制台--\u003e \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003c/filter\u003e \u003cencoder\u003e \u003cPattern\u003e${CONSOLE_LOG_PATTERN}\u003c/Pattern\u003e \u003c!-- 设置字符集 --\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!--2. 输出到文档--\u003e \u003c!-- 2.1 level为 DEBUG 日志，时间滚动输出 --\u003e \u003cappender name=\"DEBUG_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-debug.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c!-- 设置字符集 --\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 日志归档 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-debug-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录debug级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003edebug\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.2 level为 INFO 日志，时间滚动输出 --\u003e \u003cappender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-info.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} %L - %msg%n\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 每天日志归档路径以及格式 --\u003e \u003cfileNamePattern\u003e${log.path}/${project.name}-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e10MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文档保留天数--\u003e \u003cmaxHistory\u003e15\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文档只记录info级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003einfo\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!-- 2.3 level为 WARN 日志，时间滚动输出 --\u003e \u003cappender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 正在记录的日志文档的路径及文档名 --\u003e \u003cfile\u003e${log.path}/${project.name}-warn.log\u003c/file\u003e \u003c!--日志文档输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%","date":"2020-11-16","objectID":"/posts/technology-other/logback-configurature/:0:0","tags":["logback"],"title":"logback配置","uri":"/posts/technology-other/logback-configurature/"},{"categories":null,"content":"关于我 程序员。 极简主义。 曾喜欢玩游戏 （🎮 LOL S5 网一钻二、16年开始基本不玩了、没时间）。 热爱技术，喜欢瞎倒腾。生命不息、折腾不止（例如这个博客）😄。 怕什么真理无穷，进一寸有一寸的欢喜。 现居于上海。 ","date":"2020-11-16","objectID":"/about/:0:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"技术栈 数据库：mysql、redis、mongoDB、zookeeper等。 框架：spring、mybatis、springboot、springcloud系列（eureka、hystrix、ribbon、feign、zuul、actuator）、dubbo等。 java：并发编程、JVM调优、netty。 其他：tomcat、nginx、openresty、rabbitmq、docker、docker-compose等。 ","date":"2020-11-16","objectID":"/about/:0:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"博客 始建于2020年11月14日，尝试过jekyll。（后知后觉，原来这天是我生日） 目前使用 hugo ，部署于 阿里云ECS ，对象存储 阿里云OSS 。 自动发布使用 Gitee-WebHooks （最初在github，提交代码太卡） + 自写脚本 。 ","date":"2020-11-16","objectID":"/about/:0:3","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"网址 https://wlizhi.cc ：注册于2020年11月16日 https://wlz922.top ：注册于2017年11月20日 https://wlizhi.github.io https://wlizhi.gitee.io （个人版，无自动发布，很少更新） ","date":"2020-11-16","objectID":"/about/:0:4","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"友情链接 Jack大佬 | 叶良辰 ","date":"2020-11-16","objectID":"/about/:0:5","tags":null,"title":"关于","uri":"/about/"}]